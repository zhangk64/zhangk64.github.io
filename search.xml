<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OAuth 2.0 是要通过什么方式解决什么问题？</title>
    <url>/2024/07/19/01/</url>
    <content><![CDATA[<p>我想先问你个问题。第一次使用极客时间 App 的时候，你是直接使用了第三方帐号（比如微信、微博）登录，还是选择了重新注册新用户？如果你选择了重新注册用户，那你还得上传头像、输入用户名等信息。但如果你选择了使用第三方帐号微信来登录，那极客时间会直接使用你微信的这些信息作为基础信息，你就能省心很多。</p>
<p>到这里，我估计你会问，这是怎么实现的？微信把我的个人信息给了极客时间，它又是怎么保证我的数据安全的呢？</p>
<p>其实，微信这一系列授权背后的原理都可以归到一个词上，那就是 OAuth 2.0。今天这节课，我们就来看看 OAuth 2.0 到底是什么、能干什么以及它是怎么干的。</p>
<h2 id="OAuth-2-0-是什么？"><a href="#OAuth-2-0-是什么？" class="headerlink" title="OAuth 2.0 是什么？"></a>OAuth 2.0 是什么？</h2><p>用一句话总结来说，<strong>OAuth 2.0 就是一种授权协议</strong>。那如何理解这里的「授权」呢？</p>
<p>我举个咱们生活中的例子。假如你是一名销售人员，你想去百度拜访你的大客户王总。到了百度的大楼之后，保安拦住了你，问你要工牌。你说：「保安大哥啊，我是来拜访王总的，哪里有什么工牌」。保安大哥说：「那你要去前台做个登记」。</p>
<p>然后你就赶紧来到前台，前台美女问你是不是做了登记。你说王总秘书昨天有要你的手机号，说是已经做过预约。小姐姐确认之后往你的手机发了个验证码，你把验证码告诉了前台小姐姐之后，她给了你一张门禁卡，于是你就可以开心地去见王总了。</p>
<p>你看，这个例子里面 <strong>就有一次授权</strong>。本来你是没有权限进入百度大楼的，但是经过前台小姐姐一系列的验证之后，她发现你确实是来拜访客户的，<strong>于是给了你一张临时工牌。这整个过程就是授权</strong>。</p>
<p>我再举一个电商的场景，你估计更有感觉。假如你是一个卖家，在京东商城开了一个店铺，日常运营中你要将订单打印出来以便给用户发货。但打印这事儿也挺繁琐的，之前你总是手工操作，后来发现有个叫「小兔」的第三方软件，它可以帮你高效率地处理这事。</p>
<p>但你想想，小兔是怎么访问到这些订单数据的呢？其实是这样，<strong>京东商城提供了开放平台，小兔通过京东商家开放平台的 API 就能访问到用户的订单数据</strong>。</p>
<p>只要你在软件里点击同意，小兔就可以拿到一个访问令牌，通过访问令牌来获取到你的订单数据帮你干活儿了。你看，<strong>这里也是有一次授权</strong>。你要是不同意，平台肯定不敢把这些数据给到第三方软件。</p>
<h2 id="为什么用-OAuth-2-0？"><a href="#为什么用-OAuth-2-0？" class="headerlink" title="为什么用 OAuth 2.0？"></a>为什么用 OAuth 2.0？</h2><p>基于上面两种场景的解决方案，关于授权我们最容易想到的方案就是提供钥匙。比如，你要去百度拜访王总，那前台小姐姐就给你张百度的工牌；小兔要获取你的订单信息，那你就把你的用户名和密码给它。但稍微有些安全意识，我们都不会这样做。</p>
<p><strong>因为你有了百度工牌，那以后都可以随时自由地进出了</strong>，这显然不是百度想要的。所以，百度有一套完整的机制，<strong>通过给你一张临时工牌，实现在保证安全的情况下，还能让你去大楼里面见到王总</strong>。相应地，小兔软件请求访问你的订单数据的过程，也会涉及这样一套授权机制，那就是 OAuth 2.0。它通过给小兔软件一个访问令牌，而不是让小兔软件拿着你的用户名和密码，去获取你的订单数据帮你干活儿。</p>
<p>其实，除了小兔软件这个场景，在如今的互联网世界里用到 OAuth 2.0 的地方非常多，只是因为它隐藏了实现细节，需要我们多做分析才能发现它。比如，当你使用微信登录其他网站或者 App 的时候，当你开始使用某个小程序的时候，你都在无感知的情况下用到了 OAuth 2.0。</p>
<p>那总结来说，<strong>OAuth 2.0 这种授权协议，就是保证第三方（软件）只有在获得授权之后，才可以进一步访问授权者的数据</strong>。因此，我们常常还会听到一种说法，OAuth 2.0 是一种安全协议。现在你知道了，这种说法也是正确的。</p>
<p>现在访问授权者的数据主要是通过 Web API，所以凡是要保护这种对外的 API 时，都需要这样授权的方式。而 OAuth 2.0 的这种颁发访问令牌的机制，是再合适不过的方法了。同时，这样的 Web API 还在持续增加，所以 OAuth 2.0 是目前 Web 上重要的安全手段之一了。</p>
<h2 id="OAuth-2-0-是怎样运转的？"><a href="#OAuth-2-0-是怎样运转的？" class="headerlink" title="OAuth 2.0 是怎样运转的？"></a>OAuth 2.0 是怎样运转的？</h2><p>现在，我相信你已经对 OAuth 2.0 有了一个整体印象，接下来咱们再看看它是怎么运转的。</p>
<p>我们还是来看上面提到的小兔打单软件的例子吧。假如小明在京东上面开了一个店铺，小明要管理他的店铺里面的订单，于是选择了使用小兔软件。</p>
<p>现在，让我们把「小明」「小兔软件」「京东商家开放平台」放到一个对话里面，看看他们是怎么沟通的吧。</p>
<ul>
<li><p><strong>小明</strong>：你好，小兔软件。我正在 Google 浏览器上面，需要访问你来帮我处理我在京东商城店铺的订单。</p>
</li>
<li><p><strong>小兔软件</strong>：好的，小明，我需要你给我授权。现在我把你引导到京东商家开放平台上，你在那里给我授权吧。</p>
</li>
<li><p><strong>京东商家开放平台</strong>：你好，小明。我收到了小兔软件跳转过来的请求，现在已经准备好了一个授权页面。你登录并确认后，点击授权页面上面的授权按钮即可。</p>
</li>
<li><p><strong>小明</strong>：好的，京东商家开放平台。我看到了这个授权页面，已经点授权按钮啦😄</p>
</li>
<li><p><strong>京东商家开放平台</strong>：你好，小兔打单软件。我收到了小明的授权，现在要给你生成一个授权码 code 值，我通过浏览器重定向到你的回调 URL 地址上面了。</p>
</li>
<li><p><strong>小兔软件</strong>：好的，京东商家开放平台。我现在从浏览器上拿到了授权码，现在就用这个授权码来请求你，请给我一个访问令牌 access_token 吧。</p>
</li>
<li><p><strong>京东商家开放平台</strong>：好的，小兔打单软件，访问令牌已经发送给你了。</p>
</li>
<li><p><strong>小兔打单软件</strong>：太好了，我现在就可以使用访问令牌来获取小明店铺的订单了。</p>
</li>
<li><p><strong>小明</strong>：我已经能够看到我的订单了，现在就开始打单操作了。</p>
</li>
</ul>
<p>下面，为了帮助你理解，我再用一张图来描述整个过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/77197844a8f41a33cb68947b1dc9ee79.png"
                      alt="img"
                ></p>
<p>再分析下这个流程，我们不难发现小兔软件最终的目的，是要获取一个叫做「访问令牌」的东西。从最后一步也能够看出来，在小兔软件获取到 <strong>访问令牌</strong> 之后，才有足够的 「能力」 去请求小明的店铺的订单，也就是才能够帮助小明打印订单。</p>
<p>那么，小兔软件是怎么获取访问令牌的值的呢？我们会发现还有一个叫做「授权码」的东西，也就是说小兔软件是 拿<strong>授权码换取的访问令牌</strong>。</p>
<p>小兔软件又是怎么拿到 <strong>授权码</strong> 的呢？从图中流程刚开始的那一步，我们就会发现，<strong>是在小明授权之后</strong>，才产生的授权码，上面流程中后续的一切动作，实际上都是在小明对小兔软件授权发生以后才产生的。其中主要的动作，就是 <code>生成授权码 –&gt; 生成访问令牌 –&gt; 使用访问令牌</code>。</p>
<p>到这里，我们不难发现，<strong>OAuth 2.0 授权的核心就是颁发访问令牌、使用访问令牌，</strong> 而且不管是哪种类型的授权流程都是这样。你一定要理解，或者记住这句话，它是整个流程的核心。你也可以再回想下，去百度拜访王总的例子。如果你是百度这套机制的设计者的话，会怎么设计这套授权机制呢。想清楚了这个问题，你再去理解令牌、授权码啥的也就简单了。</p>
<p>在小兔软件这个例子中呢，我们使用的就是授权码许可（Authorization Code）类型。它是 OAuth 2.0 中最经典、最完备、最安全、应用最广泛的许可类型。除了授权码许可类型外，OAuth 2.0 针对不同的使用场景，还有 3 种基础的许可类型，分别是隐式许可（Implicit）、客户端凭据许可（Client Credentials）、资源拥有者凭据许可（Resource Owner Password Credentials）。相对而言，这 3 种授权许可类型的流程，在流程复杂度和安全性上都有所减弱（在后续与你详细分析）。</p>
<p>因此，在这个课程中，我会频繁用授权码许可类型来举例。至于为什么称它为授权码许可，为什么有两次重定向，以及这种许可类型更详细的通信流程又是怎样的，我会在下一讲给你深入分析，你可以先不用关注。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我来回给你举例子，其实就是希望你能理解 OAuth 到底是什么，为什么需要它，以及它大概的运行逻辑是怎样的。总结来说，我需要你记住以下这 3 个关键点：</p>
<ul>
<li><p>OAuth 2.0 的核心是授权许可，更进一步说就是令牌机制。也就是说，像小兔软件这样的第三方软件只有拿到了京东商家开放平台颁发的访问令牌，也就是得到了授权许可，然后才可以 <strong>代表</strong> 用户访问他们的数据。</p>
</li>
<li><p>互联网中所有的受保护资源，几乎都是以 Web API 的形式来提供访问的，比如极客时间 App 要获取用户的头像、昵称，小兔软件要获取用户的店铺订单，我们说 OAuth 2.0 与安全相关，是用来保护 Web API 的。另外，第三方软件通过 OAuth 2.0 取得访问权限之后，用户便把这些权限 <strong>委托</strong> 给了第三方软件，我们说 OAuth 2.0 是一种委托协议，也没问题。</p>
</li>
<li><p>也正因为像小兔这样的第三方软件，每次都是用访问令牌而不是用户名和密码来请求用户的数据，才大大减少了安全风险上的「攻击面」。不然，我们试想一下，每次都带着用户名和密码来访问数量众多的 Web API ，是不是增加了这个「攻击面」。因此，我们说 OAuth 2.0 的核心，就是颁发访问令牌和使用访问令牌。</p>
</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你可以再花时间想下小兔软件获取用户订单信息的那个场景，如果让你来设计整个的授权流程，你会怎么设计？还有没有更好的方式？</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><p>为什么要用授权码换取 token，而不是直接获取 token？</p>
<p>直接获取 token 的场景是有的，客户端凭据许可类型就是这样的使用场景，但是我们会在课程里面讲到，<strong>授权码许可类型是 OAuth 2.0 最安全 最完备的许可类型</strong>。</p>
<p>以 Web 场景为例，第一次用户是跟第三方软件建立的联系，三方软件要把用户引导到平台一方去授权，这个时候用户实际上跟三方软件就失去了联系，平台如果这个时候直接把令牌给了三方软件，因为没了联系，三方软件就不能很方便的告诉用户。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>授权服务：授权码和访问令牌的颁发流程是怎样的？</title>
    <url>/2024/07/19/03/</url>
    <content><![CDATA[<p>在上一讲，我从为什么需要授权码这个问题开始，为你串了一遍授权码许可流程整体的通信过程。在接下来的三讲中，我会着重为你 <strong>讲解关于授权服务的工作流程、授权过程中的令牌，以及如何接入 OAuth 2.0</strong>。这样一来，你就可以吃透授权码许可这一最经典、最完备、最常用的授权流程了，以后再处理授权相关的逻辑就更得心应手了。现在呢，让我们开始这一讲。</p>
<p>在介绍授权码许可类型时，我提到了很多次 「授权服务」。一句话概括，授权服务就是 <strong>负责颁发访问令牌</strong> 的服务。更进一步地讲，<strong>OAuth 2.0 的核心是授权服务，而授权服务的核心就是令牌</strong>。</p>
<p>为什么这么说呢？当第三方软件比如小兔，要想获取小明在京东店铺的订单，就必须先从京东商家开放平台的授权服务那里获取访问令牌，进而通过访问令牌来 <strong>代表</strong> 小明去请求小明的订单数据。这不恰恰就是整个 OAuth 2.0 授权体系的核心吗？</p>
<p>那么，授权服务到底是怎么生成访问令牌的，这其中包含了哪些操作呢？还有一个问题是，访问令牌过期了而用户又不在场的情况下，又如何重新生成访问令牌呢？</p>
<p>带着这两个问题，我们就以授权码许可类型为例，一起深入探索下授权服务这个核心组件吧。</p>
<h2 id="授权服务的工作过程"><a href="#授权服务的工作过程" class="headerlink" title="授权服务的工作过程"></a>授权服务的工作过程</h2><p>开始之前，你还是要先回想下小明给小兔软件授权订单数据的整个流程。</p>
<p>我们说小兔软件先要让小明去京东商家开放平台那里给它授权数据，那这里是不是你觉得很奇怪？你总不能说，「嘿，京东，你把数据给小兔用吧」，那京东肯定会回复说，「小明，小兔是谁啊，没在咱家备过案，我不能给他，万一是骗子呢？」</p>
<p>对吧，你想想是不是这个逻辑。所以，授权这个大动作的前提，肯定是小兔要去平台那里「备案」，也就是注册。注册完后，京东商家开放平台就会给小兔软件 app_id 和 app_secret 等信息，<strong>以方便后面授权时的各种身份校验</strong>。</p>
<p>同时，注册的时候，第三方软件也会请求受保护资源的可访问范围。比如，小兔能否获取小明店铺 3 个月以前的订单，能否获取每条订单的所有字段信息等等。<strong>这个权限范围，就是 scope</strong>。后面呢，我还会详细讲述范围控制。</p>
<p>文字说起来有点抽象，咱们还是直接上代码吧。关于注册后的数据存储，我们使用如下 Java 代码来模拟：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; appMap =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();<span class="comment">//模拟第三方软件注册之后的数据库存储</span></span><br><span class="line">appMap.put(<span class="string">&quot;app_id&quot;</span>,<span class="string">&quot;APPID_RABBIT&quot;</span>);</span><br><span class="line">appMap.put(<span class="string">&quot;app_secret&quot;</span>,<span class="string">&quot;APPSECRET_RABBIT&quot;</span>);</span><br><span class="line">appMap.put(<span class="string">&quot;redirect_uri&quot;</span>,<span class="string">&quot;http://localhost:8080/AppServlet-ch03&quot;</span>);</span><br><span class="line">appMap.put(<span class="string">&quot;scope&quot;</span>,<span class="string">&quot;nickname address pic&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>备完案之后，咱们接着继续前进。小明过来让平台把他的订单数据给小兔，平台咔咔一查，对了下暗号，发现小兔是合法的，于是就要推进下一步了。</p>
<p>咱们上节课讲过，在授权码许可类型中，授权服务的工作，可以划分为两大部分：</p>
<ul>
<li>一个是 <strong>颁发授权码 code</strong></li>
<li>一个是 <strong>颁发访问令牌 access_token</strong></li>
</ul>
<p>为了更能表达授权码和访问令牌的存在，我在图中用深色将其标注了出来：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/a5d231c5b356ecf2031yy7d17207c011.png"
                      alt="img"
                ></p>
<p>我们先看看颁发授权码 code 的流程。</p>
<h2 id="过程一：颁发授权码-code"><a href="#过程一：颁发授权码-code" class="headerlink" title="过程一：颁发授权码 code"></a>过程一：颁发授权码 code</h2><p>在这个过程中，授权服务需要完成两部分工作，分别是  <strong>准备工作</strong> 和 <strong>生成授权码 code</strong>。</p>
<p>你可能会问了，这个准备都包括哪些工作？我们可以想到，小明在给第三方软件小兔打单软件进行授权的时候，会看到授权页面上有一个授权按钮，但是授权服务在小明看到这个授权按钮之前，实际上已经做了一系列动作。</p>
<p>这些动作，就是所谓的准备工作，包括验证基本信息、验证权限范围（第一次）和生成授权请求页面这三步。我们具体分析下。</p>
<h3 id="第一步，验证基本信息。"><a href="#第一步，验证基本信息。" class="headerlink" title="第一步，验证基本信息。"></a><strong>第一步，验证基本信息。</strong></h3><p>验证基本信息，包括对第三方软件小兔合法性和回调地址合法性的校验。</p>
<p>在 Web 浏览器环境下，颁发 code 的整个请求过程，都是浏览器通过前端通信来完成，这就意味着所有信息都有被冒充的风险。因此，授权服务必须对第三方软件的存在性做判断。</p>
<p>同样，<strong>回调地址也是可以被伪造的</strong>。比如，不法分子将其伪装成钓鱼页面，或者是带有恶意攻击性的软件下载页面。因此从安全上考虑，授权服务需要对回调地址做基本的校验。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!appMap.get(<span class="string">&quot;redirect_uri&quot;</span>).equals(redirectUri))&#123;</span><br><span class="line">    <span class="comment">//回调地址不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在授权服务的程序中，这两步验证通过后，就会生成或者响应一个页面（<strong>属于授权服务器上的页面</strong>），以提示小明进行授权。</p>
<h3 id="第二步，验证权限范围（第一次）。"><a href="#第二步，验证权限范围（第一次）。" class="headerlink" title="第二步，验证权限范围（第一次）。"></a><strong>第二步，验证权限范围（第一次）。</strong></h3><p>既然是授权，就会涉及范围。比如，我们使用微信登录第三方软件的时候，会看到微信提示我们，第三方软件可以获得你的昵称、头像、性别、地理位置等。如果你不想让第三方软件获取你的某个信息，那么可以不选择这一项。同样在小兔中也是一样，当小明为小兔进行授权的时候，也可以选择给小兔的权限范围，比如是否授予小兔获取 3 个月以前的订单的访问权限。</p>
<p>这就意味着，我们需要对小兔传过来的 scope 参数，与小兔注册时申请的权限范围做比对。如果请求过来的权限范围大于注册时的范围，就需要作出越权提示。<strong>记住，此刻是第一次权限校验。</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;scope&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!checkScope(scope))&#123;</span><br><span class="line">    <span class="comment">//超出注册的权限范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="第三步，生成授权请求页面。"><a href="#第三步，生成授权请求页面。" class="headerlink" title="第三步，生成授权请求页面。"></a><strong>第三步，生成授权请求页面。</strong></h3><p>这个授权请求页面就是授权服务上的页面，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/5e024b40a98b65a54082106a96734c66.png"
                      alt="img"
                ></p>
<p>页面上显示了小兔注册时申请的 today、history 两种权限，小明可以选择缩小这个权限范围，比如仅授予获取 today 信息的权限。</p>
<p>至此，颁发授权码 code 的准备工作就完成了。你要注意哈，我一直强调说这也是准备工作，因为当用户点击授权按钮「approve」后，才会 <strong>生成授权码 code 值和访问令牌 acces_token 值</strong>，「一切才真正开始」。</p>
<p>这里需要说明下<strong>：在上面的准备过程中，我们忽略了小明登录的过程，</strong>但只有用户登录了才可以对第三方软件进行授权，授权服务才能够获得用户信息并最终生成 code 和 app_id（第三方软件的应用标识） + user（资源拥有者标识）之间的对应关系。你可以把登录部分的代码，作为附加练习。</p>
<p>小明点击 <code>approve</code> 按钮之后，生成授权码 code 的流程就正式开始了，主要包括验证权限范围（第二次）、处理授权请求生成授权码 code 和重定向至第三方软件这三大步。接下来，我们一起分析下这三步。</p>
<h3 id="第四步，验证权限范围（第二次）。"><a href="#第四步，验证权限范围（第二次）。" class="headerlink" title="第四步，验证权限范围（第二次）。"></a><strong>第四步，验证权限范围（第二次）。</strong></h3><p>在步骤二中，<strong>生成授权页面之前授权服务进行的第一次校验</strong>，是对比小兔 <strong>请求过来的权限范围 scope 和注册时的权限做的比对</strong>。这里的第二次验证权限范围，是用小明进行 <strong>授权之后的权限，再次与小兔软件注册的权限做校验</strong>。</p>
<p>那这里为什么又要校验一次呢？因为这相当于一次用户的输入权限。小明选择了一定的权限范围给到授权服务，对于权限的校验我们要重视对待，凡是输入性数据都会涉及到合法性检查。另外，这也是要求我们养成一种 <strong>在服务端对输入数据的请求，都尽可能做一次合法性校验的好习惯</strong>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String[] rscope =request.getParameterValues(<span class="string">&quot;rscope&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!checkScope(rscope))&#123;</span><br><span class="line">    <span class="comment">//超出注册的权限范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="第五步，处理授权请求，生成授权码-code。"><a href="#第五步，处理授权请求，生成授权码-code。" class="headerlink" title="第五步，处理授权请求，生成授权码 code。"></a><strong>第五步，处理授权请求，生成授权码 code。</strong></h3><p>当小明同意授权之后，授权服务会校验响应类型 <code>response_type</code> 的值。<code>response_type</code>  有 code 和 token 两种类型的值。在这里，我们是用授权码流程来举例的，因此代码要验证 <code>response_type</code> 的值是否为 code。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">responseType</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;response_type&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;code&quot;</span>.equals(responseType))&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在授权服务中，需要将生成的授权码 <code>code</code> 值与  <code>app_id</code>、<code>user</code> 进行关系映射。也就是说，一个授权码 code，表示某一个用户给某一个第三方软件进行授权，比如小明给小兔软件进行的授权。同时，我们需要将 code 值和这种映射关系保存起来，以便在生成访问令牌 access_token 时使用。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> generateCode(appId,<span class="string">&quot;USERTEST&quot;</span>);<span class="comment">//模拟登录用户为USERTEST</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateCode</span><span class="params">(String appId,String user)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> strb.toString();</span><br><span class="line">  codeMap.put(code,appId+<span class="string">&quot;|&quot;</span>+user+<span class="string">&quot;|&quot;</span>+System.currentTimeMillis());</span><br><span class="line">  <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在生成了授权码 code 之后，我们也按照上面所述绑定了响应的映射关系。这时，你还记得我之前讲到的授权码是临时的、一次性凭证吗？因此，我们还需要为 code 设置一个有效期。</p>
<p>OAuth 2.0 规范建议授权码 code 值有效期为 10 分钟，并且 <strong>一个授权码 code 只能被使用一次</strong>。不过根据经验呢，在生产环境中 code 的有效期一般不会超过 5 分钟。关于授权码 code 相关的安全方面的内容，我还会在后续中详细讲述。</p>
<p>同时，授权服务还需要 <strong>将生成的授权码 code 跟已经授权的权限范围 rscope 进行绑定并存储</strong>，以便后续颁发访问令牌时，我们能够通过 code 值取出授权范围并与访问令牌绑定。因为第三方软件最终是通过访问令牌来请求受保护资源的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; codeScopeMap =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String[]&gt;();</span><br><span class="line">codeScopeMap.put(code,rscope);<span class="comment">//授权范围与授权码做绑定</span></span><br></pre></td></tr></table></figure></div>

<h3 id="第六步，重定向至第三方软件。"><a href="#第六步，重定向至第三方软件。" class="headerlink" title="第六步，重定向至第三方软件。"></a><strong>第六步，重定向至第三方软件。</strong></h3><p>生成授权码 code 值之后，授权服务需要将该 code 值告知第三方软件小兔。开始时我们提到，颁发授权码 code 是通过前端通信完成的，因此这里采用重定向的方式。这一步的重定向，也是我在上一讲中提到的第二次重定向。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">params.put(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line"><span class="type">String</span> <span class="variable">toAppUrl</span> <span class="operator">=</span> URLParamsUtil.appendParams(redirectUri,params);<span class="comment">//构造第三方软件的回调地址，并重定向到该地址</span></span><br><span class="line">response.sendRedirect(toAppUrl);<span class="comment">//授权码流程的“第二次”重定向</span></span><br></pre></td></tr></table></figure></div>

<p>到此，颁发授权码 code 的流程全部完成。当小兔获取到授权码 code 值以后，就可以开始请求访问令牌 access_token 的值了，也就是我们即将开始的过程二。</p>
<h2 id="过程二：颁发访问令牌-access-token"><a href="#过程二：颁发访问令牌-access-token" class="headerlink" title="过程二：颁发访问令牌 access_token"></a>过程二：颁发访问令牌 access_token</h2><p>我们在过程一中介绍了授权码 code 的生成流程，但小兔最终是要获取到访问令牌 access_token，才可以去请求受保护资源。而授权码呢，正如我在上一讲提到的，只是一个换取访问令牌 access_token 的临时凭证。</p>
<p>当小兔拿着授权码 code 来请求的时候，授权服务需要为之生成最终的请求访问令牌。这个过程主要包括验证第三方软件小兔是否存在、验证 code 值是否合法和生成 access_token 值这三大步。接下来，我们一起分析下每一步。</p>
<h3 id="第一步，验证第三方软件是否存在。"><a href="#第一步，验证第三方软件是否存在。" class="headerlink" title="第一步，验证第三方软件是否存在。"></a><strong>第一步，验证第三方软件是否存在。</strong></h3><p>此时，接收到的 grant_type 的类型为 authorization_code。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">grantType</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;grant_type&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;authorization_code&quot;</span>.equals(grantType))&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于颁发访问令牌是通过后端通信完成的，所以这里除了要校验 app_id 外，还要校验 app_secret。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!appMap.get(<span class="string">&quot;app_id&quot;</span>).equals(appId))&#123;</span><br><span class="line">    <span class="comment">//app_id不存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!appMap.get(<span class="string">&quot;app_secret&quot;</span>).equals(appSecret))&#123;</span><br><span class="line">    <span class="comment">//app_secret不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="第二步，验证授权码-code-值是否合法。"><a href="#第二步，验证授权码-code-值是否合法。" class="headerlink" title="第二步，验证授权码 code 值是否合法。"></a><strong>第二步，验证授权码 code 值是否合法。</strong></h3><p>授权服务在颁发授权码 code 的阶段已经将 code 值存储了起来，此时对比从 request 中接收到的 code 值和从存储中取出来的 code 值。在我们给出的课程相关代码中，code 值对应的 key 是 app_id 和 user 的组合值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!isExistCode(code))&#123;<span class="comment">//验证code值</span></span><br><span class="line">  <span class="comment">//code不存在</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">codeMap.remove(code);<span class="comment">//授权码一旦被使用，须立即作废</span></span><br></pre></td></tr></table></figure></div>

<p>这里我们一定要记住，<strong>确认过授权码 code 值有效以后，应该立刻从存储中删除当前的 code 值</strong>，以防止第三方软件恶意使用一个失窃的授权码 code 值来请求授权服务。</p>
<h3 id="第三步，生成访问令牌-access-token-值。"><a href="#第三步，生成访问令牌-access-token-值。" class="headerlink" title="第三步，生成访问令牌 access_token 值。"></a><strong>第三步，生成访问令牌 access_token 值。</strong></h3><p>关于按照什么规则来生成访问令牌 access_token 的值，OAuth 2.0 规范中并没有明确规定，但必须符合三个原则：<strong>唯一性、不连续性、不可猜性</strong>。在我们给出的 Demo 中，我们是使用 UUID 来作为示例的。</p>
<p>和授权码 code 值一样，我们需要将访问令牌 access_token 值存储起来，并将其与第三方软件的应用标识 app_id 和资源拥有者标识 user 进行关系映射。也就是说，<strong>一个访问令牌 access_token 表示某一个用户给某一个第三方软件进行授权</strong>。</p>
<p>同时，<strong>授权服务还需要将授权范围跟访问令牌 access_token 做绑定</strong>。最后，还需要为该访问令牌设置一个过期时间 expires_in，比如 1 天。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; tokenScopeMap =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String[]&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken(appId,<span class="string">&quot;USERTEST&quot;</span>);<span class="comment">//生成访问令牌access_token的值</span></span><br><span class="line">tokenScopeMap.put(accessToken,codeScopeMap.get(code));<span class="comment">//授权范围与访问令牌绑定</span></span><br><span class="line"><span class="comment">//生成访问令牌的方法</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateAccessToken</span><span class="params">(String appId,String user)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">  <span class="type">String</span> <span class="variable">expires_in</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;<span class="comment">//1天时间过期</span></span><br><span class="line">  tokenMap.put(accessToken,appId+<span class="string">&quot;|&quot;</span>+user+<span class="string">&quot;|&quot;</span>+System.currentTimeMillis()+<span class="string">&quot;|&quot;</span>+expires_in);</span><br><span class="line">  <span class="keyword">return</span> accessToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>正因为 OAuth 2.0 规范没有约束访问令牌内容的生成规则，所以我们有更高的自由度。我们既可以像 Demo 中那样生成一个 UUID 形式的数据存储起来，让授权服务和受保护资源共享该数据；也可以将一些必要的信息通过结构化的处理放入令牌本身。<strong>我们将包含了一些信息的令牌，称为结构化令牌，简称 JWT</strong>。在下一讲中，我还会与你详细讲述 JWT。</p>
<p>至此，授权码许可类型下授权服务的两大主要过程，也就是颁发授权码和颁发访问令牌的流程，我就与你讲完了。</p>
<p>接下来，你在阅读别人的授权流程代码，或者是使用诸如通过微信登录的第三方软件的时候，就会明白背后的原理了。同时，你在自己搭建一个授权服务流程时，也会更加得心应手。这一切的原因，都在于颁发授权码和颁发访问令牌，就是授权服务的核心。</p>
<p>到这里，你应该还会注意到一个问题，在生成访问令牌的时候，<strong>我们还给它附加了一个过期时间 expires_in</strong>，这意味着访问令牌会在一定的时间后失效。访问令牌失效，就意味着资源拥有者给第三方软件的授权失效了，第三方软件无法继续访问资源拥有者的受保护资源了。</p>
<p>这时，<strong>如果你还想继续使用第三方软件，就只能重新点击授权按钮</strong>，比如小明给小兔软件授权以后，正在愉快地处理他店铺的订单数据，结果没过多久，突然间小兔软件再次让小明进行授权。此刻，我们可以替小明感受一下他的心情。</p>
<p>显然，这样的用户体验非常糟糕。为此，<strong>OAuth 2.0 中引入了刷新令牌的概念</strong>，也就是刷新访问令牌 access_token 的值。这就意味着，有了刷新令牌，用户在一定期限内无需重新点击授权按钮，就可以继续使用第三方软件。</p>
<p>接下来，我们就一起看看刷新令牌的工作原理吧。</p>
<h2 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h2><p>刷新令牌也是给第三方软件使用的，同样需要遵循 <strong>先颁发再使用</strong> 的原则。因此，我们还是从颁发和使用两个环节来学习刷新令牌。不过，这个颁发和使用流程和访问令牌有些是相同的，所以我只会和你重点讲述其中的区别。</p>
<h3 id="颁发刷新令牌"><a href="#颁发刷新令牌" class="headerlink" title="颁发刷新令牌"></a>颁发刷新令牌</h3><p>其实，<strong>颁发刷新令牌和颁发访问令牌是一起实现的</strong>，都是在过程二的步骤三生成访问令牌 access_token 中生成的。也就是说，第三方软件得到一个访问令牌的同时，也会得到一个刷新令牌：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;String,String&gt; refreshTokenMap =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> generateRefreshToken(appId,<span class="string">&quot;USERTEST&quot;</span>);<span class="comment">//生成刷新令牌refresh_token的值</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateRefreshToken</span><span class="params">(String appId,String user)</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">  refreshTokenMap.put(refreshToken,appId+<span class="string">&quot;|&quot;</span>+user+<span class="string">&quot;|&quot;</span>+System.currentTimeMillis());</span><br><span class="line">  <span class="keyword">return</span> refreshToken;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>看到这里你可能要问了，为什么要一起生成访问令牌和刷新令牌呢？</p>
<p>其实，这就回到了刷新令牌的作用上了。刷新令牌存在的初衷是，在访问令牌失效的情况下，为了不让用户频繁手动授权，用来通过系统重新请求 <strong>生成一个新的访问令牌</strong>。那么，如果访问令牌失效了，而「身边」又没有一个刷新令牌可用，岂不是又要麻烦用户进行手动授权了。所以，它必须得和访问令牌一起生成。</p>
<p>到这里，我们就解决了刷新令牌的颁发问题。</p>
<h3 id="使用刷新令牌"><a href="#使用刷新令牌" class="headerlink" title="使用刷新令牌"></a>使用刷新令牌</h3><p>说到刷新令牌的使用，我们需要先明白一点。在 OAuth 2.0 规范中，<strong>刷新令牌是一种特殊的授权许可类型</strong>，是嵌入在授权码许可类型下的一种特殊许可类型。在授权服务的代码里，当我们接收到这种授权许可请求的时候，会先比较 <code>grant_type</code> 和  <code>refresh_token</code>  的值，然后做下一步处理。</p>
<p>这其中的流程主要包括如下两大步骤。</p>
<p><strong>第一步，接收刷新令牌请求，验证基本信息。</strong></p>
<p>此时请求中的 <code>grant_type</code> 值为 <code>refresh_token</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">grantType</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;grant_type&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;refresh_token&quot;</span>.equals(grantType))&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>和颁发访问令牌前的验证流程一样</strong>，这里我们也需要验证第三方软件是否存在。需要注意的是，这里需要同时验证刷新令牌是否存在，<strong>目的就是要保证传过来的刷新令牌的合法性</strong>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">refresh_token</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!refreshTokenMap.containsKey(refresh_token))&#123;</span><br><span class="line">    <span class="comment">//该refresh_token值不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外，我们还需要验证刷新令牌是否属于该第三方软件。授权服务是将颁发的刷新令牌与第三方软件、当时的授权用户绑定在一起的，因此这里需要判断该刷新令牌的归属合法性。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">appStr</span> <span class="operator">=</span> refreshTokenMap.get(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!appStr.startsWith(appId+<span class="string">&quot;|&quot;</span>+<span class="string">&quot;USERTEST&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">//该refresh_token值不是颁发给该第三方软件的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>需要注意，一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌。</strong></p>
<p><strong>第二步，重新生成访问令牌。</strong></p>
<p>生成访问令牌的处理流程，与颁发访问令牌环节的生成流程是一致的。授权服务会将新的访问令牌和新的刷新令牌，一起返回给第三方软件。这里就不再赘述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天的课马上又要结束了，我和你讲了 <strong>授权码许可类型下授权服务的工作原理</strong>。授权服务可以说是整个 OAuth 2.0 体系中的 「灵魂」 组件，任何一种许可类型都离不开它的支持，它也是最复杂的组件。</p>
<p>这是因为它将复杂性尽可能地「揽在了自己身上」，才使得诸如小兔这样的第三方软件接入 OAuth 2.0 的时候更加便捷。那关于如何快速地接入 OAuth 2.0，我在后续章节中和你详细展开。</p>
<p>总结来讲，关于这一讲，我希望你能记住以下 3 点。</p>
<ol>
<li><p>授权服务的核心就是，<strong>先颁发授权码 code 值，再颁发访问令牌 access_token 值</strong>。</p>
</li>
<li><p>在颁发访问令牌的 <strong>同时还会颁发刷新令牌 refresh_token 值，这种机制可以在无须用户参与的情况下用于生成新的访问令牌</strong>。正如我们讲到的小明使用小兔软件的例子，当访问令牌过期的时候，刷新令牌的存在可以大大提高小明使用小兔软件的体验。</p>
</li>
<li><p>授权还要有授权范围，<strong>不能让第三方软件获得比注册时权限范围还大的授权，也不能获得超出了用户授权的权限范围，始终确保最小权限安全原则。</strong> 比如，小明只为小兔软件授予了获取当天订单的权限，那么小兔软件就不能访问小明店铺里面的历史订单数据。</p>
</li>
</ol>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>刷新令牌有过期时间吗，会一直有效吗？</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><p>请问什么是 rscope？和上下文中的 scope 是一回事吗？这个 r 代表什么？</p>
<p> 对应的权限 都是同一个权限，这里用 rscope 是受保护资源服务再次确认的权限，r 是 replay。</p>
</li>
<li><p>为什么要通过刷新令牌让第三方不断刷新 token 有效期，而不是直接给访问 token 一个更长的有效期？后者更简单</p>
<p>为了安全性的考虑，是不可以让 token 一个更长的有效期存在的。</p>
</li>
<li><p>scope 的权限范围指的是什么？</p>
<p>SCOPE 的权限范围非常重要，OAuth 2.0 本着【最小权限范围】原则，来支持用户对第三方软件授权。比如小兔打单软件，他的主要行当就是帮助小明 <strong>打印订单</strong>，那么它的权限范围就是调用跟订单打印相关的 API，比如单条查询订单 API、批量查询订单 API，那么查询小明店铺其它的 API 就要受限，在小兔打单软件申请成为开放平台的应用的时候就要做一次权限范围的选择，另外，当小明给小兔进行授权的时候，也会让小明去选择并确认，总之就是不要让小兔打单软件有超过其正常权限的范围，来充分保护小明店铺的数据。后面的课程，我们还会详细讲解关于 SCOPE 的种类和用法。</p>
</li>
<li><p>通过 refresh_token 刷新后，返回来 assessToken 和 refresh_token，<strong>但 refresh_token 过期时间不会重新刷新</strong>，这是为什么要这样设置呢，<strong>当 refresh_token 为 0 时，是不是只能通过重新登录授权？</strong></p>
<p>是的，当刷新令牌也过期了，只能重新登录再授权。</p>
</li>
<li><p>权限范围如何验证？</p>
<p>第三方应用在申请成为平台的开发者的时候会 <strong>注册申请一个所能够调用的 API 权限列表</strong>，在用户给第三方应用授权的时候也会 <strong>让用户来确认给三方软件授予哪些权限</strong>，<strong>在三方软件请求受保护资源的时候，受保护资源要根据以上去做判断</strong>，不能超过当初申请注册的权限范围，也不能超过用户授予的权限范围</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注意：代码中分两个项目</p>
<ul>
<li><p>xtapp：小兔 APP 第三方客户端应用</p>
</li>
<li><p>oauth-server：授权服务</p>
<p>为了方便演示：protected-server 受保护的资源服务，写在 授权服务上，不过写在另一个 controller 中。</p>
<p>原因是因为：受保护的资源服务，拿到 token 之后，需要授权服务器验证 token 是否有效，获取到他的 scope ，是否有权限访问受保护的资源服务</p>
</li>
</ul>
<p>两个主要代码入口：</p>
<ul>
<li><a class="link"   href="https://github.com/zq99299/myoath2-demo/blob/main/xtapp/src/main/java/cn/mrcode/myoath2/xtapp/ch03/Ch03IndexController.java" >xtapp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/zq99299/myoath2-demo/tree/main/oauth-server/src/main/java/cn/mrcode/myoath2/oauthserver/ch03" >oauth-server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>访问流程如下：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">//1. 访问小兔应用程序</span><br><span class="line">http://localhost:8080/ch03/index</span><br><span class="line"></span><br><span class="line">//2. 小兔应用程序，会将我们引导到第三方服务的 授权服务页面（授权服务需要保证用户已经登录过）</span><br><span class="line">//   那么用户：在该页面选择要授权的 scope，并确认授权</span><br><span class="line">http://localhost:8081/ch03/oath?scope=today%20history&amp;response_type=code&amp;redirect_uri=http://localhost:8080/ch03/callback&amp;app_id=APPID_RABBIT</span><br><span class="line"></span><br><span class="line">// 3. 用户确认授权请求会请过授权服务器的处理，校验通过后，发放 code 授权码，并重定向到小兔服务器</span><br><span class="line">http://localhost:8081/ch03/oath-confirm  -&gt;  http://localhost:8080/ch03/callback?code=61259035</span><br><span class="line"></span><br><span class="line">// 4. 重定向到小兔服务之后，这里使用后端模拟了前端，在后端中直接拿到 code 去换取 token 了</span><br><span class="line">//    并通过换回的 token 信息去访问订单信息</span><br><span class="line">http://localhost:8080/ch03/callback?code=61259035</span><br></pre></td></tr></table></figure></div>

<p>后台服务日志输出：主要对 小兔 APP 的流程做了日志的打印</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-12-17 15:30:56.071  INFO 23996 --- [nio-8080-exec-4] c.m.m.xtapp.ch03.Ch03IndexController     : 重定向到授权服务页面: http://localhost:8081/ch03/oath?scope=today history&amp;response_type=code&amp;redirect_uri=http://localhost:8080/ch03/callback&amp;app_id=APPID_RABBIT</span><br><span class="line">2020-12-17 15:31:10.840  INFO 23996 --- [nio-8080-exec-6] c.m.m.xtapp.ch03.Ch03IndexController     : 拿到授权服务回调的 code：30517503</span><br><span class="line">2020-12-17 15:31:10.857  INFO 23996 --- [nio-8080-exec-6] c.m.m.xtapp.ch03.Ch03IndexController     : 通过 code 换取到的 accessToken：e69a2b93-cc2c-4469-9c13-255656f4d2aa|566b65a8-8116-4e8c-9cc0-a81149f1c97b</span><br><span class="line"></span><br><span class="line">2020-12-17 15:31:10.862  INFO 23996 --- [nio-8080-exec-6] c.m.m.xtapp.ch03.Ch03IndexController     : 通过 accessToken 访问受保护的资源,获取到订单信息 &#123;&#x27;id&#x27;:1,&#x27;name&#x27;:&#x27;订单1&#x27;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>授权码许可类型中，为什么一定要有授权码？</title>
    <url>/2024/07/19/02/</url>
    <content><![CDATA[<p>在上一讲，我提到了 OAuth 2.0 的授权码许可类型，在小兔打单软件的例子里面，小兔最终是通过 <strong>访问令牌</strong> 请求到小明的店铺里的订单数据。同时呢，我还提到了，这个 <strong>访问令牌是通过授权码换来的</strong>。到这里估计你会问了，为什么要用授权码来换令牌？为什么不能直接颁发访问令牌呢？</p>
<h2 id="为什么需要授权码？"><a href="#为什么需要授权码？" class="headerlink" title="为什么需要授权码？"></a>为什么需要授权码？</h2><p>在讲这个问题之前，我先要和你同步下，在 OAuth 2.0 的体系里面有 4 种角色，按照官方的称呼它们分别是：</p>
<ul>
<li>资源拥有者</li>
<li>客户端</li>
<li>授权服务</li>
<li>受保护资源。</li>
</ul>
<p>不过，这里的客户端，我更愿意称其为第三方软件，而且在咱们这个课程中，都是以第三方软件在举例子。所以，在后续的讲解中我统一把它称为第三方软件。</p>
<p>所以，你在看官方资料的时候，可以自己对应下。为了便于你理解，我还是拿小兔软件来举例子，将官方的称呼 照进现实，对应关系就是，</p>
<ul>
<li><strong>资源拥有者 -&gt; 小明</strong></li>
<li><strong>第三方软件 -&gt; 小兔软件</strong></li>
<li><strong>授权服务 -&gt; 京东商家开放平台的授权服务</strong></li>
<li><strong>受保护资源 -&gt; 小明店铺在京东上面的订单</strong></li>
</ul>
<p>在理解了这些概念以后，让我们继续。</p>
<p>你知道，<strong>OAuth 诞生之初就是为了解决 Web 浏览器场景下的授权问题</strong>，所以我基于浏览器的场景，在上一讲的小明使用小兔软件打印订单的整体流程的基础上，画了一个授权码许可类型的序列图。</p>
<p>当然了，这里还是有小兔软件来继续陪伴着我们，不过这次为了能够更好地表述授权码许可流程，我会把小兔软件的前端和后端分开展示，并把京东商家开放平台的系统按照 OAuth 2.0 的组件拆分成了 <strong>授权服务</strong> 和 <strong>受保护资源服务</strong>。如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/96973a6f5637fb3d1049f6d456702932.png"
                      alt="img"
                ></p>
<p>突然看到这个序列图增加了这么多步骤的时候，你是不是有些紧张？那如果我告诉你再细分的话步骤还要更多，你是不是就更困惑了？</p>
<p>不过，别紧张，这没啥关系。一方面，咱们这一讲的 <strong>重点</strong> 就是 <strong>跟授权码相关的流程</strong>，你只需关注这里的重点步骤，也就是 <strong>两次重定向相关的步骤</strong> 就够了。在下一讲中，我再教你如何将这些步骤进一步拆解。另一方面，我接下来还会用另一种视角来帮助你分析这个流程。</p>
<p>我们继续来看这张序列图。从图中看到，在第 4 步授权服务生成了授权码 code，按照一开始我们提出来的问题，如果不要授权码，这一步实际上就可以直接返回访问令牌 access_token 了。</p>
<p>按着这个没有授权码的思路继续想，如果这里直接返回访问令牌，那我们肯定不能使用重定向的方式。因为 <strong>这样会把安全保密性要求极高的访问令牌暴露在浏览器上</strong> ，从而将会面临访问令牌失窃的安全风险。显然，这是不能被允许的。</p>
<p>也就是说，如果没有授权码的话，我们就只能把访问令牌发送给第三方软件小兔的后端服务。按照这样的逻辑，上面的流程图就会变成下面这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/f44866070ee06bc3fcceac792570d433.png"
                      alt="img"
                ></p>
<p>到这里，看起来天衣无缝。小明访问小兔软件，小兔软件说要打单你得给我授权，不然京东不干，然后小兔软件就引导小明跳转到了京东的授权服务。到授权服务之后，京东商家开放平台验证了小兔的合法性以及小明的登录状态后，生成了授权页面。紧接着，小明赶紧点击同意授权，这时候，京东商家开放平台知道可以把小明的订单数据给小兔软件。</p>
<p>于是，京东商家开放平台没含糊，赶紧生成访问令牌 access_token，并且通过后端服务的方式返回给了小兔软件。这时候，小兔软件就能正常工作了。</p>
<p>这样，问题就来了，什么问题呢？ <strong>当小明被浏览器重定向到授权服务上之后，小明跟小兔软件之间的 「连接」 就断了</strong>，相当于此时此刻小明跟授权服务建立了「连接」后，将一直「停留在授权服务的页面上」。<strong>你会看到图 2 中问号处的时序上，小明再也没有重新「连接」到小兔软件。</strong></p>
<p>但是，这个时候小兔软件已经拿到了小明授权之后的访问令牌，也使用访问令牌获取到了小明店铺里的订单数据。这时，考虑到「小明的感受」，小兔软件应该要通知到小明，但是如何做呢？现在「连接断了」，这事儿恐怕就没那么容易了。</p>
<p>OK，为了让小兔软件能很容易地通知到小明，<strong>还必须让小明跟小兔软件重新建立起 「连接」</strong>。这就是我们看到的第二次重定向，小明授权之后，又重新重定向回到了小兔软件的地址上，这样 <strong>小明就跟小兔软件有了新的 「连接」</strong>。</p>
<p>到这里，你就能理解在授权码许可的流程中，为什么需要两次重定向了吧。</p>
<p><strong>为了重新建立起这样的一次连接，我们又不能让访问令牌暴露出去</strong>，就有了这样一个 <strong>临时的、间接的凭证：授权码</strong>。因为小兔软件最终要拿到的是安全保密性要求极高的访问令牌，并不是授权码，而授权码是可以暴露在浏览器上面的。这样有了授权码的参与，访问令牌可以在后端服务之间传输，<strong>同时呢还可以重新建立小明与小兔软件之间的「连接」</strong>。这样通过一个授权码，既「照顾」到了小明的体验，又「照顾」了通信的安全。</p>
<p>这下，你就知道为什么要有授权码了吧。</p>
<p>那么，在执行授权码流程的时候，<strong>授权码和访问令牌在小兔软件和授权服务之间到底是怎么流转的呢？</strong>要回答这个问题，就需要继续分析一下授权码许可类型的通信过程了。</p>
<h2 id="授权码许可类型的通信过程"><a href="#授权码许可类型的通信过程" class="headerlink" title="授权码许可类型的通信过程"></a>授权码许可类型的通信过程</h2><p>图 1 的通信过程中标识出来的步骤就有 9 个，一步步地去分析看似会很复杂，所以我会用另一个维度来分析以帮助你理解，也就是从 <strong>直接通信</strong> 和 <strong>间接通信</strong> 的维度来分析。</p>
<ul>
<li>间接通信就是指：获取授权码的交互，</li>
<li>直接通信就是指：通过授权码换取访问令牌的交互。</li>
</ul>
<p>接下来，我们就一起分析下吧，看看哪些是间接通信，哪些又是直接通信。</p>
<h3 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h3><p>我们先分析下为什么是「间接」。</p>
<p>我们把图 1 中获取授权码 code 的流程 「放大」，并换个角度来看一看，也就是 <strong>将浏览器这个代理放到第三方软件小兔和授权服务中间</strong>。于是，我们来到了下面这张图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/9e4f51f1f77840bd0b8f756be40d42bf.jpg"
                      alt="img"
                ></p>
<p>这个过程，仿佛有这样的一段对话。</p>
<ul>
<li><p>小明：「你好，小兔软件，我要访问你了。」</p>
</li>
<li><p>小兔软件：「好的，我把你引到授权服务那里，我需要授权服务给我一个授权码。」</p>
</li>
<li><p>授权服务：「小兔软件，<strong>我把授权码发给浏览器了</strong>。」</p>
</li>
<li><p>小兔软件：「好的，我从浏览器拿到了授权码。」</p>
</li>
</ul>
<p>不知道你注意到没有，第三方软件小兔和授权服务之间，并没有发生直接的通信，而是 <strong>通过浏览器这个「中间人」来 「搭线」的</strong> 。因此，我们说这是一个间接通信的方式。</p>
<h3 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h3><p>那我们再分析下，授权码换取访问令牌的交互，为什么是「直接」的。我们再把图 1 中获取访问令牌的流程「放大」，就得到了下面的图示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/84dc2d6f578b6968b782a0280a73be9b.png"
                      alt="img"
                ></p>
<p>相比获取授权码过程的间接通信，获取访问令牌的直接通信就比较容易理解了，就是第三方软件小兔获取到授权码 code 值后，向授权服务发起获取访问令牌 access_token 的通信请求。<strong>这个请求是第三方软件服务器跟授权服务的服务器之间的通信</strong>，都是在后端服务器之间的请求和响应，因此也叫作 <strong>后端通信</strong>。</p>
<h3 id="两个-「一伙」"><a href="#两个-「一伙」" class="headerlink" title="两个 「一伙」"></a>两个 「一伙」</h3><p>了解了上面的通信方式之后，不知道你有没有意识到，OAuth 2.0 中的 4 个角色是 <strong>「两两站队</strong>」 的：</p>
<ul>
<li><strong>资源拥有者</strong>  和 <strong>第三方软件</strong> 站在一起，因为第三方软件要代表资源拥有者去访问受保护资源；</li>
<li><strong>授权服务</strong> 和 <strong>受保护资源</strong> 站在一起，因为授权服务负责颁发访问令牌，受保护资源负责接收并验证访问令牌。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/1c86e21496882894d7f03b35a01972ff.jpg"
                      alt="img"
                ></p>
<p>讲到这里的时候，你会发现在这一讲，介绍授权码流程的时候我都是以浏览器参与的场景来讲的，那么浏览器一定要参与到这个流程中吗？</p>
<p><strong>其实，授权码许可流程，不一定要有浏览器的参与</strong>。接下来，我们就继续分析下其中的逻辑。</p>
<h2 id="一定要有浏览器吗？"><a href="#一定要有浏览器吗？" class="headerlink" title="一定要有浏览器吗？"></a>一定要有浏览器吗？</h2><p>OAuth 2.0 发展之初，开放生态环境相对单薄，以浏览器为代理的 Web 应用居多，授权码许可类型 「理所当然」 地被应用到了通过浏览器才能访问的 Web 应用中。</p>
<p>但实际上，OAuth 2.0 是一个授权理念，或者说是一种授权思维。它的授权码模式的思维可以移植到很多场景中，比如微信小程序。在开发微信小程序应用时，我们 <strong>通过授权码模式获取用户登录信息</strong>，官方文档的地址示例中给出的  <code>grant_type=authorization_code</code>  ，就没有用到浏览器。</p>
<p>根据微信官方文档描述，开发者获取用户登录态信息的过程正是一个授权码的许可流程：</p>
<ul>
<li><p>首先，开发者通过 <code>wx.login(Object object)</code>  方法获取到登录凭证 code 值，这一步的流程是在小程序内部通过 <strong>调用微信提供的 SDK 实现</strong>；</p>
</li>
<li><p>然后，再通过该 code 值换取用户的 session_key 等信息，也就是官方文档的 <code>auth.code2Session</code> 方法，同时该方法也是 <strong>被强烈建议通过开发者的后端服务来调用的</strong>。</p>
</li>
</ul>
<p>你可以看到，这个过程并没有使用到浏览器，但确实  <strong>按照授权码许可的思想走了一个完整的授权码许可流程</strong>。也就是说，先通过小程序前端获取到 code 值，再通过小程序的后端服务使用 code 值换取 session_key 等信息，只不过是访问令牌 access_token 的值被换成了 session_key。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure></div>

<p>你看，<strong>这整个过程体现的就是授权码许可流程的思想</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节课又接近尾声了，我再带你回顾下重点内容。</p>
<p>今天，我从为什么需要授权码这个问题开始讲起，并通过授权码把授权码许可流程整体的通信过程串了一遍，提到了授权码这种方式解决的问题，也提到了授权码流程的通信方式。总结来说，我需要你记住以下两点。</p>
<ol>
<li><p><strong>授权码许可流程有两种通信方式</strong>。</p>
<ul>
<li>一种是前端通信，<strong>因为它通过浏览器促成了授权码的交互流程</strong>，比如京东商家开放平台的授权服务生成授权码发送到浏览器，第三方软件小兔从浏览器获取授权码。<strong>正因为获取授权码的时候小兔软件和授权服务并没有发生直接的联系，也叫做间接通信</strong>。</li>
<li>另外一种是后端通信，在小兔软件获取到授权码之后，<strong>在后端服务直接发起换取访问令牌的请求，也叫做直接通信</strong>。</li>
</ul>
</li>
<li><p>在 OAuth 2.0 中，<strong>访问令牌被要求有极高的安全保密性</strong>，因此我们不能让它暴露在浏览器上面，只能通过第三方软件（比如小兔）的 <strong>后端服务来获取和使用</strong>，以最大限度地保障访问令牌的安全性。正因为访问令牌的这种安全要求特性，当需要前端通信，比如浏览器上面的流转的时候，OAuth 2.0 才又提供了一个临时的凭证：授权码。<strong>通过授权码的方式，可以让用户小明在授权服务上给小兔授权之后，还能重新回到小兔的操作页面上</strong>。这样，在保障安全性的情况下，提升了小明在小兔上的体验。</p>
</li>
</ol>
<p>从授权码许可流程中就可以看出来，它完美地将 OAuth 2.0 的 4 个角色组织了起来，并保证了它们之间的顺畅通信。<strong>它提出的这种结构和思想都可以被迁移到其他环境或者协议上，比如在微信小程序中使用授权码许可。</strong></p>
<p>不过，也正是因为有了授权码的参与，才使得授权码许可要比其他授权许可类型，在授权的流程上多出了好多步骤，让授权码许可类型成为了 OAuth 2.0 体系中迄今流程最完备、安全性最高的授权流程。在接下来的两讲中，我还会为你重点讲解授权码许可类型下的授权服务。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>关于不需要浏览器参与的授权码许可流程，你还能列举出更多的应用场景吗？</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><p>授权码被盗取后，人家也可以模拟服务器请求获取 access_token 吗？</p>
<p>一方面授权码也都有 <strong>有效期</strong>，另外一方面除非再盗取了 <strong>第三方应用软件的 app_id、secret</strong> 才能成功请求资源。</p>
</li>
<li><p>refresh_token 存在的意义是什么？access_token 过期了，为什么要用 refresh_token 去获取 access_token，好像重新获取 access_token 也行</p>
<p>refresh_token 存在于授权码许可和资源拥有者凭据许可下，为了不烦最终用户频繁的点击【授权】按钮动作，才有了这样的机制；<br>在 <strong>隐式许可和客户端凭据许可</strong>，这两种许可类型下，不需要 refresh_token，他们可以直接根据 app_id 和secret 来换取访问令牌，因为，</p>
<ol>
<li><strong>隐式许可</strong> 对任何内容都是「透明的」，也没有必要存在 refresh_token</li>
<li><strong>客户端凭据许可</strong>，既然是叫做「客户端凭据」了，在获取那些没有跟用户强关联的信息的时候，比如 国家省市信息类似的信息，其实没有用户参与的必要性，当然可以随时获取令牌。</li>
</ol>
</li>
<li><p>把安全保密性要求极高的访问令牌暴露在浏览器上，请问如果把令牌暴露在前端会带来怎样的后果呢？</p>
<p>在后面的安全那讲中，我们也会强调这点，令牌一定要通过后端通信传输（其实也有授权许可是通过前端传输，比如隐式许可，但它是非常不安全的许可类型），<strong>我们强调 OAuth 2.0 的核心是令牌</strong>，不过，安全性是一个【组合性】的问题，单个信息暴露在公网一时是没有直接的问题，比如用户的手机号，被人知道了，一般情况下仅仅是被骚扰，但如果黑产拿到跟这个手机号更多关联的信息，比如订单信息，你买了什么商品都知道，这个时候用户就会有被恶意诈骗的可能。像这样的核心信息手机号也好，token 也好肯定都是要重点保护的。</p>
</li>
<li><p>如果使用 HTTPS 是不是可以不使用授权码？也能保证安全了</p>
<p>HTTPS 和 OAuth 是两个维度的安全，<strong>HTTPS 解决的信息加密传输</strong>，<strong>OAuth 解决的是用 token 来代替用户名和密码传输</strong>。</p>
</li>
<li><p>OAth 2 可否用来实现内部系统的使用？</p>
<p>OAuth 2.0 产生于 <strong>第三方应用的场景</strong>，来管理对外的权限，但是它的本质思想是【 用 token 来代替用户名和密码】。<br>对于我们内部的系统服务之间，我们可以借用 OAuth 2.0 的这种思想来满足我们的生产环境，比如微服务之间调用需要进行鉴权的时候，我们就可以使用这种 token 的机制。</p>
</li>
<li><p>后台的 access_token 也会泄漏，什么时候需要刷新 token，刷新后需要重新获取？</p>
<ol>
<li>若 access_token 已超时，那么进行 refresh_token 会获取一个新的 access_token，新的超时时间；</li>
<li>若 access_token 未超时，那么进行 refresh_token 有两种结果方式：<ol>
<li>会改变 access_token，但超时时间会刷新，相当于续期 access_token，有的开放平台是这么做的</li>
<li>更新 access_token 的值，我们建议【统一更新 access_token 的值】。</li>
</ol>
</li>
<li>refresh_token 拥有较长的有效期，当 refresh_token 失效后，需要用户重新授权。<br>课程中也有提到，有了 refresh_token 的参与，提升了用户的体验。</li>
</ol>
</li>
<li><p>第三方服务获取到 access_token 后，access_token 的有效期是在第三方服务管理吗？access_token 有效期到期时通过 refresh_token 请求新 access_token？还是第三方服务每一次请求都会到授权服务上更新 access_token 过期时间？</p>
<p>access_token 的有效期在授权服务侧管理，也就是平台一侧，其实也谈不上管理，实际是一个时间戳，每次访问会判断时间间隔。如果想【提前】发现 access_token 的有效期是否到期则需要第三方软件额外的去处理，比如定时检查。</p>
<p>refresh_token 的作用就是在 access_token 到期的时候，不需要用户的参与的情况下，重新获得访问令牌的值。</p>
<p>只会更新 access_token 值，不会更新 access_token 的过期时间。</p>
</li>
<li><p>第三方软件前端拿到 token 后，传给后端，后端再去请求 access_token，这两步都是 http 请求，都有可能被窃取的风险，是不是 <strong>授权服务必须要绑定第三方服务请求 access_token 的域名或IP</strong>？</p>
<p>我们常说的 token 和 access_token，实指一个东西，就是 access_token。传输一定要在HTTPS中进行。</p>
<p>第三方应用添加 IP 白名单也是一个安全防护的措施，开放平台也会这么做。</p>
</li>
<li><p>第三方软件使用 access_token 访问受保护资源，可以通过 access_token 解析信息？</p>
<p>需要换取用户信息。</p>
<p>生成 access_token 的时候的粒度一般是 <code>app_id+用户</code>，这样 access_token 和 <code>app_id+用户</code> 有个对应关系，数据服务这一层他们是不知道 token 的，需要解析出用户，才能调用数据的 API。</p>
<p>一般如果有 API GATEWAY 这一层的话，这个工作是在 API GATEWAY 来处理的，如果没有就是在受保护资源服务这层来处理。</p>
</li>
<li><p>授权码和相关数据被窃取后咋办，或者说要用授权码换 token，还需要那些信息，这些信息中那些是安全性较高的?</p>
<p>app_secret 的安全性会比较高，这个信息是在第三方软件来平台注册的时候，平台为其分配的。</p>
</li>
<li><p>access_token 一般放在后台管理吗？还是客户端自己管理？</p>
<p>放在第三方软件的后台存储管理</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>oath 角色类型</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安全、快速地接入 OAuth 2.0？</title>
    <url>/2024/07/19/05/</url>
    <content><![CDATA[<p>在 <a href="./03.md">第 3 讲</a>，我已经讲了授权服务的流程，如果你还记得的话，当时我特意强调了一点，就是 <strong>授权服务将 OAuth 2.0 的复杂性都揽在了自己身上</strong>，这也是授权服务为什么是 OAuth 2.0 体系的核心的原因之一。</p>
<p>虽然授权服务做了大部分工作，但是呢，在 OAuth 2.0 的体系里面，<strong>除了资源拥有者是作为用户参与</strong>，还有另外两个系统角色，也就是第三方软件和受保护资源服务。那么今天这一讲，我们就站在这两个角色的角度，看看它们应该做哪些工作，才能接入到 OAuth 2.0 的体系里面呢？</p>
<p>现在，就让我们来看看，作为第三方软件的小兔和京东的受保护资源服务，具体需要着重处理哪些工作吧。</p>
<p>注：另外说明一点，为了脱敏的需要，在下面的讲述中，我只是把京东商家开放平台作为一个角色使用，以便有场景感，来帮助你理解。</p>
<h2 id="构建第三方软件应用"><a href="#构建第三方软件应用" class="headerlink" title="构建第三方软件应用"></a>构建第三方软件应用</h2><p>我们先来思考一下：如果要基于京东商家开放平台构建一个小兔打单软件的应用，小兔软件的研发人员应该做哪些工作？</p>
<p>是不是要到京东商家开放平台申请注册为开发者，在成为开发者以后再创建一个应用，之后我们就开始开发了，对吧？没错，一定是这样的流程。那么，开发第三方软件应用的过程中，我们需要重点关注哪些内容呢？</p>
<p>我先来和你总结下，这些内容包括 4 部分，分别是：<strong>注册信息、引导授权、使用访问令牌、使用刷新令牌。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/ee18ea7aab4fbee26cf23d7613801078.png"
                      alt="img"
                ></p>
<h3 id="第一点，注册信息。"><a href="#第一点，注册信息。" class="headerlink" title="第一点，注册信息。"></a>第一点，注册信息。</h3><p>首先，小兔软件只有先有了身份，才可以参与到 OAuth 2.0 的流程中去。也就是说，小兔软件需要先拥有自己的 app_id 和 app_serect 等信息，同时还要填写自己的回调地址 redirect_uri、申请权限等信息。</p>
<p>这种方式的注册呢，我们有时候也称它为 <strong>静态注册</strong>，也就是小兔软件的研发人员提前登录到京东商家开放平台进行手动注册，以便后续使用这些注册的相关信息来请求访问令牌。</p>
<h3 id="第二点，引导授权。"><a href="#第二点，引导授权。" class="headerlink" title="第二点，引导授权。"></a>第二点，引导授权。</h3><p>当用户需要使用第三方软件，来操作其在受保护资源上的数据，就需要第三方软件来引导授权。比如，小明要使用小兔打单软件来对店铺里面的订单发货打印，那小明首先访问的一定是小兔软件（原则上是直接访问第三方软件，不过我们在后面讲到服务市场这种场景的时候，会有稍微不同），不会是授权服务，更不会是受保护资源服务。</p>
<p>但是呢，小兔软件需要小明的授权，只有授权服务才能允许小明这样做。所以呢，小兔软件需要 「配合」 小明做的第一件事儿，<strong>就是将小明引导至授权服务</strong>，如下面代码所示。</p>
<p>那去做什么呢？其实就是让用户为第三方软件授权，得到了授权之后，第三方软件才可以代表用户去访问数据。也就是说，小兔打单软件获得授权之后，才能够代表小明处理其在京东店铺上的订单数据。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">oauthUrl</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8081/ch03/oath?scope=today%20history&amp;response_type=code&amp;redirect_uri=http://localhost:8080/ch03/callback&amp;app_id=APPID_RABBIT&quot;</span>;</span><br><span class="line">response.sendRedirect(toOauthUrl);</span><br></pre></td></tr></table></figure></div>

<h3 id="第三点，使用访问令牌。"><a href="#第三点，使用访问令牌。" class="headerlink" title="第三点，使用访问令牌。"></a>第三点，使用访问令牌。</h3><p><strong>拿到令牌后去使用令牌，才是第三方软件的最终目的</strong>。然后我们看看如何使用令牌。目前 OAuth 2.0 的令牌只支持一种类型，那就是 bearer 令牌，也就是我之前讲到的可以是任意字符串格式的令牌。</p>
<p>官方规范给出的使用访问令牌请求的方式，有三种，分别是：</p>
<ul>
<li><p>Form-Encoded Body Parameter（表单参数）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /resource HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>URI Query Parameter（URI 查询参数）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /resource?access_token=b1a64d5c-5e0c-4a70-9711-7af6568a61fb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Authorization Request Header Field（授权请求头部字段）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /resource HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Bearer b1a64d5c-5e0c-4a70-9711-7af6568a61fb</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>也就是说，这三种方式都可以请求到受保护资源服务。那么，我们采用哪种方式最合适呢？</p>
<p>根据 OAuth 2.0 的官方建议，系统在接入 OAuth 2.0 之前信息传递的请求载体是 JSON 格式的，那么如果继续采用表单参数提交的方式，令牌就无法加入进去了，因为格式不符。如果这时采用参数传递的方式呢，整个 URI 会被整体复制，安全性是最差的。而请求头部字段的方式就没有上述的这些烦恼，<strong>因此官方的建议是采用 Authorization 的方式来传递令牌</strong>。</p>
<p>但是，<strong>我建议你采用表单提交，也就是 POST 的方式来提交令牌，</strong> 类似如下代码所示。原因是这样的，从官方的建议中也可以看出，它指的是在接入 OAuth 2.0 之前，如果你已经采用了 JSON 数据格式请求体的情况下，不建议使用表单提交。但是，刚开始的时候，只要三方软件和平台之间约束好了，大家一致采用表单提交，就没有任何问题了。<strong>因为表单提交的方式在保证安全传输的同时，还不需要去额外处理 Authorization 头部信息</strong>。</p>
<h3 id="第四点，使用刷新令牌。"><a href="#第四点，使用刷新令牌。" class="headerlink" title="第四点，使用刷新令牌。"></a>第四点，使用刷新令牌。</h3><p>我在讲授权服务的时候提到过，如果访问令牌过期了，小兔软件总不能立马提示并让小明重新授权一次，否则小明的体验将会非常不好。为了解决这个问题呢，就用到了刷新令牌。</p>
<p>使用刷新令牌的方式跟使用访问令牌是一样的，具体可以参照上面我们讲的访问令牌的方式。关于刷新令牌的使用，<strong>你最需要关心的是，什么时候你会来决定使用刷新令牌</strong>。</p>
<p>在小兔打单软件收到访问令牌的同时，也会收到访问令牌的过期时间 <code>expires_in</code>。一个设计良好的第三方应用，<strong>应该将 expires_in 值保存下来并定时检测</strong>；如果发现 expires_in 即将过期，则需要利用 refresh_token 去重新请求授权服务，以便获取新的、有效的访问令牌。</p>
<p>这种定时检测的方法可以提前发现访问令牌是否即将过期。此外，还有一种方法是「现场」发现。也就是说，比如小兔软件访问小明店铺订单的时候，突然收到一个访问令牌失效的响应，此时小兔软件立即使用 refresh_token 来请求一个访问令牌，以便继续代表小明使用他的数据。</p>
<p>综合来看的话，定时检测的方式，需要我们额外开发一个定时任务；而现场发现，就没有这种额外的工作量啦。具体采用哪一种方式，你可以结合自己的实际情况。不过呢，我还是建议你采用定时检测这种方式，因为它可以带来提前量，以便让我们有更好的主动性，而现场发现就有点被动了。</p>
<p>说到这里，我要再次提醒你注意的是，<strong>刷新令牌是一次性的，使用之后就会失效</strong>，但是它的有效期会比访问令牌要长。这个时候我们可能会想到，如果刷新令牌也过期了怎么办？在这种情况下，我们就需要将刷新令牌和访问令牌都放弃，相当于回到了系统的初始状态，只能让用户小明重新授权了。</p>
<p>到这里，我们来总结下，在构建第三方应用时，你需要重点关注的就是 <strong>注册、授权、访问令牌、刷新令牌</strong>。只要你掌握了这四部分内容，在类似京东这样的开放平台上开发小兔软件，就不再是什么困难的事情了。</p>
<h2 id="服务市场中的第三方应用软件"><a href="#服务市场中的第三方应用软件" class="headerlink" title="服务市场中的第三方应用软件"></a>服务市场中的第三方应用软件</h2><p>在构建第三方应用的引导授权时，我们说用户第一次「触摸」到的一定是第三方软件，但这并不是绝对的。这个不绝对，就发生在服务市场这样的场景里。</p>
<p>那什么是服务市场呢？说白了，就是你开发的软件，比如小兔打单软件、店铺装修软件等，都发布到这样一个 「市场」里面售卖。这样，当用户购买了这些软件之后，就可以在服务市场里面看到有个「立即使用」的按钮。点击这个按钮，用户就可以直接访问自己购买的第三方软件了。</p>
<p>比如，京东的京麦服务市场里有个「我的服务」目录，里面就存放了我购买的打单软件。小明就可以直接点击「立即使用」，继而进入小兔打单软件，如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/140a4efb622e21b21fcc4ff57653a915.png"
                      alt="img"
                ></p>
<p>那么，这里需要注意的是，作为第三方开发者来构建第三方软件的时候，在授权码环节除了要接收授权码 code 值之外，还要接收用户的订购相关信息，比如服务的版本号、服务代码标识等信息。</p>
<p>好了，以上就是关于构建第三方软件时需要注意的一些细节问题了。接下来，我们再谈谈构建受保护资源服务的时候，又需要重点处理哪些工作呢。</p>
<h2 id="构建受保护资源服务"><a href="#构建受保护资源服务" class="headerlink" title="构建受保护资源服务"></a>构建受保护资源服务</h2><p>你先想一想，实际上在整个开放授权的环境中，<strong>受保护资源最终指的还是 Web API</strong>，比如说，访问头像的 API、访问昵称的 API。对应到我们的打单软件中，受保护资源就是订单查询 API、批量查询 API 等。</p>
<p>在互联网上的系统之间的通信，基本都是以 Web API 为载体的形式进行。因此呢，当我们说受保护资源被授权服务保护着时，实际上说的是授权服务最终保护的是这些 Web API。我们在构建受保护资源服务的时候，除了基本的要检查令牌的合法性，还需要做些什么呢？我认为 <strong>最重要的就是权限范围了。</strong></p>
<p>在我们处理受保护资源服务中的逻辑的时候，<strong>校验权限的处理会占据很大的比重</strong>。你想啊，访问令牌递过来，你肯定要多看看令牌到底能操作哪些功能、又能访问哪些数据吧。现在，我们把这些权限的类别总结归纳下来，最常见的大概有以下几类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/e7b134686b9f2e824ffa8410e20f59f6.jpg"
                      alt="img"
                ></p>
<p>接下来，我和你具体说说这些权限是如何使用的。</p>
<ol>
<li><p>不同的权限对应不同的操作。</p>
<p>这里的操作，其实对应的是 Web API，比如目前京东商家开放平台提供有查询商品 API、新增商品 API、删除商品 API 这三种。如果小兔软件请求过来的一个访问令牌 access_token 的 scope 权限范围只对应了查询商品 API、新增商品 API，那么包含这个 access_token 值的请求，就不能执行删除商品 API 的操作。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不同的权限对应不同的操作</span></span><br><span class="line">String[] scope = OauthServlet.tokenScopeMap.get(accessToken);</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sbuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;scope.length;i++)&#123;</span><br><span class="line">    sbuf.append(scope[i]).append(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sbuf.toString().indexOf(<span class="string">&quot;query&quot;</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    queryGoods(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sbuf.toString().indexOf(<span class="string">&quot;add&quot;</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    addGoods(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sbuf.toString().indexOf(<span class="string">&quot;del&quot;</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    delGoods(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>不同的权限对应不同的数据。</p>
<p>这里的数据，就是指某一个 API 里包含的属性字段信息。比如，有一个查询小明信息的 API，返回的信息包括 Contact（email、phone、qq）、Like（Basketball、Swimming）、Personal Data（sex、age、nickname）。如果小兔软件请求过来的一个访问令牌 access_token 的 scope 权限范围只对应了 Personal Data，那么包含该 access_token 值的请求就不能获取到 Contact 和 Like 的信息，关于这部分的代码，实际跟不同权限对应不同操作的代码类似。</p>
<p>看到这里，你就明白了，这种 <strong>权限范围的粒度要比「不同的权限对应不同的操作」的粒度要小</strong>。这正是遵循了最小权限范围原则。</p>
</li>
<li><p>不同的用户对应不同的数据。</p>
<p>这种权限是什么意思呢？其实，这种权限实际上只是换了一种维度，将其定位到了用户上面。</p>
<p>一些基础类信息，比如获取地理位置、获取天气预报等，不会带有用户归属属性，也就是说这些信息并不归属于某个用户，是一类公有信息。对于这样的信息，平台提供出去的 API 接口都是「中性」的，没有用户属性。</p>
<p>但是，更多的场景却是基于用户属性的。还是以小兔打单软件为例，商家每次打印物流面单的时候，小兔打单软件都要知道是哪个商家的订单。这种情况下，商家为小兔软件授权，小兔软件获取的 access_token 实际上就包含了商家这个用户属性。</p>
<p>京东商家开放平台的受保护资源服务每次接收到小兔软件的请求时，都会根据该请求中 access_token 的值找到对应的商家 ID，继而根据商家 ID 查询到商家的订单信息，也就是不同的商家对应不同的订单数据。</p>
</li>
</ol>
<p>在上面讲三种权限的时候，我举的例子实际上都属于一个系统提供了查询、添加、删除这样的所有服务。此时你可能会想到，现在的系统不已经是分布式系统环境了么，如果有很多个受保护资源服务，比如提供用户信息查询的用户资源服务、提供商品查询的商品资源服务、提供订单查询的订单资源服务，<strong>那么每个受保护资源服务岂不是都要把上述的权限范围校验执行一遍吗，这样不就会有大量的重复工作产生么？</strong></p>
<p>在这里，我特别高兴你能想到这一点。为了应对这种情况，我们应该有一个 <strong>统一的网关层来处理这样的校验</strong>，所有的请求都会经过 API GATEWAY 跳转到不同的受保护资源服务。这样呢，我们就不需要在每一个受保护资源服务上都做一遍权限校验的工作了，而只需要在 API GATEWAY 这一层做权限校验就可以了。系统结构如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/a5175438e76411c808dd5e72d3d3dbb0.png"
                      alt="img"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截止到这一讲呢，我们已经把 OAuth 2.0 中授权码相关的流程所涉及到的内容都讲完了。通过 02 到 05 这 4 讲，你可以很清晰地理解授权码流程的核心原理了，也可以弄清楚如何使用以及如何接入这一授权流程了。</p>
<p>我在本讲开始的时候，提到 OAuth 2.0 的复杂性实际上都给了授权服务来承担，接着我从第三方软件和受保护资源的角度，分别介绍了这两部分系统在接入 OAuth 2.0 的时候应该注意哪些方面。总结下来，我其实希望你能够记住以下两点。</p>
<ol>
<li><p>对于第三方软件，比如小兔打单软件来讲，<strong>它的主要目的就是获取访问令牌，使用访问令牌</strong> ，这当然也是整个 OAuth 2.0 的目的，就是让第三方软件来做这两件事。在这个过程中需要强调的是，第三方软件在使用访问令牌的时候有三种方式，我们建议在平台和第三方软件约定好的前提下，<strong>优先采用 Post 表单提交的方式</strong>。</p>
</li>
<li><p>受保护资源系统，比如小兔软件要访问开放平台的订单数据服务，它需要注意的是权限的问题，这个权限范围主要包括，<strong>不同的权限会有不同的操作，不同的权限也会对应不同的数据，不同的用户也会对应不同的数据</strong>。</p>
</li>
</ol>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>如果使用刷新令牌 refresh_token 请求回来一个新的访问令牌 access_token，按照一般规则授权服务上旧的访问令牌应该要立即失效，但是如果在这之前已经有使用旧的访问令牌发出去的请求，不就受到影响了吗，这种情况下应该如何处理呢？</p>
<p>笔者就遇到过这样的问题：微信开发平台的做法是延迟失效，刷新 token 之后，之前的旧 token 在 1~2 分钟内还是有效的。唯一不清楚的时候，使用 spring security 如何实现这个功能。</p>
]]></content>
  </entry>
  <entry>
    <title>在 OAuth 2.0 中，如何使用 JWT 结构化令牌？</title>
    <url>/2024/07/19/04/</url>
    <content><![CDATA[<p>在上一讲，我们讲到了授权服务的核心就是 <strong>颁发访问令牌</strong>，而 OAuth 2.0 规范并没有约束访问令牌内容的生成规则，只要符合唯一性、不连续性、不可猜性就够了。这就意味着，我们 <strong>可以灵活选择令牌的形式</strong>，既可以是没有内部结构且不包含任何信息含义的随机字符串，也可以是具有内部结构且包含有信息含义的字符串。</p>
<p>随机字符串这样的方式我就不再介绍了，之前课程中我们生成令牌的方式都是默认一个随机字符串。而在结构化令牌这方面，目前用得最多的就是 JWT 令牌了。</p>
<p>接下来，我就要和你详细讲讲，JWT 是什么、原理是怎样的、优势是什么，以及怎么使用，同时我还会讲到令牌生命周期的问题。</p>
<h2 id="JWT-结构化令牌"><a href="#JWT-结构化令牌" class="headerlink" title="JWT 结构化令牌"></a>JWT 结构化令牌</h2><p>关于什么是 JWT，官方定义是这样描述的：</p>
<blockquote>
<p>JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。</p>
</blockquote>
<p>这个定义是不是很费解？我们简单理解下，JWT 就是用一种 <strong>结构化封装的方式来生成 token 的技术</strong>。结构化后的 token 可以被赋予非常丰富的含义，这也是它与原先毫无意义的、随机的字符串形式 token 的最大区别。</p>
<p><strong>结构化之后，令牌本身就可以被「塞进」一些有用的信息</strong>，比如小明为小兔软件进行了授权的信息、授权的范围信息等。或者，你可以形象地将其理解为这是一种「自编码」的能力，而这些恰恰是无结构化令牌所不具备的。</p>
<p>JWT 这种结构化体可以分为：</p>
<ul>
<li>HEADER（头部）</li>
<li>PAYLOAD（数据体）</li>
<li>SIGNATURE（签名）</li>
</ul>
<p>三部分。经过签名之后的 JWT 的整体结构，是被 <strong>句点符号</strong> 分割的三段内容，结构为 <code>header.payload.signature</code>。比如下面这个示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.</span><br><span class="line">eyJzdWIiOiJVU0VSVEVTVCIsImV4cCI6MTU4NDEwNTc5MDcwMywiaWF0IjoxNTg0MTA1OTQ4MzcyfQ.</span><br><span class="line">1HbleXbvJ_2SW8ry30cXOBGR9FW4oSWBd3PWaWKsEXE</span><br></pre></td></tr></table></figure></div>

<p>::: tip</p>
<p>注意：JWT 内部没有换行，这里只是为了展示方便，才将其用三行来表示。</p>
<p>:::</p>
<p>你可能会说，这个 JWT 令牌看起来也是毫无意义的、随机的字符串啊。确实，你直接去看这个字符串是没啥意义，但如果你把它拷贝到  <a class="link"   href="https://jwt.io/" >https://jwt.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  网站的在线校验工具中，就可以看到解码之后的数据：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/image-20201217100330577.png"
                      alt="image-20201217100330577"
                ></p>
<p>再看解码后的数据，你是不是发现它跟随机的字符串不一样了呢。很显然，现在呈现出来的就是结构化的内容了。接下来，我就具体和你说说 JWT 的这三部分。</p>
<ul>
<li><p><strong>HEADER</strong> </p>
<p>表示装载令牌类型和算法等信息，是 JWT 的头部。其中，</p>
<ul>
<li>typ 表示第二部分 PAYLOAD 是 JWT 类型，</li>
<li>alg 表示使用 HS256 对称签名的算法。</li>
</ul>
</li>
<li><p><strong>PAYLOAD</strong> 表示是 JWT 的数据体，代表了一组数据。其中，</p>
<ul>
<li>sub（令牌的主体，一般设为资源拥有者的唯一标识）、</li>
<li>exp（令牌的过期时间戳）、</li>
<li>iat（令牌颁发的时间戳）是 JWT 规范性的声明，代表的是常规性操作。</li>
</ul>
<p>更多的通用声明，你可以参考 <a class="link"   href="https://tools.ietf.org/html/rfc7519" >RFC 7519 开放标准 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。不过，在一个 JWT 内可以包含一切合法的 JSON 格式的数据，也就是说，PAYLOAD 表示的一组数据允许我们自定义声明。</p>
</li>
<li><p><strong>SIGNATURE</strong> 表示对 JWT 信息的签名。</p>
<p>那么，它有什么作用呢？我们可能认为，有了 HEADER 和 PAYLOAD 两部分内容后，就可以让令牌携带信息了，似乎就可以在网络中传输了，但是在网络中传输这样的信息体是不安全的，因为你在「裸奔」啊。所以，我们还需要对其进行加密签名处理，而 SIGNATURE 就是对信息的签名结果，当受保护资源接收到第三方软件的签名后需要验证令牌的签名是否合法。</p>
</li>
</ul>
<p>现在，我们知道了 JWT 的结构以及每部分的含义，那么具体到 OAuth 2.0 的授权流程中，JWT 令牌是如何被使用的呢？在讲如何使用之前呢，我先和你说说 「令牌内检」。</p>
<h2 id="令牌内检"><a href="#令牌内检" class="headerlink" title="令牌内检"></a>令牌内检</h2><p>什么是令牌内检呢？授权服务颁发令牌，受保护资源服务就要验证令牌。同时呢，授权服务和受保护资源服务，它俩是「一伙的」，还记得我之前在 <a href="./02.md">第 2 课</a> 讲过的吧。受保护资源来 <strong>调用授权服务提供的检验令牌的服务</strong>，<strong>我们把这种校验令牌的方式称为令牌内检。</strong></p>
<p>有时候授权服务依赖一个数据库，然后受保护资源服务也依赖这个数据库，也就是我们说的「共享数据库」。不过，在如今已经成熟的分布式以及微服务的环境下，不同的系统之间是依靠 <strong>服务</strong> 而 <strong>不是数据库</strong> 来通信了，比如授权服务给受保护资源服务提供一个 RPC 服务。如下图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/963bb5dfc504c700fce24c8aac0dd2bf.png"
                      alt="img"
                ></p>
<p>那么，在有了 JWT 令牌之后，我们就多了一种选择，<strong>因为 JWT 令牌本身就包含了之前所要依赖数据库或者依赖 RPC 服务才能拿到的信息</strong>，比如我上面提到的哪个用户为哪个软件进行了授权等信息。</p>
<p>接下来就让我们看看有了 JWT 令牌之后，整体的内检流程会变成什么样子。</p>
<h2 id="JWT-是如何被使用的？"><a href="#JWT-是如何被使用的？" class="headerlink" title="JWT 是如何被使用的？"></a>JWT 是如何被使用的？</h2><p>有了 JWT 令牌之后的通信方式，就如下面的图 3 所展示的那样了，<strong>授权服务「扔出」一个令牌，受保护资源服务「接住」这个令牌，然后自己开始解析令牌本身所包含的信息就可以了，而不需要再去查询数据库或者请求 RPC 服务</strong>。这样也实现了我们上面说的令牌内检。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/1a4cf53349aeb5d588e27c608e06d539.png"
                      alt="img"
                ></p>
<p>在上面这幅图中呢，为了更能突出 JWT 令牌的位置，我简化了逻辑关系。实际上，授权服务颁发了 JWT 令牌后给到了小兔软件，小兔软件拿着 JWT 令牌来请求受保护资源服务，也就是小明在京东店铺的订单。很显然，JWT 令牌需要在公网上做传输。<strong>所以在传输过程中，JWT 令牌需要进行 Base64 编码以防止乱码，同时还需要进行签名及加密处理来防止数据信息泄露</strong>。</p>
<p>如果是我们自己处理这些编码、加密等工作的话，就会增加额外的编码负担。好在，我们可以借助一些开源的工具来帮助我们处理这些工作。比如，我在下面的 Demo 中，给出了开源 <code>JJWT（Java JWT）</code> 的使用方法。</p>
<p>JJWT 是目前 Java 开源的、比较方便的 JWT 工具，封装了 Base64URL 编码和对称 HMAC、非对称 RSA 的一系列签名算法。使用 JJWT，我们只关注上层的业务逻辑实现，而无需关注编解码和签名算法的具体实现，这类开源工具可以做到「开箱即用」。</p>
<p>这个 Demo 的代码如下，使用 JJWT 可以很方便地生成一个经过签名的 JWT 令牌，以及解析一个 JWT 令牌。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String sharedTokenSecret=<span class="string">&quot;hellooauthhellooauthhellooauthhellooauth&quot;</span>;<span class="comment">//密钥</span></span><br><span class="line"><span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(sharedTokenSecret.getBytes(),</span><br><span class="line">                SignatureAlgorithm.HS256.getJcaName());</span><br><span class="line"><span class="comment">//生成JWT令牌</span></span><br><span class="line">String jwts=</span><br><span class="line">Jwts.builder().setHeaderParams(headerMap).setClaims(payloadMap).signWith(key,SignatureAlgorithm.HS256).compact()</span><br><span class="line">    </span><br><span class="line"><span class="comment">//解析JWT令牌</span></span><br><span class="line">Jws&lt;Claims&gt; claimsJws =Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(jwts);</span><br><span class="line"><span class="type">JwsHeader</span> <span class="variable">header</span> <span class="operator">=</span> claimsJws.getHeader();</span><br><span class="line"><span class="type">Claims</span> <span class="variable">body</span> <span class="operator">=</span> claimsJws.getBody();  </span><br></pre></td></tr></table></figure></div>

<p>使用 JJWT 解析 JWT 令牌时包含了验证签名的动作，如果签名不正确就会抛出异常信息。我们可以借助这一点来对签名做校验，从而判断是否是一个没有被伪造过的、合法的 JWT 令牌。</p>
<p>异常信息，一般是如下的样子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.</span><br></pre></td></tr></table></figure></div>

<p>以上就是借助开源工具，将 JWT 令牌应用到授权服务流程中的方法了。到这里，你是不是一直都有一个疑问：为什么要绕这么大一个弯子，使用 JWT，而不是使用没有啥内部结构，也不包含任何信息的随机字符串呢？JWT 到底有什么好处？</p>
<h2 id="为什么要使用-JWT-令牌？"><a href="#为什么要使用-JWT-令牌？" class="headerlink" title="为什么要使用 JWT 令牌？"></a>为什么要使用 JWT 令牌？</h2><p>别急，我这就和你总结下使用 JWT 格式令牌的三大好处。</p>
<p>第一，<strong>JWT 的核心思想，就是用计算代替存储，有些 「时间换空间」 的 「味道」</strong>。当然，这种经过计算并结构化封装的方式，也减少了共享数据库因远程调用而带来的网络传输消耗，所以也有可能是节省时间的。</p>
<p>第二，也是一个重要特性，是加密。因为 JWT 令牌内部已经包含了重要的信息，所以在整个传输过程中都必须被要求是密文传输的，<strong>这样被强制要求了加密也就保障了传输过程中的安全性</strong>。这里的加密算法，既可以是对称加密，也可以是非对称加密。</p>
<p>第三，<strong>使用 JWT 格式的令牌，有助于增强系统的可用性和可伸缩性</strong>。这一点要怎么理解呢？我们前面讲到了，这种 JWT 格式的令牌，通过「自编码」的方式包含了身份验证需要的信息，不再需要服务端进行额外的存储，所以每次的请求都是无状态会话。这就符合了我们尽可能遵循无状态架构设计的原则，也就是增强了系统的可用性和伸缩性。</p>
<p>但，万物皆有两面性，JWT 令牌也有缺点。</p>
<p>JWT 格式令牌的最大问题在于 「覆水难收」，也就是说，没办法在使用过程中修改令牌状态。我们还是借助小明使用小兔软件例子，先停下来想一下。</p>
<p>小明在使用小兔软件的时候，是不是有可能因为某种原因修改了在京东的密码，或者是不是有可能突然取消了给小兔的授权？这时候，令牌的状态是不是就要有相应的变更，将原来对应的令牌置为无效。</p>
<p>但，使用 JWT 格式令牌时，每次颁发的令牌都不会在服务端存储，这样我们要改变令牌状态的时候，就无能为力了。因为服务端并没有存储这个 JWT 格式的令牌。这就意味着，JWT 令牌在有效期内，是可以横行无止的。</p>
<p>为了解决这个问题，<strong>我们可以把 JWT 令牌存储到远程的分布式内存数据库中吗？显然不能，因为这会违背 JWT 的初衷（将信息通过结构化的方式存入令牌本身）</strong>。因此，我们通常会有两种做法：</p>
<ul>
<li><p>一是，<strong>将每次生成 JWT 令牌时的秘钥粒度缩小到用户级别</strong>，也就是一个用户一个秘钥。这样，当用户取消授权或者修改密码后，就可以让这个密钥一起修改。一般情况下，这种方案需要配套一个单独的密钥管理服务。</p>
</li>
<li><p>二是，在不提供用户主动取消授权的环境里面，如果只考虑到修改密码的情况，那么我们就可以把用户密码作为 JWT 的密钥。当然，这也是用户粒度级别的。这样一来，用户修改密码也就相当于修改了密钥。</p>
</li>
</ul>
<h2 id="令牌的生命周期"><a href="#令牌的生命周期" class="headerlink" title="令牌的生命周期"></a>令牌的生命周期</h2><p>我刚才讲了 JWT 令牌有效期的问题，讲到了它的失效处理，另外咱们在 <a href="./03.md">第 3 讲</a> 中提到，授权服务颁发访问令牌的时候，都会设置一个过期时间，其实这都属于令牌的生命周期的管理问题。接下来，我便向你讲一讲令牌的生命周期。</p>
<p>万物皆有周期，这是自然规律，令牌也不例外，无论是 JWT 结构化令牌还是普通的令牌。它们都有有效期，只不过，JWT 令牌可以把有效期的信息存储在本身的结构体中。</p>
<p>具体到 OAuth 2.0 的令牌生命周期，通常会有三种情况。</p>
<p><strong>第一种情况是令牌的自然过期过程</strong>，这也是最常见的情况。这个过程是，从授权服务创建一个令牌开始，到第三方软件使用令牌，再到受保护资源服务验证令牌，最后再到令牌失效。同时，这个过程也不排除主动销毁令牌的事情发生，比如令牌被泄露，授权服务可以做主让令牌失效。</p>
<p>生命周期的第二种情况，也就是上一讲提到的，<strong>访问令牌失效之后可以使用刷新令牌请求新的访问令牌来代替失效的访问令牌</strong>，以提升用户使用第三方软件的体验。</p>
<p>生命周期的第三种情况，<strong>就是让第三方软件比如小兔，主动发起令牌失效的请求，然后授权服务收到请求之后让令牌立即失效</strong>。我们来想一下，什么情况下会需要这种机制，也就是想一下第三方软件这样做的 「动机」，毕竟一般情况下 「我们很难放弃已经拥有的事物」。</p>
<p>比如有些时候，用户和第三方软件之间存在一种订购关系，比如小明购买了小兔软件，那么在订购时长到期或者退订，且小明授权的 token 还没有到期的情况下，就需要有这样的一种令牌撤回协议，来支持小兔软件主动发起令牌失效的请求。作为平台一方比如京东商家开放平台，也建议有责任的第三方软件比如小兔软件，遵守这样的一种令牌撤回协议。</p>
<p>我将以上三种情况整理成了一份序列图，以便帮助你理解。同时，为了突出令牌，我将访问令牌和刷新令牌，特意用深颜色标识出来，并单独作为两个角色放进了整个序列图中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/bc5fde2c813d41c60d863e2919b65565.png"
                      alt="img"
                ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OAuth 2.0 的核心是授权服务，更进一步讲是令牌，<strong>没有令牌就没有 OAuth，</strong>令牌表示的是授权行为之后的结果。</p>
<p>一般情况下令牌对第三方软件来说是一个随机的字符串，是不透明的。大部分情况下，我们提及的令牌，都是一个无意义的字符串。</p>
<p>但是，人们「不甘于」这样的满足，于是开始探索有没有其他生成令牌的方式，也就有了 JWT 令牌，这样一来既不需要通过共享数据库，也不需要通过授权服务提供接口的方式来做令牌校验了。这就相当于通过 JWT 这种结构化的方式，我们在做令牌校验的时候多了一种选择。</p>
<p>通过这一讲呢，我希望你能记住以下几点内容：</p>
<ol>
<li><p>我们有了新的令牌生成方式的选择，这就是 JWT 令牌。这是一种结构化、信息化令牌，<strong>结构化可以组织用户的授权信息，信息化就是令牌本身包含了授权信息</strong>。</p>
</li>
<li><p>虽然我们这讲的重点是 JWT 令牌，但是呢，不论是结构化的令牌还是非结构化的令牌，对于第三方软件来讲，它都不关心，因为 <strong>令牌在 OAuth 2.0 系统中对于第三方软件都是不透明的</strong> 。需要关心令牌的，是授权服务和受保护资源服务。</p>
</li>
<li><p>我们需要注意 JWT 令牌的失效问题。我们使用了 JWT 令牌之后，远程的服务端上面是不存储的，因为不再有这个必要，JWT 令牌本身就包含了信息。那么，如何来控制它的有效性问题呢？本讲中，我给出了两种建议，<strong>一种是建立一个秘钥管理系统，将生成秘钥的粒度缩小到用户级别，另外一种是直接将用户密码当作密钥。</strong></p>
</li>
</ol>
<p>现在，你已经对 JWT 有了更深刻的认识，也知道如何来使用它了。当你构建并生成令牌的时候除了使用随机的、「任性的」字符串，还可以采用这样的结构化的令牌，以便在令牌校验的时候能解析出令牌的内容信息直接进行校验处理。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这部分代码的测试在 <a class="link"   href="https://github.com/zq99299/myoath2-demo/blob/main/oauth-server/src/main/java/cn/mrcode/myoath2/oauthserver/ch04/JWTTest.java" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>添加 JWT 的依赖包</p>
<div class="highlight-container" data-rel="Groovy"><figure class="iseeu highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="attr">group:</span> <span class="string">&#x27;io.jsonwebtoken&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;jjwt-api&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;0.11.2&#x27;</span></span><br><span class="line">compile <span class="attr">group:</span> <span class="string">&#x27;io.jsonwebtoken&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;jjwt-impl&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;0.11.2&#x27;</span></span><br><span class="line">compile <span class="attr">group:</span> <span class="string">&#x27;io.jsonwebtoken&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;jjwt-jackson&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;0.11.2&#x27;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">sharedTokenSecret</span> <span class="operator">=</span> <span class="string">&quot;hellooauthhellooauthhellooauthhellooauth&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用密匙生成 JWT 令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildJewTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> buildJwt();</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt:&quot;</span>);</span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">buildJwt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(sharedTokenSecret.getBytes(), SignatureAlgorithm.HS256.getJcaName());</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; headerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    headerMap.put(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>);</span><br><span class="line">    headerMap.put(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; payloadMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    payloadMap.put(<span class="string">&quot;iss&quot;</span>, <span class="string">&quot;http://localhost:8081/&quot;</span>);</span><br><span class="line">    payloadMap.put(<span class="string">&quot;sub&quot;</span>, <span class="string">&quot;XIAOMINGTEST&quot;</span>);</span><br><span class="line">    payloadMap.put(<span class="string">&quot;aud&quot;</span>, <span class="string">&quot;APPID_RABBIT&quot;</span>);</span><br><span class="line">    payloadMap.put(<span class="string">&quot;exp&quot;</span>, <span class="number">1584105790703L</span>);</span><br><span class="line">    payloadMap.put(<span class="string">&quot;iat&quot;</span>, <span class="number">1584105948372L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 Jwt 令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder().setHeaderParams(headerMap).setClaims(payloadMap).signWith(key, SignatureAlgorithm.HS256).compact();</span><br><span class="line">    <span class="keyword">return</span> jwt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用密匙解析 JWT 令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parserJwt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(sharedTokenSecret.getBytes(), SignatureAlgorithm.HS256.getJcaName());</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> buildJwt();</span><br><span class="line"></span><br><span class="line">    Jws&lt;Claims&gt; claimsJws = Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(jwt);</span><br><span class="line"></span><br><span class="line">    <span class="type">JwsHeader</span> <span class="variable">header</span> <span class="operator">=</span> claimsJws.getHeader();</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">body</span> <span class="operator">=</span> claimsJws.getBody();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;jwt header:&quot;</span> + header);</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt body:&quot;</span> + body);</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt sub:&quot;</span> + body.getSubject());</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt aud:&quot;</span> + body.getAudience());</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt iss:&quot;</span> + body.getIssuer());</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt exp:&quot;</span> + body.getExpiration());</span><br><span class="line">    System.out.println(<span class="string">&quot;jwt iat:&quot;</span> + body.getIssuedAt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意一点的是：这里 APi 不用密匙，将解析报错。而官网的在线解析不要密匙也是可以看到内容的，所以他的机制应该是：</p>
<ol>
<li>解析不需要密匙</li>
<li>校验签名：需要密匙</li>
</ol>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你还知道有哪些场景适合 JWT 令牌，又有哪些场景不适合 JWT 令牌吗？</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li>在 jwt.io 网站上验证的时候，如果不输入密钥，返回 <code>invalid Signature</code>, 但是 header 和 payload 信息依然可以正确显示。我的理解是，在生成 header 和 payload 部分的时候，是通过 base64 编码，没有进行加密处理。最后的签名是保证整个 body 在传输的过程中没有被篡改。那么是不是意味着使用 JWT 方式，信息的主体还是依然能被未授信的第三方获取到？</li>
</ul>
<p>  JWT 肯定要加密传输，这点我们文中强调了，不做加密的结果就是你说的，加密用对称和非对称都可以，看实际需要，追求性能就是对称，可通过管理秘钥来对冲掉对称带来的相比非对称的弱化的那部分安全。</p>
<ul>
<li><p>您提到 JWT 的一个优势是资源服务器不需要依赖数据库存储相关的信息，从而易于横向扩容。但是密钥部分还是躲不过需要查询的，可能依然需要存储。另外，如果采取一个用户用一个密钥的方式，资源服务器如何知道某个 JWT token 是给哪个用户使用的？（用户信息包含在 header or payload 中？）</p>
<p>是的，用生成秘钥的方法，这是管理我们扔出去的 JWT TOKEN 的方式之一，如果只靠有效期当然也可以，但如果追求更进一步管理的话就需要做点额外的消耗。如果通过秘钥来管理，就需要一个秘钥管理系统，另外JWT 肯定是要加密处理，而且加解密的重点不在于加解密算法，而在于秘钥管理，需要我们要把秘钥生成在独立于授权系统之外的秘钥管理系统里面，存储关系就是 <code>app_id + 用户 = 秘钥</code>，这里的用户就是 TOKEN 换取出来的。</p>
</li>
<li><p>如果需要从服务器端直接暴力将某些用户「踢出下线」，也就是让 jwt 失效，如何做</p>
<p>还是通过管理密匙的部分，具体做法是：不用验证签名就能获取 jwt 中的 id 信息，然后获取该 id 的加密密匙，进行验证。 那么当需要让 jwt 失效的时候，修改这个密匙信息。</p>
</li>
<li><p>用户密码当做秘钥合适吗？，如果用户修改密码，所有的授权都会失效</p>
<p>用户修改密码，这个动作本身在安全背后是一件很严密的事情，对授权系统来讲，它接收到的事件，就是密码修改了，它的反应一定要让授权失效，因为授权系统不知道谁修改了密码。</p>
</li>
<li><p>jwt 如果每个用户一个密钥，就还需要访问数据库，这种方式和无结构的 token 优化没那么明显，只是省了token 的存储。</p>
<p>存储节省不明显是在用户量少的情况下。秘钥管理系统是 JWT 和 OAuth 2.0 之外的成本，安全问题的防护是一个成本问题，如果是低等级防护，当然可以直接使用 JWT 的令牌短时过期。</p>
</li>
<li><p>jwt 中 signature 已经在签名的时候用到了一个 secret，这样已经能保证只有知道 secret 的第三个方才能验证 jwt 合法性，为什么还要加密，为了防止解密出 head 和 payload？</p>
<p>是的，为了防止解密出 payload。在将 JWT 用作【访问令牌】的时候，令牌的内容第三方应用也是不能被允许知道的，对于第三方应用来讲【访问令牌】对它不透明。</p>
<p>后续章节有一个知识点是，通过 OAuth 2.0 来实现一个用户身份认证的时候会用到【ID 令牌】，这个【ID 令牌】允许被第三方软件解析，因为这种情况需要一个用户标识。</p>
</li>
<li><p>我对 JWT 的理解是：JWT 本身只对 payload 进行了签名，并没有做加密（base64 编码不算加密）。文中多次提到加密，我比较疑惑，是我的理解错了吗？</p>
<p>你理解是对的，签名是签名，加密是加密。所以在 jwt.io 网站上，不使用密匙也可以看到 payload 信息。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>除了授权码许可类型，OAuth 2.0 还支持什么授权流程？</title>
    <url>/2024/07/19/06/</url>
    <content><![CDATA[<p>在前面几讲学习授权码许可类型的原理与工作流程时，不知道你是不是一直有这样一个疑问：授权码许可的流程最完备、最安全没错儿，但它适合所有的授权场景吗？在有些场景下使用授权码许可授权，是不是过于复杂了，是不是根本就没必要这样？</p>
<p>比如，小兔打单软件是京东官方开发的一款软件，那么小明在使用小兔的时候，还需要小兔再走一遍授权码许可类型的流程吗？估计你也猜到答案了，肯定是不需要了。</p>
<p>你还记得 <strong>授权码许可流程的特点</strong> 么？<strong>它通过授权码这种临时的中间值，让小明这样的用户参与进来</strong>，从而让小兔软件和京东之间建立联系，进而让小兔代表小明去访问他在京东店铺的订单数据。</p>
<p>现在小兔被「招安」了，是京东自家的了，是被京东充分信任的，没有「第三方软件」的概念了。同时，小明也是京东店铺的商家，也就是说 <strong>软件和用户都是京东的资产</strong>。这时，显然没有必要再使用授权码许可类型进行授权了。但是呢，小兔依然要通过互联网访问订单数据的 Web API，来提供为小明打单的功能。</p>
<p>于是，为了保护这些场景下的 Web API，又为了让 OAuth 2.0 更好地适应现实世界的更多场景，来解决比如上述小兔软件这样的案例，OAuth 2.0 体系中还提供了 <strong>资源拥有者凭据许可类型</strong>。</p>
<h2 id="资源拥有者凭据许可"><a href="#资源拥有者凭据许可" class="headerlink" title="资源拥有者凭据许可"></a>资源拥有者凭据许可</h2><p>从「资源拥有者凭据许可」这个命名上，你可能就已经理解它的含义了。没错，资源拥有者的凭据，就是用户的凭据，就是 <strong>用户名和密码</strong>。可见，这是最糟糕的一种方式。那为什么 OAuth 2.0 还支持这种许可类型，而且编入了 OAuth 2.0 的规范呢？</p>
<p>我们先来思考一下。正如上面我提到的，小兔此时就是京东官方出品的一款软件，小明也是京东的用户，<strong>那么小明其实是可以使用用户名和密码来直接使用小兔这款软件的</strong>。原因很简单，那就是 <strong>这里不再有「第三方」的概念了</strong>。</p>
<p>但是呢，如果每次小兔都是拿着小明的用户名和密码来通过调用 Web API 的方式，来访问小明店铺的订单数据，甚至还有商品信息等，在调用这么多 API 的情况下，无疑增加了用户名和密码等敏感信息的攻击面。</p>
<p>如果是使用了 token 来代替这些「满天飞」的敏感信息，不就能很大程度上保护敏感信息数据了吗？这样，小兔软件只需要使用一次用户名和密码数据来换回一个 token，进而通过 token 来访问小明店铺的数据，以后就不会再使用用户名和密码了。</p>
<p>接下来，我们一起看下这种许可类型的流程，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/cd596cfd73a42449a39342f951c5cce9.png"
                      alt="img"
                ></p>
<ul>
<li><p>步骤 1：当用户访问第三方软件小兔时，会提示输入用户名和密码。索要用户名和密码，就是 <strong>资源拥有者凭据许可类型的特点</strong>。</p>
</li>
<li><p>步骤 2：<strong>这里的 grant_type 的值为 password</strong>，告诉授权服务使用资源拥有者凭据许可凭据的方式去请求访问。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">params.put(<span class="string">&quot;grant_type&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;app_id&quot;</span>,<span class="string">&quot;APPIDTEST&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;app_secret&quot;</span>,<span class="string">&quot;APPSECRETTEST&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;NAMETEST&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;PASSWORDTEST&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> HttpURLClient.doPost(oauthURl,HttpURLClient.mapToStr(params));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>步骤 3：授权服务在验证用户名和密码之后，生成 access_token 的值并返回给第三方软件。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;password&quot;</span>.equals(grantType))&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">appSecret</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;app_secret&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="string">&quot;APPSECRETTEST&quot;</span>.equals(appSecret))&#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;app_secret is not available&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="string">&quot;USERNAMETEST&quot;</span>.equals(username))&#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;username is not available&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="string">&quot;PASSWORDTEST&quot;</span>.equals(password))&#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;password is not available&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken(appId,<span class="string">&quot;USERTEST&quot;</span>);<span class="comment">//生成访问令牌access_token的值</span></span><br><span class="line">    response.getWriter().write(accessToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>到了这里，你可以掌握到一个信息：<strong>如果软件是官方出品的，又要使用 OAuth 2.0 来保护我们的 Web API，那么你就可以使用小兔软件的做法，采用资源拥有者凭据许可类型</strong>。</p>
<p>无论是我们的架构、系统还是框架，都是致力于解决现实生产中的各种问题的。除了资源拥有者凭据许可类型外，OAuth 2.0 体系针对现实的环境还提供了客户端凭据许可和隐式许可类型。接下来，让我们继续看看这两种授权许可类型吧。</p>
<h2 id="客户端凭据许可"><a href="#客户端凭据许可" class="headerlink" title="客户端凭据许可"></a>客户端凭据许可</h2><p><strong>如果没有明确的资源拥有者</strong>，换句话说就是，小兔软件访问了一个不需要用户小明授权的数据，比如获取京东 LOGO 的图片地址，这个 LOGO 信息不属于任何一个第三方用户，再比如其它类型的第三方软件来访问平台提供的省份信息，省份信息也不属于任何一个第三方用户。</p>
<p>此时，在授权流程中，就不再需要资源拥有者这个角色了。当然了，<strong>你也可以形象地理解为 「资源拥有者被塞进了第三方软件中」 或者 「第三方软件就是资源拥有者」</strong>。这种场景下的授权，便是客户端凭据许可，第三方软件可以直接使用注册时的 app_id 和 app_secret 来换回访问令牌 token 的值。</p>
<p>我们还是以小明使用小兔软件为例，来看下客户端凭据许可的整个授权流程，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/cbc8cc1e03cb1d0a2f945ffd9dbb37ff.png"
                      alt="img"
                ></p>
<p>另外一点呢，因为授权过程没有了资源拥有者小明的参与，小兔软件的后端服务可以随时发起 access_token 的请求，所以 <strong>这种授权许可也不需要刷新令牌</strong>。</p>
<p>这样一来，客户端凭据许可类型的关键流程，就是以下两大步。</p>
<ul>
<li><p>步骤 1：第三方软件小兔通过后端服务向授权服务发送请求，<strong>这里 grant_type 的值为 client_credentials</strong>，告诉授权服务要使用第三方软件凭据的方式去请求访问。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">params.put(<span class="string">&quot;grant_type&quot;</span>,<span class="string">&quot;client_credentials&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;app_id&quot;</span>,<span class="string">&quot;APPIDTEST&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;app_secret&quot;</span>,<span class="string">&quot;APPSECRETTEST&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> HttpURLClient.doPost(oauthURl,HttpURLClient.mapToStr(params));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>步骤 2：在验证 app_id 和 app_secret 的合法性之后，生成 access_token 的值并返回。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">grantType</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;grant_type&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">appId</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;app_id&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="string">&quot;APPIDTEST&quot;</span>.equals(appId))&#123;</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;app_id is not available&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;client_credentials&quot;</span>.equals(grantType))&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">appSecret</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;app_secret&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="string">&quot;APPSECRETTEST&quot;</span>.equals(appSecret))&#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;app_secret is not available&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken(appId,<span class="string">&quot;USERTEST&quot;</span>);<span class="comment">//生成访问令牌access_token的值</span></span><br><span class="line">    response.getWriter().write(accessToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>到这里，我们再小结下。在获取一种不属于任何一个第三方用户的数据时，并不需要类似小明这样的用户参与，此时便可以使用客户端凭据许可类型。</p>
<p>接下来，我们再一起看看今天要讲的最后一种授权许可类型，就是隐式许可类型。</p>
</li>
</ul>
<h2 id="隐式许可"><a href="#隐式许可" class="headerlink" title="隐式许可"></a>隐式许可</h2><p>让我们再想象一下，如果小明使用的小兔打单软件应用 <strong>没有后端服务</strong>，就是在浏览器里面执行的，比如纯粹的 JavaScript 应用，应该如何使用 OAuth 2.0 呢？</p>
<p>其实，这种情况下的授权流程就可以使用 <strong>隐式许可流程</strong>，<strong>可以理解为第三方软件小兔直接嵌入浏览器中了</strong>。</p>
<p>在这种情况下，小兔软件对于浏览器就没有任何保密的数据可以隐藏了，也不再需要应用密钥 app_secret 的值了，也不用再通过授权码 code 来换取访问令牌 access_token 的值了。因为使用授权码的目的之一，就是把浏览器和第三方软件的信息做一个隔离，确保浏览器看不到第三方软件最重要的访问令牌 access_token 的值。</p>
<p>因此，**隐式许可授权流程的安全性会降低很多 **。在授权流程中，没有服务端的小兔软件相当于是嵌入到了浏览器中，访问浏览器的过程相当于接触了小兔软件的全部，因此我用虚线框来表示小兔软件，整个授权流程如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/c957860d09beb8777c59978f3b9e2yy0.png"
                      alt="img"
                ></p>
<p>接下来，我使用 Servlet 的 Get 请求来模拟这个流程，一起看看相关的示例代码。</p>
<ul>
<li><p>步骤 1：用户通过浏览器访问第三方软件小兔。此时，第三方软件小兔实际上是嵌入浏览器中执行的应用程序。</p>
</li>
<li><p>步骤 2：这个流程和授权码流程类似，只是需要特别注意一点，<strong>response_type 的值变成了 token</strong>，是要告诉授权服务直接返回 access_token 的值。随着我们后续的讲解，你会发现隐式许可流程是唯一在前端通信中要求返回 access_token 的流程。对，就这么 「大胆」，但「不安全」。</p>
  <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">params.put(<span class="string">&quot;response_type&quot;</span>,<span class="string">&quot;token&quot;</span>);<span class="comment">//告诉授权服务直接返回access_token</span></span><br><span class="line">params.put(<span class="string">&quot;redirect_uri&quot;</span>,<span class="string">&quot;http://localhost:8080/AppServlet-ch02&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;app_id&quot;</span>,<span class="string">&quot;APPIDTEST&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">toOauthUrl</span> <span class="operator">=</span> URLParamsUtil.appendParams(oauthUrl,params);<span class="comment">//构造请求授权的URl</span></span><br><span class="line">response.sendRedirect(toOauthUrl);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>步骤 3：生成 acccess_token 的值，通过前端通信返回给第三方软件小兔。</p>
  <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">responseType</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;response_type&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">redirectUri</span> <span class="operator">=</span>request.getParameter(<span class="string">&quot;redirect_uri&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">appId</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;app_id&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="string">&quot;APPIDTEST&quot;</span>.equals(appId))&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;token&quot;</span>.equals(responseType))&#123;</span><br><span class="line">    <span class="comment">//隐式许可流程（模拟），DEMO CODE，注意：该流程全部在前端通信中完成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> generateAccessToken(appId,<span class="string">&quot;USERTEST&quot;</span>);<span class="comment">//生成访问令牌access_token的值</span></span><br><span class="line">    Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    params.put(<span class="string">&quot;redirect_uri&quot;</span>,redirectUri);</span><br><span class="line">    params.put(<span class="string">&quot;access_token&quot;</span>,accessToken);</span><br><span class="line">    <span class="type">String</span> <span class="variable">toAppUrl</span> <span class="operator">=</span> URLParamsUtil.appendParams(redirectUri,params);<span class="comment">//构造第三方软件的回调地址，并重定向到该地址</span></span><br><span class="line">    response.sendRedirect(toAppUrl);<span class="comment">//使用sendRedirect方式模拟前端通信</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>如果你的软件就是直接嵌入到了浏览器中运行，而且还没有服务端的参与，并且还想使用 OAuth 2.0 流程的话，也就是像上面我说的小兔这个例子，那么便可以直接使用隐式许可类型了。</p>
<h2 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h2><p>现在，我们已经理解了 OAuth 2.0 的 4 种授权许可类型的原理与流程。那么，我们应该如何选择到底使用哪种授权许可类型呢？</p>
<p>这里，我给你的建议是，在对接 OAuth 2.0 的时候先考虑授权码许可类型，其次再结合现实生产环境来选择：</p>
<ul>
<li><p>如果小兔软件是 <strong>官方出品</strong>，那么可以直接使用 <strong>资源拥有者凭据许可</strong>；</p>
</li>
<li><p>如果小兔软件就是 <strong>只嵌入到浏览器端的应用且没有服务端</strong>，那就 <strong>只能选择隐式许可</strong>；</p>
</li>
<li><p>如果小兔软件获取的信息 <strong>不属于任何一个第三方用户</strong>，那可以直接使用 <strong>客户端凭据许可类型</strong>。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，我们马上要结束这篇文章了，在这之前呢，我们一直讲的是授权码许可类型，你已经知道了这是一种流程最完备、安全性最高的授权许可流程。不过呢，现实世界总是有各种各样的变化，OAuth 2.0 也要适应这样的变化，所以才有了我们今天讲的另外这三种许可类型。同时，关于如何来选择使用这些许可类型，我前面也给了大家一个建议。</p>
<p>加上前面我们讲的授权码许可类型，我们一共讲了 4 种授权许可类型，它们最显著的区别就是 <strong>获取访问令牌 access_token 的方式不同</strong>。最后，我通过一张表格来对比下：</p>
<table>
<thead>
<tr>
<th align="center">授权许可类型</th>
<th align="center">获取访问令牌的方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">授权码许可</td>
<td align="center">通过授权码 code 获取 access_token</td>
</tr>
<tr>
<td align="center">客户端凭证许可</td>
<td align="center">通过第三方软件的 app_id 和 app_secret 获取 access_token</td>
</tr>
<tr>
<td align="center">隐式许可</td>
<td align="center">通过嵌入浏览器中的第三方软件的 app_id 来获取 access_token</td>
</tr>
<tr>
<td align="center">资源拥有者凭证许可</td>
<td align="center">通过资源拥有者的用户名和密码获取 access_token</td>
</tr>
</tbody></table>
<p>除了上面这张表格所展现的 4 种授权许可类型的区别之外，我希望你还能记住以下两点。</p>
<ol>
<li><p>所有的授权许可类型中，授权码许可类型的安全性是最高的。因此，只要具备使用授权码许可类型的条件，我们一定要首先授权码许可类型。</p>
</li>
<li><p>所有的授权许可类型都是为了解决现实中的实际问题，因此我们还要结合实际的生产环境，在保障安全性的前提下选择最合适的授权许可类型，比如使用客户端凭据许可类型的小兔软件就是一个案例。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 隐式许可</span><br><span class="line">http://localhost:8080/ch06/implicit</span><br><span class="line"></span><br><span class="line">// 客户端凭证许可</span><br><span class="line">http://localhost:8080/ch06/client_credentials</span><br><span class="line"></span><br><span class="line">// 资源拥有者许可</span><br><span class="line">http://localhost:8080/ch06/password</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://github.com/zq99299/myoath2-demo/blob/main/oauth-server/src/main/java/cn/mrcode/myoath2/oauthserver/ch06/Ch06OathServerController.java" >代码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 相对简单，没有完整按照协议实现，可以不去看。主要理解这里的流程。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>如果受限于应用特性所在的环境，比如在没有浏览器参与的情况下，我们应该如何选择授权许可类型呢，还可以使用授权码许可流程吗？</p>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><p>资源拥有者凭据许可，直接用用户名密码是前 <strong>端登陆还是后端登陆？</strong>例子中还需要携带 appID 和秘钥，那就是需要后端登陆。那这样的情况就是，<strong>官方出品所的产品都要自己提供登录接口，然后后端服务绕一圈去登录</strong>？能否直接在前端直接用用户名和密码登录？</p>
<p><strong>登录和授权是两个通路的事情，任何授权都是在用户登录之后进行的</strong>。</p>
<p>用户的用户名和密码是来进行登陆的，appID 和秘钥是用来换取访问令牌的。</p>
<p><strong>授权的本质是令牌</strong>，令牌是怎么换来的呢，是用户登录之后的授权，那生成令牌的时候是怎么跟用户的登录关联上的呢，<strong>因为授权和登录的后台处理都是「一家」的</strong>。</p>
<p>并不是说后端服务绕一圈再去登录，而且生产中登录和授权本来也是有分别的系统来进行处理。</p>
</li>
<li><p>对比了授权码许可类型，本文介绍的三种授权流程中，都不需要经过用户小明的「授权」操作吗？</p>
<p>只有客户端凭据许可不需要。</p>
<p>任何授权都是需要用户登录后，只有客户端凭证许可不需要，那隐式许可，是如何和用户关联上的？这里笔者没看明白。</p>
</li>
<li><p>对于授权服务而言，支持隐式类型还要对注册的域名增加跨域支持吧？</p>
<p> 隐式许可类型实际应用在生产环境中的机会非常小了，比如直接嵌入浏览器这样的应用，在我们的实际生产环境中很少。因此，大家的重点不要放在这个授权许可类型上。</p>
</li>
<li><p>如果内网两个服务器需要鉴权通信，就可以使用隐式授权？</p>
<p>隐式许可的特点是  <strong>第三方软件无法对浏览器隐藏任何秘密</strong>，因为第三方软件的任何信息都暴露在了浏览器里面，第三方软件也就没有办法，也无必要再持有秘钥，失去了一层保护，授权服务会直接返回 access_token 给到「嵌入」浏览器中的第三方软件，<strong>但是用户授权的动作还是要有的，用户不授权，授权服务不颁发access_token</strong>，当然这个access_token也暴露在了浏览器下面，所以隐式许安全性低了很多，另外也有它的使用局限性，仅仅在浏览器短暂运行的第三方软件的场景。</p>
<p>内部服务之间的鉴权的时候，【一般】的做法是这样，比如服务 A 调用服务 B，B 要对 A 鉴权，当 A 申请去调用 B 的时候，B 会留下 A 的 app_id，同时会告知一个 token，某种【层度】上跟隐式许可类似，这里没有了秘钥，但隐式许可是需要【用户】这个角色参与的，所以严格上来说不是 OAuth 2.0 里面的隐式许可授权类型。倒是有点像失去了秘钥的客户端凭据许可。</p>
<p>OAuth 2.0 从思想层面来理解是包含了一种授权的思想，可以【简单的理解】就是用令牌代替 <strong>去访问</strong>。</p>
</li>
<li><p>是否每次都需要去获取 token？</p>
<p>token 有有效期，一段时间之内都可以使用。而且可以刷新 token</p>
<p>四种基本授权许可类型中 <strong>隐式许可</strong> 和 <strong>客户端凭据许可</strong> 没有 refresh_token。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>GAS优化（一）</title>
    <url>/2024/07/22/GAS%20%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>![alt text]</p>
]]></content>
      <tags>
        <tag>Excerpt</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/07/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello Worl</title>
    <url>/2024/07/19/hello-worldaaaaaaaaaaaaaaaaaaaaaaa)/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>test01</title>
    <url>/2024/07/11/test01/</url>
    <content><![CDATA[<p>This is test aritcle.</p>
]]></content>
  </entry>
  <entry>
    <title>Solidity 安全：已知攻击方法和常见防御模式综合列表</title>
    <url>/2024/07/19/solidity-security-comprehensive-list-of-known-attack-vectors-and-common-anti-patterns_zh-cn/</url>
    <content><![CDATA[<p>原文链接：<a class="link"   href="https://blog.sigmaprime.io/solidity-security.html" >https://blog.sigmaprime.io/solidity-security.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>译者：爱上平顶山@慢雾安全团队</p>
<p>校对：keywolf@慢雾安全团队</p>
<p>虽然处于起步阶段，但是 Solidity 已被广泛采用，并被用于编译我们今天看到的许多以太坊智能合约中的字节码。相应地，开发者和用户也获得许多严酷的教训，例如发现语言和EVM的细微差别。这篇文章旨在作为一个相对深入和最新的介绍性文章，详述 Solidity 开发人员曾经踩过的坑，避免后续开发者重蹈覆辙。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E">重入漏洞</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90the-dao">真实的例子：The DAO</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E4%B8%8A%E4%B8%8B%E6%BA%A2%E5%87%BA">算法上下溢出</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-1">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-1">预防技术</a></li>
<li><a href="#%E5%AE%9E%E9%99%85%E7%A4%BA%E4%BE%8Bpowhc-%E5%92%8C%E6%89%B9%E9%87%8F%E4%BC%A0%E8%BE%93%E6%BA%A2%E5%87%BAcve-2018-10299">实际示例：PoWHC 和批量传输溢出（CVE-2018-10299）</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8D%E6%9C%9F%E8%80%8C%E8%87%B3%E7%9A%84-ether">不期而至的 Ether</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-2">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-2">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9C%AA%E7%9F%A5">真实世界的例子：未知</a></li>
</ul>
</li>
<li><a href="#delegatecall">Delegatecall</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-3">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-3">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%A4%BA%E4%BE%8Bparity-multisig-walletsecond-hack">真实世界示例：Parity Multisig Wallet（Second Hack）</a></li>
</ul>
</li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%AF%E8%A7%81%E6%80%A7visibility">默认可见性（Visibility）</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-4">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-4">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%A4%BA%E4%BE%8Bparity-multisig-walletfirst-hack">真实世界示例：Parity MultiSig Wallet（First Hack）</a></li>
</ul>
</li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E8%AF%AF%E5%8C%BA">随机数误区</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-5">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-5">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%A4%BA%E4%BE%8Bprng-%E5%90%88%E7%BA%A6">真实世界示例：PRNG 合约</a></li>
</ul>
</li>
<li><a href="#%E5%A4%96%E9%83%A8%E5%90%88%E7%BA%A6%E5%BC%95%E7%94%A8">外部合约引用</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-6">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-6">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90%E5%8F%AF%E9%87%8D%E5%85%A5%E9%92%93%E9%B1%BC%E5%90%88%E7%BA%A6">真实世界的例子：可重入钓鱼合约</a></li>
</ul>
</li>
<li><a href="#%E7%9F%AD%E5%9C%B0%E5%9D%80%E5%8F%82%E6%95%B0%E6%94%BB%E5%87%BB">短地址&#x2F;参数攻击</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-7">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-7">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9C%AA%E7%9F%A5-1">真实世界的例子：未知</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8D%E6%A3%80%E6%9F%A5-call-%E8%BF%94%E5%9B%9E%E5%80%BC">不检查 CALL 返回值</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-8">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-8">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90etherpot-%E5%92%8C-king-of-ether">真实的例子：Etherpot 和 King of Ether</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%8A%A2%E5%85%88%E6%8F%90%E4%BA%A4">条件竞争&#x2F;抢先提交</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-9">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-9">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90erc20-%E5%92%8C-bancor">真实世界的例子：ERC20 和 Bancor</a></li>
</ul>
</li>
<li><a href="#%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1dos">拒绝服务（DOS）</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-10">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-10">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90governmental">真实的例子：GovernMental</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E7%BA%B5%E5%8C%BA%E5%9D%97%E6%97%B6%E9%97%B4%E6%88%B3">操纵区块时间戳</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-11">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-11">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90governmental-1">真实的例子：GovernMental</a></li>
</ul>
</li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A4%B1%E6%8E%A7">构造函数失控</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-12">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-12">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90rubixi">真实世界的例子：Rubixi</a></li>
</ul>
</li>
<li><a href="#%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AD%98%E5%82%A8%E6%8C%87%E9%92%88">未初始化的存储指针</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-13">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-13">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90%E9%92%93%E9%B1%BCopenaddresslottery-%E5%92%8C-cryptoroulette">真实世界的例子：钓鱼：OpenAddressLottery 和 CryptoRoulette</a></li>
</ul>
</li>
<li><a href="#%E6%B5%AE%E7%82%B9%E5%92%8C%E7%B2%BE%E5%BA%A6">浮点和精度</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-14">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-14">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90ethstick">真实世界的例子：Ethstick</a></li>
</ul>
</li>
<li><a href="#txorigin-%E7%94%A8%E4%BD%9C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">Tx.Origin 用作身份验证</a><ul>
<li><a href="#%E6%BC%8F%E6%B4%9E-15">漏洞</a></li>
<li><a href="#%E9%A2%84%E9%98%B2%E6%8A%80%E6%9C%AF-15">预防技术</a></li>
<li><a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9C%AA%E7%9F%A5-2">真实世界的例子：未知</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9C%BA%E5%85%B3">以太坊机关</a><ul>
<li><a href="#%E6%97%A0%E5%AF%86%E9%92%A5%E7%9A%84-ether">无密钥的 ether</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%9C%B0%E5%9D%80">一次性地址</a></li>
</ul>
</li>
<li><a href="#%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3%E7%9A%84hacksbugs%E5%88%97%E8%A1%A8">有趣的加密相关的hacks&#x2F;bugs列表</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
</ul>
<h2 id="重入漏洞"><a href="#重入漏洞" class="headerlink" title="重入漏洞"></a>重入漏洞</h2><p>以太坊智能合约的特点之一是能够调用和利用其他外部合约的代码。合约通常也处理 Ether，因此通常会将 Ether 发送给各种外部用户地址。调用外部合约或将以太网发送到地址的操作需要合约提交外部调用。这些外部调用可能被攻击者劫持，迫使合约执行进一步的代码（即通过回退函数），包括回调自身。因此代码执行“重新进入”合约。这种攻击被用于臭名昭著的 DAO 攻击。</p>
<p>有关重入攻击的进一步阅读，请参阅<a class="link"   href="https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4" >对智能合约的重入式攻击 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和 <a class="link"   href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert" >Consensus - 以太坊智能合约最佳实践 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>当合约将 Ether 发送到未知地址时，可能会发生此攻击。攻击者可以在 <a class="link"   href="https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function" >Fallback 函数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中的外部地址处构建一个包含恶意代码的合约。因此，当合约向此地址发送 Ether 时，它将调用恶意代码。通常，恶意代码会在易受攻击的合约上执行一个函数、该函数会运行一项开发人员不希望的操作。“重入”这个名称来源于外部恶意合约回复了易受攻击合约的功能，并在易受攻击的合约的任意位置“重新输入”了代码执行。</p>
<p>为了澄清这一点，请考虑简单易受伤害的合约，该合约充当以太坊保险库，允许存款人每周只提取 1 个 Ether。</p>
<p>EtherStore.sol：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">    mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    </span><br><span class="line">    function depositFunds() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">        // limit the withdrawal</span><br><span class="line">        require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">        // limit the time allowed to withdraw</span><br><span class="line">        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);</span><br><span class="line">        require(msg.sender.call.value(_weiToWithdraw)());</span><br><span class="line">        balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = now;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>该合约有两个公共职能。 <code>depositFunds()</code> 和 <code>withdrawFunds()</code> 。该 <code>depositFunds()</code> 功能只是增加发件人余额。该 <code>withdrawFunds()</code> 功能允许发件人指定要撤回的 wei 的数量。如果所要求的退出金额小于 1Ether 并且在上周没有发生撤回，它才会成功。额，真会是这样吗？… </p>
<p>该漏洞出现在 [17] 行，我们向用户发送他们所要求的以太数量。考虑一个恶意攻击者创建下列合约，</p>
<p>Attack.sol：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;EtherStore.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">  EtherStore public etherStore;</span><br><span class="line"></span><br><span class="line">  // intialise the etherStore variable with the contract address</span><br><span class="line">  constructor(address _etherStoreAddress) &#123;</span><br><span class="line">      etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function pwnEtherStore() public payable &#123;</span><br><span class="line">      // attack to the nearest ether</span><br><span class="line">      require(msg.value &gt;= 1 ether);</span><br><span class="line">      // send eth to the depositFunds() function</span><br><span class="line">      etherStore.depositFunds.value(1 ether)();</span><br><span class="line">      // start the magic</span><br><span class="line">      etherStore.withdrawFunds(1 ether);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function collectEther() public &#123;</span><br><span class="line">      msg.sender.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // fallback function - where the magic happens</span><br><span class="line">  function () payable &#123;</span><br><span class="line">      if (etherStore.balance &gt; 1 ether) &#123;</span><br><span class="line">          etherStore.withdrawFunds(1 ether);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>让我们看看这个恶意合约是如何利用我们的 <code>EtherStore</code> 合约的。攻击者可以（假定恶意合约地址为 <code>0x0...123</code> ）使用 <code>EtherStore</code> 合约地址作为构造函数参数来创建上述合约。这将初始化并将公共变量 <code>etherStore</code> 指向我们想要攻击的合约。</p>
<p>然后攻击者会调用这个 <code>pwnEtherStore()</code> 函数，并存入一些 Ehter（大于或等于1），比方说 1Ehter，在这个例子中。在这个例子中，我们假设一些其他用户已经将若干 Ehter 存入这份合约中，比方说它的当前余额就是 <code>10 ether</code> 。然后会发生以下情况：</p>
<ol>
<li>Attack.sol -Line [15] -EtherStore合约的 <code>despoitFunds</code> 函数将会被调用，并伴随 1Ether 的 mag.value（和大量的 Gas）。sender(msg.sender) 将是我们的恶意合约 <code>（0x0...123）</code> 。因此， <code>balances[0x0..123] = 1 ether</code> 。</li>
<li>Attack.sol - Line [17] - 恶意合约将使用一个参数来调用合约的 <code>withdrawFunds()</code> 功能。这将通过所有要求（合约的行 [12] - [16] ），因为我们以前没有提款。</li>
<li>EtherStore.sol - 行 [17] - 合约将发送 1Ether 回恶意合约。</li>
<li>Attack.sol - Line [25] - 发送给恶意合约的 Ether 将执行 fallback 函数。</li>
<li>Attack.sol - Line [26] - EtherStore 合约的总余额是 10Ether，现在是 9Ether，如果声明通过。</li>
<li>Attack.sol - Line [27] - 回退函数然后再次动用 EtherStore 中的 <code>withdrawFunds()</code> 函数并“重入” EtherStore合约。</li>
<li>EtherStore.sol - 行 [11] - 在第二次调用 <code>withdrawFunds()</code> 时，我们的余额仍然是 1Ether，因为 行[18] 尚未执行。因此，我们仍然有 <code>balances[0x0..123] = 1 ether</code>。<code>lastWithdrawTime</code> 变量也是这种情况。我们再次通过所有要求。</li>
<li>EtherStore.sol - 行[17] - 我们撤回另外的 1Ether。</li>
<li>步骤4-8将重复 - 直到 <code>EtherStore.balance &gt;= 1</code>，这是由 Attack.sol - Line [26] 所指定的。</li>
<li>Attack.sol - Line [26] - 一旦在 EtherStore 合约中留下少于 1（或更少）的 Ether，此 if 语句将失败。这样 EtherStore 就会执行合约的 行[18]和 行[19]（每次调用 <code>withdrawFunds()</code> 函数之后都会执行这两行）。</li>
<li>EtherStore.sol - 行[18]和[19] -  <code>balances</code> 和 <code>lastWithdrawTime</code> 映射将被设置并且执行将结束。</li>
</ol>
<p>最终的结果是，攻击者只用一笔交易，便立即从 EtherStore 合约中取出了（除去 1 个 Ether 以外）所有的 Ether。</p>
<h3 id="预防技术"><a href="#预防技术" class="headerlink" title="预防技术"></a>预防技术</h3><p>有许多常用技术可以帮助避免智能合约中潜在的重入漏洞。首先是（在可能的情况下）在将 Ether 发送给外部合约时使用内置的 <a class="link"   href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related" >transfer() 函数 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。转账功能只发送 <code>2300 gas</code> 不足以使目的地址&#x2F;合约调用另一份合约（即重入发送合约）。</p>
<p>第二种技术是确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol - 行[18]和行[19] 应放在 行[17] 之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为<a class="link"   href="http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern" >检查效果交互（checks-effects-interactions） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>模式。</p>
<p>第三种技术是引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用。</p>
<p>给 EtherStore.sol 应用所有这些技术（同时使用全部三种技术是没必要的，只是为了演示目的而已）会出现如下的防重入合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line"></span><br><span class="line">    // initialise the mutex</span><br><span class="line">    bool reEntrancyMutex = false;</span><br><span class="line">    uint256 public withdrawalLimit = 1 ether;</span><br><span class="line">    mapping(address =&gt; uint256) public lastWithdrawTime;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    </span><br><span class="line">    function depositFunds() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdrawFunds (uint256 _weiToWithdraw) public &#123;</span><br><span class="line">        require(!reEntrancyMutex);</span><br><span class="line">        require(balances[msg.sender] &gt;= _weiToWithdraw);</span><br><span class="line">        // limit the withdrawal</span><br><span class="line">        require(_weiToWithdraw &lt;= withdrawalLimit);</span><br><span class="line">        // limit the time allowed to withdraw</span><br><span class="line">        require(now &gt;= lastWithdrawTime[msg.sender] + 1 weeks);</span><br><span class="line">        balances[msg.sender] -= _weiToWithdraw;</span><br><span class="line">        lastWithdrawTime[msg.sender] = now;</span><br><span class="line">        // set the reEntrancy mutex before the external call</span><br><span class="line">        reEntrancyMutex = true;</span><br><span class="line">        msg.sender.transfer(_weiToWithdraw);</span><br><span class="line">        // release the mutex after the external call</span><br><span class="line">        reEntrancyMutex = false; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="真实的例子：The-DAO"><a href="#真实的例子：The-DAO" class="headerlink" title="真实的例子：The DAO"></a>真实的例子：The DAO</h3><p><a class="link"   href="https://en.wikipedia.org/wiki/The_DAO_(organization)" >The DAO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（分散式自治组织）是以太坊早期发展的主要黑客之一。当时，该合约持有1.5亿美元以上。重入在这次攻击中发挥了重要作用，最终导致了 Ethereum Classic（ETC）的分叉。有关The DAO 漏洞的详细分析，请参阅 <a class="link"   href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" >Phil Daian 的文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="算法上下溢出"><a href="#算法上下溢出" class="headerlink" title="算法上下溢出"></a>算法上下溢出</h2><p>以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整型变量只能有一定范围的数字表示。例如，一个 <code>uint8</code> ，只能存储在范围 [0,255] 的数字。试图存储 256 到一个 <code>uint8</code> 将变成 0。不加注意的话，只要没有检查用户输入又执行计算，导致数字超出存储它们的数据类型允许的范围，Solidity 中的变量就可以被用来组织攻击。</p>
<p>要进一步阅读算法上下溢出，请参阅<a class="link"   href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" >如何保护您的智能合约 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow" >以太坊智能合约最佳实践 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和<a class="link"   href="https://randomoracle.wordpress.com/2018/04/27/ethereum-solidity-and-integer-overflows-programming-blockchains-like-1970/" >以太坊，Solidity 和整数溢出：像身处1970 年那样为区块链编程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>当执行操作需要固定大小的变量来存储超出变量数据类型范围的数字（或数据）时，会发生数据上溢&#x2F;下溢。</p>
<p>例如，从一个存储 0 的 <code>uint8</code> （无符号的 8 位整数，即只有正数）变量中减去 1，将导致该变量的值变为 255。这是一个下溢。我们明明为该 <code>uint8</code> 分配了一个低于其储存范围的值，结果却是 <em>绕回来</em> 变成了 <code>uint8</code> 所能储存的最大值。同样，给一个 <code>uint8</code> 加上  <code>2^8=256</code> 会使变量保持不变，因为我们已经绕过了 <code>uint</code> 的整个值域又回到原值（对于数学家来说，这类似于将三角函数的角度加上 2pi ，sin(x) &#x3D; sin(x + 2pi)）。添加大于数据类型范围的数字称为上溢。为了清楚起见，添加 257 到一个目前仅有 0 值的 <code>uint8</code> 变量将变成数字 1。将固定类型变量视为循环有时很有启发意义，如果我们加入的数字超出最大可存储数字，等于是从零开始加上超出额，反之也是从零开始（从零中减去一定数额，等同于从最大数字往下减该数额）。</p>
<p>这些类型的漏洞允许攻击者滥用代码并创建意外的逻辑流程。例如，请考虑下面的时间锁定合约。</p>
<p>TimeLock.sol：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TimeLock &#123;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; uint) public lockTime;</span><br><span class="line">    </span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">        lockTime[msg.sender] = now + 1 weeks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function increaseLockTime(uint _secondsToIncrease) public &#123;</span><br><span class="line">        lockTime[msg.sender] += _secondsToIncrease;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0);</span><br><span class="line">        require(now &gt; lockTime[msg.sender]);</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(balances[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这份合约的设计就像是一个时间保险库，用户可以将 Ether 存入合约，并在那里锁定至少一周。如果用户选择的话，用户可以延长超过1周的时间，但是一旦存放，用户可以确信他们的 Ether 会被安全锁定至少一周。有没有别的可能性？…</p>
<p>如果用户被迫交出他们的私钥（考虑绑票的情形），像这样的合约可能很方便，以确保在短时间内无法获得 Ether。但是，如果用户已经锁定了 100Ether 合约并将其密钥交给了攻击者，那么攻击者可以使用溢出来接收 Ether，无视 <code>lockTime</code> 的限制。</p>
<p>攻击者可以确定他们所持密钥的地址的 <code>lockTime</code> （它是一个公共变量）。我们称之为 <code>userLockTime</code> 。然后他们可以调用该 <code>increaseLockTime</code> 函数并将数字 <code>2^256 - userLockTime</code> 作为参数传入。该数字将被添加到当前的 <code>userLockTime</code> 并导致溢出，重置 <code>lockTime[msg.sender]</code> 为0。攻击者然后可以简单地调用 <code>withdraw</code> 函数来获得他们的奖励。</p>
<p>我们来看另一个例子，来自 <a class="link"   href="https://github.com/OpenZeppelin/ethernaut" >Ethernaut Challanges <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的这个例子。</p>
<p>SPOILER ALERT： 如果你还没有完成 Ethernaut 的挑战，这可以解决其中一个难题。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  function Token(uint _initialSupply) &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public constant returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是一个简单的 Token 合约，它使用一个 <code>transfer()</code> 函数，允许参与者转移他们的 Token。你能看出这份合约中的错误吗？</p>
<p>缺陷出现在 <code>transfer()</code> 功能中。行[13]上的 require 语句可以使用下溢来绕过。考虑一个没有余额的用户。他们可以用任何非零值 <code>_value</code> 调用 <code>transfer()</code> 函数，并将 <code>_value</code> 传入 行[13] 上的 require 语句。因为 <code>balances[msg.sender]</code> 为零（也即是 <code>uint256</code> ），减去任何正数（不包括 <code>2^256</code> ）都将导致正数（由于我们上面描述的下溢）。对于 行[14] 也是如此，我们的余额将记入正数。因此，在这个例子中，我们由于下溢漏洞得到了免费的 Token。</p>
<h3 id="预防技术-1"><a href="#预防技术-1" class="headerlink" title="预防技术"></a>预防技术</h3><p>防止溢出漏洞的（当前）常规技术是使用或建立取代标准数学运算符的数学库; 加法，减法和乘法（除法被排除在外，因为它不会导致上溢&#x2F;下溢，并且 EVM 除以 0 时会丢出错误）。</p>
<p><a class="link"   href="https://github.com/OpenZeppelin/zeppelin-solidity" >OppenZepplin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 在构建和审计 Ethereum 社区可以利用的安全库方面做得非常出色。特别是，他们的 <a class="link"   href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" >SafeMath <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个用来避免上溢&#x2F;下溢漏洞的参考或库。</p>
<p>为了演示如何在 Solidity 中使用这些库，让我们使用 Open Zepplin 的 SafeMath 库更正合约 TimeLock。防溢出的合约长这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b); </span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b; </span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TimeLock &#123;</span><br><span class="line">    using SafeMath for uint; // use the library for uint type</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line">    mapping(address =&gt; uint256) public lockTime;</span><br><span class="line">    </span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] = balances[msg.sender].add(msg.value);</span><br><span class="line">        lockTime[msg.sender] = now.add(1 weeks);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function increaseLockTime(uint256 _secondsToIncrease) public &#123;</span><br><span class="line">        lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt; 0);</span><br><span class="line">        require(now &gt; lockTime[msg.sender]);</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(balances[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，所有标准的数学运算已被 SafeMath 库中定义的数学运算所取代。该 TimeLock 合约不会再执行任何能够导致下溢&#x2F;上溢的操作。</p>
<h3 id="实际示例：PoWHC-和批量传输溢出（CVE-2018-10299）"><a href="#实际示例：PoWHC-和批量传输溢出（CVE-2018-10299）" class="headerlink" title="实际示例：PoWHC 和批量传输溢出（CVE-2018-10299）"></a>实际示例：PoWHC 和批量传输溢出（<a class="link"   href="https://nvd.nist.gov/vuln/detail/CVE-2018-10299" >CVE-2018-10299 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</h3><p>一个 4chan 小组认为，用 Solidity 在 Ethereum上 构建一个庞氏骗局是个好主意。他们称它为弱手硬币证明（PoWHC）。不幸的是，似乎合约的作者之前没有看到上溢&#x2F;下溢问题，因此，866Ether 从合约中解放出来。<a class="link"   href="https://blog.goodaudience.com/how-800k-evaporated-from-the-powh-coin-ponzi-scheme-overnight-1b025c33b530" >Eric Banisadar 的文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>对下溢是如何发生的作出了很好的概述（这与上面的 Ethernaut 挑战不太相似）。</p>
<p>一些开发人员还为一些 <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Token 合约实施了一项 <code>batchTransfer()</code> 函数。该实现包含溢出。<a class="link"   href="https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>对此进行了解释，但是我认为标题有误导性，因为它与 ERC20 标准无关，而是一些 ERC20 Token 合约实现了易受攻击的 <code>batchTransfer()</code> 。</p>
<h2 id="不期而至的-Ether"><a href="#不期而至的-Ether" class="headerlink" title="不期而至的 Ether"></a>不期而至的 Ether</h2><p>通常，当 Ether 发送到合约时，它必须执行回退功能或合约中描述的其他功能。这里有两个例外，合约可能会收到了 Ether 但并不会执行任何函数。通过收到以太币来触发代码的合约，对强制将以太币发送到某个合约这类攻击是非常脆弱的。</p>
<p>关于这方面的进一步阅读，请参阅<a class="link"   href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834" >如何保护您的智能合约：6 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html" >Solidity security patterns - forcing ether to a contract <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="漏洞-2"><a href="#漏洞-2" class="headerlink" title="漏洞"></a>漏洞</h3><p>一种常用的防御性编程技术对于执行正确的状态转换或验证操作很有用，它是不变量检查（Invariant-checking）。该技术涉及定义一组不变量（不应改变的度量或参数），并且在单个（或多个）操作之后检查这些不变量保持不变。这基本上是很好的设计，保证受到检查的不变量在实际上保持不变。不变量的一个例子是发行量固定的 <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 代币合约的 <code>totalSupply</code> 。不应该有函数能修改此不变量，因此可以在该 <code>transfer()</code> 函数中添加一个检查以确保 <code>totalSupply</code> 保持未修改状态，确保函数按预期工作。</p>
<p>不管智能合约中规定的规则如何，有一个量，特别容易诱导开发人员将其当作明显的“不变量”来使用，但它在事实上是可以由外部用户来操纵的，那便是合约中存储的 Ether 数量。通常，开发人员刚开始学习 Solidity 时，他们有一种误解，认为合约只能通过 <code>payable</code> 函数接受或获得 Ether。这种误解可能会导致合约对其内部的 ETH 余额有错误的假设，进而导致一系列的漏洞。此漏洞的明显信号是（不正确地）使用 <code>this.balance</code> 。正如我们将看到的，错误地使用 <code>this.balance</code> 会导致这种类型的严重漏洞。</p>
<p>有两种方式可以将 Ether（强制）发送给合约，而无需使用 <code>payable</code> 函数或执行合约中的任何代码。这些在下面列出。</p>
<p><strong>自毁</strong></p>
<p>任何合约都能够实现该 <a href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct"><code>selfdestruct(address)</code></a> 功能，该功能从合约地址中删除所有字节码，并将所有存储在那里的 Ether 发送到参数指定的地址。如果此指定的地址也是合约，则不会调用任何功能（包括故障预置）。因此，使用 <code>selfdestruct()</code> 函数可以无视目标合约中存在的任何代码，强制将 Ether 发送给任一目标合约，包括没有任何可支付函数的合约。这意味着，任何攻击者都可以创建带有 <code>selfdestruct()</code> 函数的合约，向其发送 Ether，调用 <code>selfdestruct(target)</code> 并强制将 Ether 发送至 <code>target</code> 合约。Martin Swende 有一篇出色的<a class="link"   href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html" >博客文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>描述了自毁操作码（Quirk＃2）的一些诡异操作，并描述了客户端节点如何检查不正确的不变量，这可能会导致相当灾难性的客户端问题。</p>
<p><strong>预先发送的 Ether</strong></p>
<p>合约不使用 <code>selfdestruct()</code> 函数或调用任何 payable 函数仍可以接收到 Ether 的第二种方式是把 Ether 预装进合约地址。合约地址是确定性的，实际上地址是根据创建合约的地址及创建合约的交易 Nonce 的哈希值计算得出的，即下述形式： <code>address = sha3(rlp.encode([account_address,transaction_nonce])</code> 请参阅 <a class="link"   href="https://github.com/sigp/solidity-security-blog#keyless-eth" >Keyless Ether <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 在这一点上的一些有趣用例）。这意味着，任何人都可以在创建合约之前计算出合约地址，并将 Ether 发送到该地址。当合约确实创建时，它将具有非零的 Ether 余额。</p>
<p>根据上述知识，我们来探讨一些可能出现的缺陷。<br>考虑过于简单的合约，</p>
<p>EtherGame.sol：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherGame &#123;</span><br><span class="line">    </span><br><span class="line">    uint public payoutMileStone1 = 3 ether;</span><br><span class="line">    uint public mileStone1Reward = 2 ether;</span><br><span class="line">    uint public payoutMileStone2 = 5 ether;</span><br><span class="line">    uint public mileStone2Reward = 3 ether; </span><br><span class="line">    uint public finalMileStone = 10 ether; </span><br><span class="line">    uint public finalReward = 5 ether; </span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; uint) redeemableEther;</span><br><span class="line">    // users pay 0.5 ether. At specific milestones, credit their accounts</span><br><span class="line">    function play() public payable &#123;</span><br><span class="line">        require(msg.value == 0.5 ether); // each play is 0.5 ether</span><br><span class="line">        uint currentBalance = this.balance + msg.value;</span><br><span class="line">        // ensure no players after the game as finished</span><br><span class="line">        require(currentBalance &lt;= finalMileStone);</span><br><span class="line">        // if at a milestone credit the players account</span><br><span class="line">        if (currentBalance == payoutMileStone1) &#123;</span><br><span class="line">            redeemableEther[msg.sender] += mileStone1Reward;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentBalance == payoutMileStone2) &#123;</span><br><span class="line">            redeemableEther[msg.sender] += mileStone2Reward;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentBalance == finalMileStone ) &#123;</span><br><span class="line">            redeemableEther[msg.sender] += finalReward;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        // ensure the game is complete</span><br><span class="line">        require(this.balance == finalMileStone);</span><br><span class="line">        // ensure there is a reward to give</span><br><span class="line">        require(redeemableEther[msg.sender] &gt; 0); </span><br><span class="line">        redeemableEther[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(redeemableEther[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure></div>

<p>这个合约代表一个简单的游戏（自然会引起<a href="#%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E9%9D%9E%E6%B3%95%E9%A2%84%E5%85%88%E4%BA%A4%E6%98%93">条件竞争（Race-conditions）</a>），玩家可以将 <code>0.5 ether</code> 发送给合约，希望成为第一个达到三个里程碑之一的玩家。里程碑以 Ether 计价。当游戏结束时，第一个达到里程碑的人可以获得合约的部分 Ether。当达到最后的里程碑（10 Ether）时，游戏结束，用户可以申请奖励。</p>
<p>EtherGame 合约的问题出自在 [14] 行（以及相关的 [16] 行）和 [32] 行中对 <code>this.balance</code> 的错误使用。一个调皮的攻击者可以通过（上面讨论过的） <code>selfdestruct()</code> 函数强行发送少量的以太，比如 <code>0.1 ether</code>，以防止未来的玩家达到一个里程碑。由于所有合法玩家只能发送 <code>0.5 ether</code> 增量，而合约收到了 <code>0.1 ether</code> ，合约的 <code>this.balance</code> 不再是半个整数。这会阻止 [18]、[21]和[24] 行的所有条件成立。</p>
<p>更糟糕的是，一个因错过了里程碑而复仇心切的攻击者可能会强行发送 <code>10 ether</code> （或者会将合约的余额推到高出 <code>finalMileStone</code> 的数量），这将永久锁定合约中的所有奖励。这是因为 <code>claimReward()</code> 函数总是会回弹，因为 [32] 行中的要求（即 <code>this.balance</code> 大于 <code>finalMileStone</code> ）。</p>
<h3 id="预防技术-2"><a href="#预防技术-2" class="headerlink" title="预防技术"></a>预防技术</h3><p>这个漏洞通常是由于错误运用 <code>this.balance</code> 而产生的。如果可能，合约逻辑应该避免依赖于合约余额的确切值，因为它可以被人为地操纵。如果应用基于 <code>this.balance</code> 函数的逻辑语句，请确保考虑到了飞来横 Ether。</p>
<p>如果需要存储 Ether 的确定值，则应使用自定义变量来获得通过可支付函数获得的增量，以安全地追踪储存 Ether 的值。这个变量不应受到通过调用 <code>selfdestruct()</code> 强制发送的 Ether 的影响。</p>
<p>考虑到这一点，修正后的EtherGame合约版本可能如下所示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherGame &#123;</span><br><span class="line">    </span><br><span class="line">    uint public payoutMileStone1 = 3 ether;</span><br><span class="line">    uint public mileStone1Reward = 2 ether;</span><br><span class="line">    uint public payoutMileStone2 = 5 ether;</span><br><span class="line">    uint public mileStone2Reward = 3 ether; </span><br><span class="line">    uint public finalMileStone = 10 ether; </span><br><span class="line">    uint public finalReward = 5 ether; </span><br><span class="line">    uint public depositedWei;</span><br><span class="line">    </span><br><span class="line">    mapping (address =&gt; uint) redeemableEther;</span><br><span class="line">    </span><br><span class="line">    function play() public payable &#123;</span><br><span class="line">        require(msg.value == 0.5 ether);</span><br><span class="line">        uint currentBalance = depositedWei + msg.value;</span><br><span class="line">        // ensure no players after the game as finished</span><br><span class="line">        require(currentBalance &lt;= finalMileStone);</span><br><span class="line">        if (currentBalance == payoutMileStone1) &#123;</span><br><span class="line">            redeemableEther[msg.sender] += mileStone1Reward;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentBalance == payoutMileStone2) &#123;</span><br><span class="line">            redeemableEther[msg.sender] += mileStone2Reward;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentBalance == finalMileStone ) &#123;</span><br><span class="line">            redeemableEther[msg.sender] += finalReward;</span><br><span class="line">        &#125;</span><br><span class="line">        depositedWei += msg.value;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function claimReward() public &#123;</span><br><span class="line">        // ensure the game is complete</span><br><span class="line">        require(depositedWei == finalMileStone);</span><br><span class="line">        // ensure there is a reward to give</span><br><span class="line">        require(redeemableEther[msg.sender] &gt; 0); </span><br><span class="line">        redeemableEther[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(redeemableEther[msg.sender]);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure></div>

<p>在这里，我们刚刚创建了一个新变量， <code>depositedEther</code>，它跟踪已知的 Ether 存储量，并且这也是我们执行需求和测试时用到的变量。请注意，我们不再参考 <code>this.balance</code>。</p>
<h3 id="真实世界的例子：未知"><a href="#真实世界的例子：未知" class="headerlink" title="真实世界的例子：未知"></a>真实世界的例子：未知</h3><p>我还没有找到该漏洞在真实世界中被利用的例子。然而，在 <a class="link"   href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/" >Underhanded Solidity 竞赛 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中出现了一些可利用该漏洞的合约的例子。</p>
<h2 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h2><p> <code>CALL</code> 与 <code>DELEGATECALL</code> 操作码是非常有用的，它们让 Ethereum 开发者将他们的代码模块化（Modularise）。用 <code>CALL</code> 操作码来处理对合约的外部标准信息调用（Standard Message Call）时，代码在外部合约&#x2F;功能的环境中运行。 <code>DELEGATECALL</code> 操作码也是标准消息调用，但在目标地址中的代码会在调用合约的环境下运行，也就是说，保持 <code>msg.sender</code> 和 <code>msg.value</code> 不变。该功能支持实现库，开发人员可以为未来的合约创建可重用的代码。 </p>
<p>虽然这两个操作码之间的区别很简单直观，但是使用 <code>DELEGATECALL</code> 可能会导致意外的代码执行。</p>
<p>有关进一步阅读，请参阅 <a class="link"   href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall" >Stake Exchange上关于以太坊的这篇提问 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" >Solidity 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以及<a class="link"   href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" >如何保护您的智能合约：6 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-3"><a href="#漏洞-3" class="headerlink" title="漏洞"></a>漏洞</h3><p> <code>DELEGATECALL</code> 会保持调用环境不变的属性表明，构建无漏洞的定制库并不像人们想象的那么容易。库中的代码本身可以是安全的，无漏洞的，但是当在另一个应用的环境中运行时，可能会出现新的漏洞。让我们看一个相当复杂的例子，使用斐波那契数字。</p>
<p>考虑下面的可以生成斐波那契数列和相似形式序列的库：FibonacciLib.sol<a href="%E6%AD%A4%E4%BB%A3%E7%A0%81%E5%B7%B2%E4%BB%8Eweb3j%E4%BF%AE%E6%94%B9%E8%BF%87">^ 1</a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// library contract - calculates fibonacci-like numbers;</span><br><span class="line">contract FibonacciLib &#123;</span><br><span class="line">    // initializing the standard fibonacci sequence;</span><br><span class="line">    uint public start;</span><br><span class="line">    uint public calculatedFibNumber;</span><br><span class="line"></span><br><span class="line">    // modify the zeroth number in the sequence</span><br><span class="line">    function setStart(uint _start) public &#123;</span><br><span class="line">        start = _start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFibonacci(uint n) public &#123;</span><br><span class="line">        calculatedFibNumber = fibonacci(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fibonacci(uint n) internal returns (uint) &#123;</span><br><span class="line">        if (n == 0) return start;</span><br><span class="line">        else if (n == 1) return start + 1;</span><br><span class="line">        else return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该库提供了一个函数，可以在序列中生成第 n 个斐波那契数。它允许用户更改第 0 个 <code>start</code> 数字并计算这个新序列中的第 n 个斐波那契数字。</p>
<p>现在我们来考虑一个利用这个库的合约。</p>
<p>FibonacciBalance.sol：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FibonacciBalance &#123;</span><br><span class="line"></span><br><span class="line">    address public fibonacciLibrary;</span><br><span class="line">    // the current fibonacci number to withdraw</span><br><span class="line">    uint public calculatedFibNumber;</span><br><span class="line">    // the starting fibonacci sequence number</span><br><span class="line">    uint public start = 3;    </span><br><span class="line">    uint public withdrawalCounter;</span><br><span class="line">    // the fibonancci function selector</span><br><span class="line">    bytes4 constant fibSig = bytes4(sha3(&quot;setFibonacci(uint256)&quot;));</span><br><span class="line">    </span><br><span class="line">    // constructor - loads the contract with ether</span><br><span class="line">    constructor(address _fibonacciLibrary) public payable &#123;</span><br><span class="line">        fibonacciLibrary = _fibonacciLibrary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() &#123;</span><br><span class="line">        withdrawalCounter += 1;</span><br><span class="line">        // calculate the fibonacci number for the current withdrawal user</span><br><span class="line">        // this sets calculatedFibNumber</span><br><span class="line">        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));</span><br><span class="line">        msg.sender.transfer(calculatedFibNumber * 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // allow users to call fibonacci library functions</span><br><span class="line">    function() public &#123;</span><br><span class="line">        require(fibonacciLibrary.delegatecall(msg.data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该合约允许参与者从合约中提取 ether，金额等于参与者提款订单对应的斐波纳契数字；即第一个参与者获得 1 ether，第二个参与者获得 1，第三个获得 2，第四个获得 3，第五个获得 5 等等（直到合约的余额小于被取出的斐波纳契数）。</p>
<p>本合约中的许多要素可能需要一些解释。首先，有一个看起来很有趣的变量， <code>fibSig</code>。这包含字符串“fibonacci（uint256）”的 Keccak（SHA-3） 哈希值的前4个字节。这被称为<a class="link"   href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector" >函数选择器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，它被放入 <code>calldata</code> 中以指定调用智能合约的哪个函数。在 [21] 行的 <code>delegatecall</code> 函数中，它被用来指出：我们希望运行 <code>fibonacci(uint256)</code> 函数。 <code>delegatecall</code> 的第二个参数是我们传递给函数的参数。其次，我们假设 FibonacciLib 库的地址在构造函数中正确引用（<a class="link"   href="https://github.com/sigp/solidity-security-blog#deployment" >部署攻击向量 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>部分会讨论与合约参考初始化相关的潜在漏洞）。</p>
<p>你能发现这份合约中的错误吗？如果你把它放到 Remix 里面编译，存入 Ether 并调用 <code>withdraw()</code> ，它可能会回滚状态。（Revert）</p>
<p>您可能已经注意到，在库和主调用合约中都使用了状态变量 <code>start</code>。在库合约中， <code>start</code> 用于指定斐波纳契数列的起点，它被设置为 0，而 FibonacciBalance 合约中它被设置为 3。你可能还注意到，FibonacciBalance 合约中的回退函数允许将所有调用传递给库合约，因此也允许调用库合约的 <code>setStart()</code> 函数。回想一下，我们会保留合约状态，那么看起来你就可以据此改变本地 FibonnacciBalance 合约中 <code>start</code> 变量的状态。如果是这样，一个用户可以取出更多的 Ether，因为最终的 <code>calculatedFibNumber</code> 依赖于 <code>start</code> 变量（如库合约中所见）。实际上，该 <code>setStart()</code> 函数不会（也不能）修改 FibonacciBalance 合约中的 <code>start</code> 变量。这个合约中的潜在弱点比仅仅修改 <code>start</code> 变量要糟糕得多。</p>
<p>在讨论实际问题之前，我们先快速绕道了解状态变量（ <code>storage</code> 变量）实际上是如何存储在合约中的。状态或 <code>storage</code> 变量（贯穿单个交易、始终都存在的变量）在合约中引入时，是按顺序放置在 <code>slots</code> 中的。（这里有一些复杂的东西，我鼓励读者阅读<a class="link"   href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage" >存储中状态变量的布局 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以便更透彻地理解）。</p>
<p>作为一个例子，让我们看看库合约。它有两个状态变量， <code>start</code> 和 <code>calculatedFibNumber</code>。第一个变量是 <code>start</code> ，因此它被存储在合约的存储位置 <code>slot[0]</code> （即第一个 slot）。第二个变量 <code>calculatedFibNumber</code> 放在下一个可用的存储位置中，也就是 <code>slot[1]</code> 。如果我们看看 <code>setStart()</code> 这个函数，它可以接收一个输入并依据输入来设置 <code>start</code>。因此， <code>setStart()</code> 函数可以将 <code>slot[0]</code> 设置为我们在该函数中提供的任何输入。同样， <code>setFibonacci()</code> 函数也可以将 <code>calculatedFibNumber</code> 设置为 <code>fibonacci(n)</code> 的结果。再说一遍，这只是将存储位置 <code>slot[1]</code> 设置为 <code>fibonacci(n)</code> 的值。</p>
<p>现在让我们看看 FibonacciBalance 合约。存储位置 <code>slot[0]</code> 现在对应于 fibonacciLibrary 的地址， <code>slot[1]</code> 对应于 <code>calculatedFibNumber</code> 。这就是漏洞所在。 <code>delegatecall</code> 会保留合约环境。这意味着通过 <code>delegatecall</code> 执行的代码将作用于调用合约的状态（即存储）。</p>
<p>现在，请注意在 [21] 行上的 <code>withdraw()</code>， <code>fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)</code> 。这会调用 <code>setFibonacci()</code> ，正如我们讨论的那样，会修改存储位置 <code>slot[1]</code> ，在我们当前的环境中就是 <code>calculatedFibNumber</code> 。我们预期是这样的（即执行后， <code>calculatedFibNumber</code> 会得到调整）。但是，请记住，FibonacciLib 合约中，位于存储位置 <code>slot[0]</code> 中的是 <code>start</code> 变量，而在当前（FibonacciBalance）合约中就是 fibonacciLibrary 的地址。这意味着 <code>fibonacci()</code> 函数会带来意想不到的结果。这是因为它引用 <code>start</code> （ <code>slot[0]</code> ），而该位置在当前调用环境中是 fibonacciLibrary 的地址（如果用 <code>uint</code> 来表达的话，该值会非常大）。因此，调用 <code>withdraw()</code> 函数很可能会导致状态回滚（Revert），因为 <code>calcultedFibNumber</code> 会返回  <code>uint(fibonacciLibrary)</code>，而合约却没有那么多数量的 Ether。</p>
<p>更糟糕的是，FibonacciBalance 合约允许用户通过 [26] 行上的回退（Fallback）函数调用 fibonacciLibrary 的所有函数。正如我们前面所讨论的那样，这包括 <code>setStart()</code> 函数。我们讨论过这个功能允许任何人修改或设置 <code>slot[0]</code> 的值。在当前合约中，存储位置 <code>slot[0]</code> 是 fibonacciLibrary 地址。因此，攻击者可以创建一个恶意合约（下面是一个例子），将恶意合约地址转换为一个 <code>uint</code> 数据（在 python 中可以使用 <code>int(&#39;&lt;address&gt;&#39;,16)</code> 轻松完成），然后调用 <code>setStart(&lt;attack_contract_address_as_uint&gt;)</code> ，这会将 <code>fibonacciLibrary</code> 转变为攻击合约的地址。然后，无论何时用户调用 <code>withdraw()</code> 或回退函数，恶意合约都会运行（它可以窃取合约的全部余额），因为我们修改了 <code>fibonacciLibrary</code> 指向的实际地址。这种攻击合约的一个例子是，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    uint storageSlot0; // corresponds to fibonacciLibrary</span><br><span class="line">    uint storageSlot1; // corresponds to calculatedFibNumber</span><br><span class="line">   </span><br><span class="line">    // fallback - this will run if a specified function is not found</span><br><span class="line">    function() public &#123;</span><br><span class="line">        storageSlot1 = 0; // we set calculatedFibNumber to 0, so that if withdraw</span><br><span class="line">        // is called we don&#x27;t send out any ether. </span><br><span class="line">        &lt;attacker_address&gt;.transfer(this.balance); // we take all the ether</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，此攻击合约可以通过更改存储位置 <code>slot[1]</code> 来修改 <code>calculatedFibNumber</code> 。原则上，攻击者可以修改他们选择的任何其他存储位置来对本合约执行各种攻击。我鼓励所有读者将这些合约放入 <a class="link"   href="https://remix.ethereum.org/" >Remix <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，并通过这些 <code>delegatecall</code> 函数尝试不同的攻击合约和状态更改。</p>
<p>同样重要的是要注意，当我们说 <code>delegatecall</code> 会保留状态，我们说的并不是合约中不同名称下的变量，而是这些名称指向的实际存储位置。从这个例子中可以看出，一个简单的错误，可能导致攻击者劫持整个合约及其 Ether。</p>
<h3 id="预防技术-3"><a href="#预防技术-3" class="headerlink" title="预防技术"></a>预防技术</h3><p>Solidity 为实现库合约提供了关键字 <code>library</code> （参见 <a class="link"   href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#libraries" >Solidity Docs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 了解更多详情)。这确保了库合约是无状态（Stateless）且不可自毁的。强制让 library 成为无状态的，可以缓解本节所述的存储环境的复杂性。无状态库也可以防止攻击者直接修改库状态的攻击，以实现依赖库代码的合约。作为一般的经验法则，在使用时 <code>DELEGATECALL</code> 时要特别注意库合约和调用合约的可能调用上下文，并且尽可能构建无状态库。</p>
<h3 id="真实世界示例：Parity-Multisig-Wallet（Second-Hack）"><a href="#真实世界示例：Parity-Multisig-Wallet（Second-Hack）" class="headerlink" title="真实世界示例：Parity Multisig Wallet（Second Hack）"></a>真实世界示例：Parity Multisig Wallet（Second Hack）</h3><p>Parity 多签名钱包第二次被黑事件是一个例子，说明了如果在非预期的环境中运行，良好的库代码也可以被利用。关于这次被黑事件，有很多很好的解释，比如这个概述：Anthony Akentiev 写的 <a class="link"   href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838" >再一次解释 Parity 多签名钱包被黑事件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这个<a class="link"   href="https://ethereum.stackexchange.com/questions/30128/explanation-of-parity-library-suicide/30130" >stack exchange 上的问答 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和<a class="link"   href="http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/" >深入了解Parity Multisig Bug <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>要深入理解这些参考资料，我们要探究一下被攻击的合约。受攻击的库合约和钱包合约可以在 <a class="link"   href="https://github.com/paritytech/parity/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol" >Parity 的 github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上找到。</p>
<p>我们来看看这个合约的相关方面。这里有两个包含利益的合约，库合约和钱包合约。</p>
<p>先看 library 合约， </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract WalletLibrary is WalletEvents &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // throw unless the contract is not yet initialized.</span><br><span class="line">  modifier only_uninitialized &#123; if (m_numOwners &gt; 0) throw; _; &#125;</span><br><span class="line"></span><br><span class="line">  // constructor - just pass on the owner array to the multiowned and</span><br><span class="line">  // the limit to daylimit</span><br><span class="line">  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized &#123;</span><br><span class="line">    initDaylimit(_daylimit);</span><br><span class="line">    initMultiowned(_owners, _required);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // kills the contract sending everything to  ` _to ` .</span><br><span class="line">  function kill(address _to) onlymanyowners(sha3(msg.data)) external &#123;</span><br><span class="line">    suicide(_to);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再看钱包合约，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Wallet is WalletEvents &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // METHODS</span><br><span class="line"></span><br><span class="line">  // gets called when no other function matches</span><br><span class="line">  function() payable &#123;</span><br><span class="line">    // just being sent some cash?</span><br><span class="line">    if (msg.value &gt; 0)</span><br><span class="line">      Deposit(msg.sender, msg.value);</span><br><span class="line">    else if (msg.data.length &gt; 0)</span><br><span class="line">      _walletLibrary.delegatecall(msg.data);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...  </span><br><span class="line"></span><br><span class="line">  // FIELDS</span><br><span class="line">  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，Wallet 合约基本上会通过 delegate call 将所有调用传递给 WalletLibrary。此代码段中的常量地址 <code>_walletLibrary</code>，即是实际部署的 WalletLibrary 合约的占位符（位于 <code>0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4</code> ）。</p>
<p>这些合约的预期运作是生成一个简单的可低成本部署的 Wallet 合约，合约的代码基础和主要功能都在 WalletLibrary 合约中。不幸的是，WalletLibrary 合约本身就是一个合约，并保持它自己的状态。你能能不能看出为什么这会是一个问题？</p>
<p>因为有可能向 WalletLibrary 合约本身发送调用请求。具体来说，WalletLibrary 合约可以初始化，并被用户拥有。一个用户通过调用 WalletLibrary 中的 <code>initWallet()</code> 函数，成为了 Library 合约的所有者。同一个用户，随后调用 <code>kill()</code> 功能。因为用户是 Library 合约的所有者，所以修改传入、Library 合约自毁。因为所有现存的 Wallet 合约都引用该 Library 合约，并且不包含更改引用的方法，因此其所有功能（包括取回 Ether 的功能）都会随 WalletLibrary 合约一起丢失。更直接地说，这种类型的 Parity 多签名钱包中的所有以太都会立即丢失或者说永久不可恢复。</p>
<h2 id="默认可见性（Visibility）"><a href="#默认可见性（Visibility）" class="headerlink" title="默认可见性（Visibility）"></a>默认可见性（Visibility）</h2><p>Solidity 中的函数具有可见性说明符，它们会指定我们可以如何调用函数。可见性决定一个函数是否可以由用户或其他派生契约在外部调用、只允许内部调用或只允许外部调用。有四个可见性说明符，详情请参阅 <a class="link"   href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters" >Solidity 文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。为允许用户从外部调用函数，函数的可见性默认为 <code>public</code>。正如本节将要讨论的，可见性说明符的不正确使用可能会导致智能合约中的一些资金流失。</p>
<h3 id="漏洞-4"><a href="#漏洞-4" class="headerlink" title="漏洞"></a>漏洞</h3><p>函数的可见性默认是 <code>public</code>。因此，不指定任何可见性的函数就可以由用户在外部调用。当开发人员错误地忽略应该是私有的功能（或只能在合约本身内调用）的可见性说明符时，问题就出现了。<br>让我们快速浏览一个简单的例子。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract HashForEther &#123;</span><br><span class="line">    </span><br><span class="line">    function withdrawWinnings() &#123;</span><br><span class="line">        // Winner if the last 8 hex characters of the address are 0. </span><br><span class="line">        require(uint32(msg.sender) == 0);</span><br><span class="line">        _sendWinnings();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     function _sendWinnings() &#123;</span><br><span class="line">         msg.sender.transfer(this.balance);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个简单的合约被设计为充当赏金猜测游戏的地址。要赢得该合约的余额，用户必须生成一个以太坊地址，其最后 8 个十六进制字符为0。一旦获得，他们可以调用 <code>WithdrawWinnings()</code> 函数来获得赏金。<br>不幸的是，这些功能的可见性没有得到指定。特别是，因为 <code>_sendWinnings()</code> 函数的可见性是 <code>public</code>，任何地址都可以调用该函数来窃取赏金。</p>
<h3 id="预防技术-4"><a href="#预防技术-4" class="headerlink" title="预防技术"></a>预防技术</h3><p>总是指定合约中所有功能的可见性、即便这些函数的可见性本就有意设计成 <code>public</code>，这是一种很好的做法。最近版本的 Solidity 将在编译过程中为没有明确设置可见性的函数显示警告，以鼓励这种做法。</p>
<h3 id="真实世界示例：Parity-MultiSig-Wallet（First-Hack）"><a href="#真实世界示例：Parity-MultiSig-Wallet（First-Hack）" class="headerlink" title="真实世界示例：Parity MultiSig Wallet（First Hack）"></a>真实世界示例：Parity MultiSig Wallet（First Hack）</h3><p>在 Parity 多签名钱包遭受的第一次黑客攻击中，约值 3100 万美元的 Ether 被盗，主要是三个钱包。Haseeb Qureshi 在<a class="link"   href="https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中给出了一个很好的回顾。</p>
<p>实质上，这些多签名钱包（可以在<a class="link"   href="https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>找到）是从一个基础的 <code>Wallet</code> 合约构建出来的，该基础合约调用包含核心功能的库合约（如<a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%A4%BA%E4%BE%8Bparity-multisig-walletsecond-hack">真实世界中的例子：Parity Multisig（Second Hack）</a>中所述)。库合约包含初始化钱包的代码，如以下代码片段所示</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract WalletLibrary is WalletEvents &#123;</span><br><span class="line">  </span><br><span class="line">  ... </span><br><span class="line">  </span><br><span class="line">  // METHODS</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // constructor is given number of sigs required to do protected &quot;onlymanyowners&quot; transactions</span><br><span class="line">  // as well as the selection of addresses capable of confirming them.</span><br><span class="line">  function initMultiowned(address[] _owners, uint _required) &#123;</span><br><span class="line">    m_numOwners = _owners.length + 1;</span><br><span class="line">    m_owners[1] = uint(msg.sender);</span><br><span class="line">    m_ownerIndex[uint(msg.sender)] = 1;</span><br><span class="line">    for (uint i = 0; i &lt; _owners.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      m_owners[2 + i] = uint(_owners[i]);</span><br><span class="line">      m_ownerIndex[uint(_owners[i])] = 2 + i;</span><br><span class="line">    &#125;</span><br><span class="line">    m_required = _required;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // constructor - just pass on the owner array to the multiowned and</span><br><span class="line">  // the limit to daylimit</span><br><span class="line">  function initWallet(address[] _owners, uint _required, uint _daylimit) &#123;</span><br><span class="line">    initDaylimit(_daylimit);</span><br><span class="line">    initMultiowned(_owners, _required);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，这两个函数都没有明确指定可见性。两个函数的可见性都默认为 <code>public</code> 。钱包构造函数会调用 <code>initWallet()</code> 函数，并设置多签名钱包的所有者，如 <code>initMultiowned()</code> 函数中所示。由于这些函数意外地设置为 <code>public</code>，攻击者可以在部署的合约上调用这些功能，并将所有权重置为攻击者地址。作为主人，袭击者随后取走钱包中所有的 Ether，损失高达 3100 万美元。</p>
<h2 id="随机数误区"><a href="#随机数误区" class="headerlink" title="随机数误区"></a>随机数误区</h2><p>以太坊区块链上的所有交易都是确定性的状态转换操作。这意味着每笔交易都会改变以太坊生态系统的全球状态，并且它以可计算的方式进行，没有不确定性。这最终意味着在区块链生态系统内不存在熵或随机性的来源。Solidity 中没有 <code>rand()</code> 功能。实现区中心化的熵源（随机性）是一个由来已久的问题，人们提出了很多想法来解决这个问题（例如，<a class="link"   href="https://github.com/randao/randao" >RanDAO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，或是如 Vitalik 在<a class="link"   href="https://vitalik.ca/files/randomness.html" >这篇帖子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中说的那样，使用哈希链）。</p>
<h3 id="漏洞-5"><a href="#漏洞-5" class="headerlink" title="漏洞"></a>漏洞</h3><p>以太坊平台上建立的首批合约中，有一些是围绕博彩的。从根本上讲，博彩需要不确定性（可以下注），这使得在区块链（一个确定性系统）上构建博彩系统变得相当困难。很明显，不确定性只能来自于区块链外部的来源。朋友之间怡情还是可以的（例如参见<a class="link"   href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" >承诺揭示技术 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），然而，要让合约成为<strong>赌场</strong>（比如玩 21 点或是轮盘赌），则困难得多。一个常见的误区是使用未来的块变量，如区块哈希值，时间戳，区块高低或是 Gas 上限。与这些设计有关的问题是，这些量都是由挖矿的矿工控制的，因此并不是真正随机的。例如，考虑一个轮盘赌智能合约，其逻辑是如果下一个块哈希值以偶数结尾，则返回一个黑色数字。一个矿工（或矿池）可以在黑色上下注 100 万美元。如果他们挖出下一个块并发现块哈希值以奇数结尾，他们会高兴地不发布他们的块、继续挖矿、直到他们挖出一个块哈希值为偶数的块（假设区块奖励和费用低于 100 万美元）。Martin Swende 在其优秀的<a class="link"   href="http://martin.swende.se/blog/Breaking_the_house.html" >博客文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中指出，使用过去或现在的区块变量可能会更具破坏性。此外，仅使用块变量意味着伪随机数对于一个块中的所有交易都是相同的，所以攻击者可以通过在一个块内进行多次交易来使收益倍增（如果赌注有上限的话）。</p>
<h3 id="预防技术-5"><a href="#预防技术-5" class="headerlink" title="预防技术"></a>预防技术</h3><p>熵（随机性）的来源只能在区块链之外。在熟人之间，这可以通过使用诸如 <a class="link"   href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" >commit-reveal <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>之类的系统来解决，或通过将信任模型更改为一组参与者（例如 <a class="link"   href="https://github.com/randao/randao" >RanDAO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。这也可以通过一个中心化的实体来完成，这个实体充当一个随机性的预言机（Oracle）。区块变量（一般来说，有一些例外）不应该被用来提供熵，因为它们可以被矿工操纵。</p>
<h3 id="真实世界示例：PRNG-合约"><a href="#真实世界示例：PRNG-合约" class="headerlink" title="真实世界示例：PRNG 合约"></a>真实世界示例：PRNG 合约</h3><p>Arseny Reutov 分析了 3649 份使用某种伪随机数发生器（PRNG）的已上线智能合约，在发现 43 份可被利用的合约之后写了一篇<a class="link"   href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" >博文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。该文详细讨论了使用区块变量作为熵源的缺陷。</p>
<h2 id="外部合约引用"><a href="#外部合约引用" class="headerlink" title="外部合约引用"></a>外部合约引用</h2><p>以太坊全球计算机的好处之一是能够重复使用代码、与已部署在网络上的合约进行交互。因此，大量合约引用外部合约，并且在一般运营中使用外部消息调用（External Message Call）来与这些合约交互。恶意行为者的意图可以隐藏在这些不起眼的外部消息调用之下，下面我们就来探讨这些瞒天过海的方法。</p>
<h3 id="漏洞-6"><a href="#漏洞-6" class="headerlink" title="漏洞"></a>漏洞</h3><p>在 Solidity 中，任何地址都可以被当作合约，无论地址上的代码是否表示需要用到合约类型。这可能是骗人的，特别是当合约的作者试图隐藏恶意代码时。让我们以一个例子来说明这一点：</p>
<p>考虑一段代码，它初步地实现了 <a class="link"   href="https://blog.sigmaprime.io/www.wikipedia.com/rot13" >Rot13 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 密码。</p>
<p> <code>Rot13Encryption.sol</code> ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//encryption contract</span><br><span class="line">contract Rot13Encryption &#123;</span><br><span class="line">     </span><br><span class="line">   event Result(string convertedString);</span><br><span class="line">   </span><br><span class="line">    //rot13 encrypt a string</span><br><span class="line">    function rot13Encrypt (string text) public &#123;</span><br><span class="line">        uint256 length = bytes(text).length;</span><br><span class="line">        for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            byte char = bytes(text)[i];</span><br><span class="line">            //inline assembly to modify the string</span><br><span class="line">            assembly &#123;</span><br><span class="line">                char := byte(0,char) // get the first byte</span><br><span class="line">                if and(gt(char,0x6D), lt(char,0x7B)) // if the character is in [n,z], i.e. wrapping. </span><br><span class="line">                &#123; char:= sub(0x60, sub(0x7A,char)) &#125; // subtract from the ascii number a by the difference char is from z. </span><br><span class="line">                if iszero(eq(char, 0x20)) // ignore spaces</span><br><span class="line">                &#123;mstore8(add(add(text,0x20), mul(i,1)), add(char,13))&#125; // add 13 to char. </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Result(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // rot13 decrypt a string</span><br><span class="line">    function rot13Decrypt (string text) public &#123;</span><br><span class="line">        uint256 length = bytes(text).length;</span><br><span class="line">        for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            byte char = bytes(text)[i];</span><br><span class="line">            assembly &#123;</span><br><span class="line">                char := byte(0,char)</span><br><span class="line">                if and(gt(char,0x60), lt(char,0x6E))</span><br><span class="line">                &#123; char:= add(0x7B, sub(char,0x61)) &#125;</span><br><span class="line">                if iszero(eq(char, 0x20))</span><br><span class="line">                &#123;mstore8(add(add(text,0x20), mul(i,1)), sub(char,13))&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Result(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>得到一串字符（字母 a-z，没有验证）之后，上述代码通过将每个字符向右移动 13 个位置（围绕 ‘z’）来加密该字符串；即 ‘a’ 转换为 ‘n’，’x’ 转换为 ‘k’。这里的集合并不重要，所以如果在这个阶段看不出问题，不必焦躁。</p>
<p>考虑以下使用此代码进行加密的合约，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Rot13Encryption.sol&quot;;</span><br><span class="line"></span><br><span class="line">// encrypt your top secret info</span><br><span class="line">contract EncryptionContract &#123;</span><br><span class="line">    // library for encryption</span><br><span class="line">    Rot13Encryption encryptionLibrary;</span><br><span class="line">        </span><br><span class="line">    // constructor - initialise the library</span><br><span class="line">    constructor(Rot13Encryption _encryptionLibrary) &#123;</span><br><span class="line">        encryptionLibrary = _encryptionLibrary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function encryptPrivateData(string privateInfo) &#123;</span><br><span class="line">        // potentially do some operations here</span><br><span class="line">        encryptionLibrary.rot13Encrypt(privateInfo);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>这个合约的问题是， <code>encryptionLibrary</code> 地址并不是公开的或保证不变的。因此，合约的配置人员可以在指向该合约的构造函数中给出一个地址：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//encryption contract</span><br><span class="line">contract Rot26Encryption &#123;</span><br><span class="line">     </span><br><span class="line">   event Result(string convertedString);</span><br><span class="line">   </span><br><span class="line">    //rot13 encrypt a string</span><br><span class="line">    function rot13Encrypt (string text) public &#123;</span><br><span class="line">        uint256 length = bytes(text).length;</span><br><span class="line">        for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            byte char = bytes(text)[i];</span><br><span class="line">            //inline assembly to modify the string</span><br><span class="line">            assembly &#123;</span><br><span class="line">                char := byte(0,char) // get the first byte</span><br><span class="line">                if and(gt(char,0x6D), lt(char,0x7B)) // if the character is in [n,z], i.e. wrapping. </span><br><span class="line">                &#123; char:= sub(0x60, sub(0x7A,char)) &#125; // subtract from the ascii number a by the difference char is from z. </span><br><span class="line">                if iszero(eq(char, 0x20)) // ignore spaces</span><br><span class="line">                &#123;mstore8(add(add(text,0x20), mul(i,1)), add(char,26))&#125; // add 13 to char. </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Result(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // rot13 decrypt a string</span><br><span class="line">    function rot13Decrypt (string text) public &#123;</span><br><span class="line">        uint256 length = bytes(text).length;</span><br><span class="line">        for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            byte char = bytes(text)[i];</span><br><span class="line">            assembly &#123;</span><br><span class="line">                char := byte(0,char)</span><br><span class="line">                if and(gt(char,0x60), lt(char,0x6E))</span><br><span class="line">                &#123; char:= add(0x7B, sub(char,0x61)) &#125;</span><br><span class="line">                if iszero(eq(char, 0x20))</span><br><span class="line">                &#123;mstore8(add(add(text,0x20), mul(i,1)), sub(char,26))&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Result(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>它实现了 rot26 密码（每个字母移动 26 个位置，明白了吗（微笑脸））。再次强调，你不需要了解本合约中的程序集。部署人员也可以链接下列合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Print&#123;</span><br><span class="line">    event Print(string text);</span><br><span class="line">    </span><br><span class="line">    function rot13Encrypt(string text) public &#123;</span><br><span class="line">        emit Print(text);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果这些合约中的任何一个的地址在构造函数中给出，那么 <code>encryptPrivateData()</code> 函数只会产生一个打印出未加密私有数据的事件（Event）。尽管在这个例子中，在构造函数中设置了类似库的合约，但是特权用户（例如 <code>owner</code> ）可以更改库合约地址。如果被链接的合约不包含被调用的函数，则将执行回退函数。例如，对于行 <code>encryptionLibrary.rot13Encrypt()</code> ，如果指定的合约 <code>encryptionLibrary</code> 是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Blank &#123;</span><br><span class="line">    event Print(string text);</span><br><span class="line">    function () &#123;</span><br><span class="line">        emit Print(&quot;Here&quot;);</span><br><span class="line">        //put malicious code here and it will run</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么会发出一个带有“Here”文字的事件。因此，如果用户可以更改合约库，原则上可以让用户在不知不觉中运行任意代码。</p>
<p>注意：不要使用这些加密合约，因为智能合约的输入参数在区块链上可见。另外，Rot密码并不是推荐的加密技术：p</p>
<h3 id="预防技术-6"><a href="#预防技术-6" class="headerlink" title="预防技术"></a>预防技术</h3><p>如上所示，无漏洞合约可以（在某些情况下）以恶意行为的方式部署。审计人员可以公开验证合约并让其所有者以恶意方式进行部署，从而产生具有漏洞或恶意的公开审计合约。</p>
<p>有许多技术可以防止这些情况发生。</p>
<p>一种技术是使用 <code>new</code> 关键词来创建合约。在上面的例子中，构造函数可以写成：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor（）&#123;</span><br><span class="line">    encryptionLibrary =  new  Rot13Encryption（）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样，引用合约的一个实例就会在部署时创建，并且部署者无法在不修改智能合约的情况下用其他任何东西替换 <code>Rot13Encryption</code> 合约。</p>
<p>另一个解决方案是如果已知外部合约地址的话，对所有外部合约地址进行硬编码。</p>
<p>一般来说，应该仔细查看调用外部合约的代码。作为开发人员，在定义外部合约时，最好将合约地址公开（在 Honey-pot 的例子中就不是这样），以便用户轻松查看合约引用了哪些代码。反过来说，如果合约具有私人变量合约地址，则它可能是某人恶意行为的标志（如现实示例中所示）。如果特权（或任何）用户能够更改用于调用外部函数的合约地址，（在去中心化系统的情境中）实现时间锁定或投票机制就变得很重要，为要允许用户查看哪些代码正在改变，或让参与者有机会选择加入&#x2F;退出新的合约地址。</p>
<h3 id="真实世界的例子：可重入钓鱼合约"><a href="#真实世界的例子：可重入钓鱼合约" class="headerlink" title="真实世界的例子：可重入钓鱼合约"></a>真实世界的例子：可重入钓鱼合约</h3><p>最近主网上出现了一些钓鱼合约（Honey Pot）。这些合约试图打败那些想要利用合约漏洞的黑客，让他们反过来在想要利用的合约中损失 Ether。一个例子是通过在构造函数中用恶意合约代替期望的合约来发动上述攻击。代码可以在这里找到：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Private_Bank</span><br><span class="line">&#123;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line">    uint public MinDeposit = 1 ether;</span><br><span class="line">    Log TransferLog;</span><br><span class="line">    </span><br><span class="line">    function Private_Bank(address _log)</span><br><span class="line">    &#123;</span><br><span class="line">        TransferLog = Log(_log);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function Deposit()</span><br><span class="line">    public</span><br><span class="line">    payable</span><br><span class="line">    &#123;</span><br><span class="line">        if(msg.value &gt;= MinDeposit)</span><br><span class="line">        &#123;</span><br><span class="line">            balances[msg.sender]+=msg.value;</span><br><span class="line">            TransferLog.AddMessage(msg.sender,msg.value,&quot;Deposit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function CashOut(uint _am)</span><br><span class="line">    &#123;</span><br><span class="line">        if(_am&lt;=balances[msg.sender])</span><br><span class="line">        &#123;</span><br><span class="line">            if(msg.sender.call.value(_am)())</span><br><span class="line">            &#123;</span><br><span class="line">                balances[msg.sender]-=_am;</span><br><span class="line">                TransferLog.AddMessage(msg.sender,_am,&quot;CashOut&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function() public payable&#123;&#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Log </span><br><span class="line">&#123;</span><br><span class="line">    struct Message</span><br><span class="line">    &#123;</span><br><span class="line">        address Sender;</span><br><span class="line">        string  Data;</span><br><span class="line">        uint Val;</span><br><span class="line">        uint  Time;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Message[] public History;</span><br><span class="line">    Message LastMsg;</span><br><span class="line">    </span><br><span class="line">    function AddMessage(address _adr,uint _val,string _data)</span><br><span class="line">    public</span><br><span class="line">    &#123;</span><br><span class="line">        LastMsg.Sender = _adr;</span><br><span class="line">        LastMsg.Time = now;</span><br><span class="line">        LastMsg.Val = _val;</span><br><span class="line">        LastMsg.Data = _data;</span><br><span class="line">        History.push(LastMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一位 reddit 用户发布了<a class="link"   href="https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，解释他们如何在他们想利用可重入漏洞的合约中失去 1 Ether。</p>
<h2 id="短地址-参数攻击"><a href="#短地址-参数攻击" class="headerlink" title="短地址&#x2F;参数攻击"></a>短地址&#x2F;参数攻击</h2><p>这种攻击并不是专门针对 Solidity 合约执行的，而是针对可能与之交互的第三方应用程序执行的。为了完整性，我添加了这个攻击，然后意识到了参数可以在合约中被操纵。</p>
<p>有关进一步阅读，请参阅 <a class="link"   href="https://vessenes.com/the-erc20-short-address-attack-explained/" >ERC20 短地址攻击说明 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   href="https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b" >ICO智能合约漏洞：短地址攻击 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>或<a class="link"   href="https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/" >这个 Reddit 帖子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-7"><a href="#漏洞-7" class="headerlink" title="漏洞"></a>漏洞</h3><p>将参数传递给智能合约时，参数将根据 <a class="link"   href="https://solidity.readthedocs.io/en/latest/abi-spec.html" >ABI 规范 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行编码。可以发送比预期参数长度短的编码参数（例如，发送只有 38 个十六进制字符（19 个字节）的地址而不是标准的 40 个十六进制字符（20 个字节））。在这种情况下，EVM 会将 0 填到编码参数的末尾以补成预期的长度。</p>
<p>当第三方应用程序不验证输入时，这会成为问题。最明显的例子是当用户请求提款时，交易所不验证 <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md0" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Token 的地址。Peter Venesses 的文章 “<a class="link"   href="http://vessenes.com/the-erc20-short-address-attack-explained/" >ERC20 短地址攻击解释 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>”中详细介绍了这个例子。</p>
<p>考虑一下标准的 ERC20 传输函数接口，注意参数的顺序，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint tokens) public returns (bool success);</span><br></pre></td></tr></table></figure></div>

<p>现在考虑一下，一个交易所持有大量代（比方说 <code>REP</code> ），并且，某用户希望取回他们存储的100个代币。用户将提交他们的地址， <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead</code> 以及代币的数量 <code>100</code> 。交易所将根据 <code>transfer()</code> 函数指定的顺序对这些参数进行编码，即先是 <code>address</code> 然后是 <code>tokens</code> 。编码结果将是 <code>a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000056bc75e2d63100000</code> 。前四个字节（a9059cbb）是 <code>transfer()</code>  <a class="link"   href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector" >函数签名&#x2F;选择器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，第二个 32 字节是地址，最后 32 个字节是表示代币数量的 <code>uint256</code> 。请注意，最后的十六进制数 <code>56bc75e2d63100000</code> 对应于 100 个代币（包含 18 个小数位，这是由 REP 代币合约指定的）。</p>
<p>好的，现在让我们看看如果我们发送一个丢失 1 个字节（2 个十六进制数字）的地址会发生什么。具体而言，假设攻击者以 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde</code> 作为地址发送（缺少最后两位数字），并取回相同的 <code>100</code> 个代币。如果交易所没有验证这个输入，它将被编码为 <code>a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde0000000000000000000000000000000000000000000000056bc75e2d6310000000</code> 。差别是微妙的。请注意， <code>00</code> 已被填充到编码的末尾，以补完发送的短地址。当它被发送到智能合约时， <code>address</code> 参数将被读为 <code>0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00</code> 并且值将被读为 <code>56bc75e2d6310000000</code> （注意两个额外的 0）。此值现在是 <code>25600</code> 个代币（值已被乘以 <code>256</code> ）。在这个例子中，如果交易所持有这么多的代币，用户会取出 25600 个代币（而交换所认为用户只是取出 100）到修改后的地址。很显然，在这个例子中攻击者不会拥有修改后的地址，但是如果攻击者产生了以 0 结尾的地址（很容易强制产生）并且使用了这个生成的地址，他们很容易从毫无防备的交易所中窃取令牌。</p>
<h3 id="预防技术-7"><a href="#预防技术-7" class="headerlink" title="预防技术"></a>预防技术</h3><p>我想很明显，在将所有输入发送到区块链之前对其进行验证可以防止这些类型的攻击。还应该指出的是参数排序在这里起着重要的作用。由于填充只发生在字符串末尾，智能合约中参数的缜密排序可能会缓解此攻击的某些形式。</p>
<h3 id="真实世界的例子：未知-1"><a href="#真实世界的例子：未知-1" class="headerlink" title="真实世界的例子：未知"></a>真实世界的例子：未知</h3><p>我尚不知道真实世界中发生的此类攻击的公开例子。</p>
<h2 id="不检查-CALL-返回值"><a href="#不检查-CALL-返回值" class="headerlink" title="不检查 CALL 返回值"></a>不检查 CALL 返回值</h2><p>Solidity 中有很多方法可以执行外部调用。向外部账户发送 Ether 通常通过 <code>transfer()</code> 方法完成。不过，也可以使用 <code>send()</code> 功能，而且，对于更多功能的外部调用，在 Solidity 中可以直接使用 <code>CALL</code> 操作码。 <code>call()</code> 和 <code>send()</code> 函数会返回一个布尔值，显示调用是成功还是失败。因此，这些功能有一个简单的警告作用，如果（由 <code>call()</code> 或 <code>send()</code> 初始化的）外部调用失败，执行这些函数的交易将不会回滚，反而 <code>call()</code> 或 <code>send()</code> 将简单地返回 <code>false</code> 。当没有检查返回值时，会出现一个常见的错误，并不是开发人员希望的那样发生回滚。</p>
<p>有关进一步阅读，请参阅 <a class="link"   href="http://www.dasp.co/#item-4" >DASP Top 10 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和<a class="link"   href="http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/" >剖析以太坊线上合约中的“Unchecked-Send”错误 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-8"><a href="#漏洞-8" class="headerlink" title="漏洞"></a>漏洞</h3><p>考虑下面的例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Lotto &#123;</span><br><span class="line"></span><br><span class="line">    bool public payedOut = false;</span><br><span class="line">    address public winner;</span><br><span class="line">    uint public winAmount;</span><br><span class="line">    </span><br><span class="line">    // ... extra functionality here </span><br><span class="line"></span><br><span class="line">    function sendToWinner() public &#123;</span><br><span class="line">        require(!payedOut);</span><br><span class="line">        winner.send(winAmount);</span><br><span class="line">        payedOut = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function withdrawLeftOver() public &#123;</span><br><span class="line">        require(payedOut);</span><br><span class="line">        msg.sender.send(this.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这份合约代表了一个类似于大乐透的合约，在这种合约中， <code>winner</code> 会收到 <code>winAmount</code> 个 Ether，通常只剩下一点让其他人取出。</p>
<p>错误存在于第 [11] 行，其中使用 <code>send()</code> 而不检查响应值。在这个微不足道的例子中， <code>winner</code> 的交易失败（无论是通过耗尽 Gas、通过故意抛出回退函数的合约，还是调用<a class="link"   href="https://github.com/ethereum/wiki/wiki/Safety#call-depth-attack-deprecated" >堆栈深度攻击 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）可以使得 <code>payedOut</code> 被设置为 <code>true</code> （无论是否发送了 Ether） 。在这种情况下，公众可以通过 <code>withdrawLeftOver()</code> 函数取出属于 <code>winner</code> 的奖金。</p>
<h3 id="预防技术-8"><a href="#预防技术-8" class="headerlink" title="预防技术"></a>预防技术</h3><p>只要有可能，使用 <code>transfer()</code> 功能，而不是 <code>send()</code> ，因为，如果外部交易回滚， <code>transfer()</code> 会触发回滚。如果需要使用 <code>send()</code> ，请务必检查返回值。</p>
<p>一种更强大的<a class="link"   href="http://solidity.readthedocs.io/en/latest/common-patterns.html#withdrawal-from-contracts" >推荐用法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是采取 <em>withdrawel（取出）模式</em>。在这个解决方案中，每个用户都得调用相互隔离的函数（即 <em>withdrawel</em> 函数），这一函数会处理将 Ether 发送到合约以外的交易，因此，它会分别处理发送失败的交易结果。这个想法是将外部发送功能与代码库的其余部分进行逻辑隔离，并将可能失败的交易负担交给正在调用 <em>withdrawel</em> 函数的最终用户。</p>
<h3 id="真实的例子：Etherpot-和-King-of-Ether"><a href="#真实的例子：Etherpot-和-King-of-Ether" class="headerlink" title="真实的例子：Etherpot 和 King of Ether"></a>真实的例子：Etherpot 和 King of Ether</h3><p><a class="link"   href="https://github.com/etherpot" >Etherpot <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个彩票智能合约，与上面提到的示例合约不太相似。Etherpot 的 Soloidity 代码可以在这里找到：<a class="link"   href="https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol" >lotto.sol <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。这个合约的主要缺点是对块哈希的不当使用（只有最后 256 个块的哈希值是可用的，请参阅 Aakil Fernandes 关于 Etherpot 如何正确实现的<a class="link"   href="http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks" >帖子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。然而，这份合约也受到未经检查的 Call 返回值的影响。注意lotto.sol 的 行[80] 上的函数 <code>cash()</code> ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function cash(uint roundIndex, uint subpotIndex)&#123;</span><br><span class="line"></span><br><span class="line">        var subpotsCount = getSubpotsCount(roundIndex);</span><br><span class="line"></span><br><span class="line">        if(subpotIndex&gt;=subpotsCount)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);</span><br><span class="line"></span><br><span class="line">        if(decisionBlockNumber&gt;block.number)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        if(rounds[roundIndex].isCashed[subpotIndex])</span><br><span class="line">            return;</span><br><span class="line">        //Subpots can only be cashed once. This is to prevent double payouts</span><br><span class="line"></span><br><span class="line">        var winner = calculateWinner(roundIndex,subpotIndex);    </span><br><span class="line">        var subpot = getSubpot(roundIndex);</span><br><span class="line"></span><br><span class="line">        winner.send(subpot);</span><br><span class="line"></span><br><span class="line">        rounds[roundIndex].isCashed[subpotIndex] = true;</span><br><span class="line">        //Mark the round as cashed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，在 行[21]，发送函数的返回值没有被检查，然后下一行设置了一个布尔值，表示已经向赢家发送了属于他们的奖金。这个错误可能引发一种状态，即赢家没有收到他们的 Ether，但是合约状态表明赢家已经得到了支付。</p>
<p>这个错误的更严重的版本发生在 <a class="link"   href="https://www.kingoftheether.com/thrones/kingoftheether/index.html" >King of the Ether <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。已经有人写出一篇优秀的<a class="link"   href="https://www.kingoftheether.com/postmortem.html" >事后检验报告 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，详细介绍了一个未经检查的 <code>send()</code> 失败交易可以如何用于攻击合约。</p>
<h2 id="条件竞争-抢先提交"><a href="#条件竞争-抢先提交" class="headerlink" title="条件竞争&#x2F;抢先提交"></a>条件竞争&#x2F;抢先提交</h2><p>将对其它合约的外部调用以及底层区块链的多用户特性结合在一起，会在 Solidity 中产生各种潜在的缺陷，用户可能会 <em>争用（race）</em> 代码产生意外状态。<a class="link"   href="https://ethfans.org/posts/comprehensive-list-of-common-attacks-and-defense-part-1" >可重入漏洞 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是这种条件竞争（Race Conditions）的一个例子。在本节中，我们将更一般地讨论以太坊区块链上可能发生的各种竞态条件。在这个领域有很多不错的帖子，其中一些是：<a class="link"   href="https://github.com/ethereum/wiki/wiki/Safety#race-conditions" >以太坊Wiki - 安全 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   href="http://www.dasp.co/#item-7" >DASP - 前台运行和共识 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以及<a class="link"   href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions" >智能合约最佳实践 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-9"><a href="#漏洞-9" class="headerlink" title="漏洞"></a>漏洞</h3><p>与大多数区块链一样，以太坊节点汇集交易并将其打包成块。一旦矿工获得了共识机制（目前以太坊上实行的是 <a class="link"   href="https://github.com/ethereum/wiki/wiki/Ethash" >ETHASH <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 工作量证明算法）的一个解，这些交易就被认为是有效的。挖出该区块的矿工同时也选择将交易池中的哪些交易包含在该区块中，一般来说是根据交易的 <code>gasPrice</code> 来排序。在这里有一个潜在的攻击媒介。攻击者可以监测交易池，看看其中是否存在问题的解决方案（如下合约所示）、修改或撤销攻击者的权限、或更改合约中状态的交易；这些交易对攻击者来说都是阻碍。然后攻击者可以从该中获取数据，并创建一个 <code>gasPrice</code> 更高的交易，（让自己的交易）抢在原始交易之前被打包到一个区块中。</p>
<p>让我们看看这可以如何用一个简单的例子。考虑合约 <code>FindThisHash.sol</code> ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FindThisHash &#123;</span><br><span class="line">    bytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;</span><br><span class="line">    </span><br><span class="line">    constructor() public payable &#123;&#125; // load with ether</span><br><span class="line">    </span><br><span class="line">    function solve(string solution) public &#123;</span><br><span class="line">        // If you can find the pre image of the hash, receive 1000 ether</span><br><span class="line">        require(hash == sha3(solution)); </span><br><span class="line">        msg.sender.transfer(1000 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>想象一下，这个合约包含 1000 个 Ether。可以找到 sha3 哈希值为 <code>0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a</code> 的原象（Pre-image）的用户可以提交解决方案，然后取得 1000 Ether。让我们假设，一个用户找到了答案 <code>Ethereum!</code> 。他们可以调用 <code>solve()</code> 并将 <code>Ethereum!</code> 作为参数。不幸的是，攻击者非常聪明，他监测交易池看看有没有人提交解决方案。他们看到这个解决方案，检查它的有效性，然后提交一个 <code>gasPrice</code> 远高于原始交易的相同交易。挖出当前块的矿工可能会因更高的 <code>gasPrice</code> 而偏爱攻击者发出的交易，并在打包原始交易之前接受他们的交易。攻击者将获得1000 Ether，解决问题的用户将不会得到任何东西（因为合约中没有剩余的 Ether）。</p>
<p>未来 Casper 实现的设计中会出现更现实的问题。Casper 权益证明合约涉及罚没条件，在这些条件下，注意到验证者双重投票或行为不当的用户被激励提交验证者已经这样做的证据。验证者将受到惩罚、用户会得到奖励。在这种情况下，可以预期，矿工和用户会抢先提交（Front-run）所有这样的证据（以获得奖励），这个问题必须在最终发布之前解决。</p>
<h3 id="预防技术-9"><a href="#预防技术-9" class="headerlink" title="预防技术"></a>预防技术</h3><p>有两类用户可以执行这种抢先提交攻击。用户（他们可以修改他们交易的 <code>gasPrice</code> ）和矿工自己（他可以依自己的意愿安排包含在块中的交易）。易受第一类（用户）攻击的合约比易受第二类（矿工）影响的合约明显更差，因为矿工只能在挖出某个块时执行攻击，对任何单个矿工来说都不太可能针对特定区块发动攻击（译者注：因为他们不一定能挖出特定高度的区块）。在这里，我将列出一些与他们可能阻止的攻击者类别有关的缓解措施。</p>
<p>可以采用的一种方法是在合约中创建逻辑，设置 <code>gasPrice</code> 的上限。这可以防止用户增加 <code>gasPrice</code> 并因超出上限而获得优先的交易排序。这种预防措施只能缓解第一类攻击者（任意用户）。在这种情况下，矿工仍然可以攻击合约，因为无论 Gas价格如何，他们都可以安排包含在他们的块中的交易。</p>
<p>一个更强大的方法是尽可能使用 <a class="link"   href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" >承诺-公开（commit-reveal） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 方案。这种方案规定用户使用隐藏信息（通常是哈希值）发送交易。在交易已包含在块中后，用户将发送一个交易来显示已发送的数据（reveal 阶段）。这种方法可以防止矿工和用户从事抢先交易，因为他们无法确定交易的内容。然而，这种方法不能隐藏交易价值（在某些情况下，这是需要隐藏的有价值的信息）。<a class="link"   href="https://ens.domains/" >ENS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 智能合约允许用户发送交易，其承诺数据包括他们愿意花费的金额。用户可以发送任意值的交易。在披露阶段，用户可以取出交易中发送的金额与他们愿意花费的金额之间的差额。</p>
<p>Lorenz、Phil、Ari 以及 Florian 的进一步建议是使用 <a class="link"   href="http://hackingdistributed.com/2017/08/28/submarine-sends/" >Submarine Sends <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。这个想法的有效实现需要 <code>CREATE2</code> 操作码，目前还没有被采用，但可能出现在即将到来的硬分叉上。</p>
<h3 id="真实世界的例子：ERC20-和-Bancor"><a href="#真实世界的例子：ERC20-和-Bancor" class="headerlink" title="真实世界的例子：ERC20 和 Bancor"></a>真实世界的例子：ERC20 和 Bancor</h3><p><a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是相当知名的在以太坊上开发代币的标准。这个标准有一个潜在的抢先提交漏洞，这个漏洞是由于 <code>approve()</code> 功能而产生的。这个漏洞的一个很好的解释可以在<a class="link"   href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>找到。</p>
<p>该标准规定的 <code>approve()</code> 功能如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function approve(address _spender, uint256 _value) returns (bool success)</span><br></pre></td></tr></table></figure></div>

<p>该功能让用户可以授权其他用户代表他们转移代币。当用户Alice <em>批准（Approve）</em> 她的朋友 Bob 花费 <code>100 tokens</code> 时，这种先发制人的漏洞就会出现。Alice 后来决定，她想撤销对 Bob 花费 <code>100 tokens</code> 的批准，所以她创建了一个交易，设置 Bob 的份额为 <code>50 tokens</code> 。Bob 一直在仔细监测链上数据，看到这笔交易之后他建立了一笔他自己的交易，花费了 <code>100 tokens</code> 。他给自己的交易设置了比 Alice 交易更高的 <code>gasPrice</code> ，让自己的交易优先于她的交易。一些 <code>approve()</code> 的实现允许 Bob 转移他的 <code>100 tokens</code> ，然后当 Alice 的交易被提交时，重置 Bob 的批准份额为 <code>50 tokens</code> ，实际上允许 Bob 调动 <code>150 tokens</code> 。上面链接到的<a class="link"   href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" >文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>给出了针对这一攻击的缓解策略。</p>
<p>另一个突出的现实世界的例子是 <a class="link"   href="https://www.bancor.network/" >Bancor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。Ivan Bogatty 和他的团队记录了对 Bancor 初始实现的有利可图的攻击。他的<a class="link"   href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798" >博客文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和<a class="link"   href="https://www.youtube.com/watch?v=RL2nE3huNiI" >Devcon 3 演讲 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>详细讨论了这是如何完成的。基本上，代币的价格是根据交易价值确定的，用户可以观测 Bancor 交易的交易池，并抢先提交它们以从价格差异中获利。Bancor 团队已经解决了这种攻击。</p>
<h2 id="拒绝服务（DOS）"><a href="#拒绝服务（DOS）" class="headerlink" title="拒绝服务（DOS）"></a>拒绝服务（DOS）</h2><p>这个类别非常广泛，但其基本攻击形式都是让用户短暂地（在某些情形下，是永久）推出不可操作的合约。这种攻击可以把 Ether 永远锁在被攻击的合约中，正如 <a href="#%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%A4%BA%E4%BE%8Bparity-multisig-walletsecond-hack">Parity 多签名钱包第二次被黑</a>中的情形一样。</p>
<h3 id="漏洞-10"><a href="#漏洞-10" class="headerlink" title="漏洞"></a>漏洞</h3><p>有很多办法可以让合约变得不可操作。这里我只强调一些微妙的区块链 Solidity 编码模式，虽然看不太出来，但可能留下让攻击者执行 DOS 攻击的空间。</p>
<p><strong>1.通过外部操纵映射或数组（Array）循环</strong> ——在我的经历中，我看过此种模式的各种形式。通常情况下，它出现在 <code>owner</code> 希望在其投资者之间分配代币的情况下，以及，在合约中可以看到类似于 <code>distribute()</code> 函数的情况下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DistributeTokens &#123;</span><br><span class="line">    address public owner; // gets set somewhere</span><br><span class="line">    address[] investors; // array of investors</span><br><span class="line">    uint[] investorTokens; // the amount of tokens each investor gets</span><br><span class="line">    </span><br><span class="line">    // ... extra functionality, including transfertoken()</span><br><span class="line">    </span><br><span class="line">    function invest() public payable &#123;</span><br><span class="line">        investors.push(msg.sender);</span><br><span class="line">        investorTokens.push(msg.value * 5); // 5 times the wei sent</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    function distribute() public &#123;</span><br><span class="line">        require(msg.sender == owner); // only owner</span><br><span class="line">        for(uint i = 0; i &lt; investors.length; i++) &#123; </span><br><span class="line">            // here transferToken(to,amount) transfers &quot;amount&quot; of tokens to the address &quot;to&quot;</span><br><span class="line">            transferToken(investors[i],investorTokens[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，此合约中的循环遍历的数组可以被人为扩充。攻击者可以创建许多用户帐户，让 <code>investor</code> 数据变得更大。原则上来说，可以让执行 for 循环所需的 Gas 超过区块 Gas 上限，这会使 <code>distribute()</code> 函数变得无法操作。</p>
<p><strong>2.所有者操作</strong>——另一种常见模式是所有者在合约中具有特定权限，并且必须执行一些任务才能使合约进入下一个状态。例如，ICO 合约要求所有者 <code>finalize()</code> 签订合约，然后才可以转让代币，即</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool public isFinalized = false;</span><br><span class="line">address public owner; // gets set somewhere</span><br><span class="line"></span><br><span class="line">function finalize() public &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    isFinalized == true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... extra ICO functionality</span><br><span class="line"></span><br><span class="line">// overloaded transfer function</span><br><span class="line">function transfer(address _to, uint _value) returns (bool) &#123;</span><br><span class="line">    require(isFinalized);</span><br><span class="line">    super.transfer(_to,_value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这种情况下，如果权限用户丢失其私钥或变为非活动状态，则整个代币合约就变得无法操作。在这种情况下，如果 <code>owner</code> 无法调用 <code>finalize()</code> 则代币不可转让；即代币系统的全部运作都取决于一个地址。</p>
<p><strong>3.基于外部调用的进展状态</strong>——有时候，合约被编写成为了进入新的状态需要将 Ether 发送到某个地址，或者等待来自外部来源的某些输入。这些模式也可能导致 DOS 攻击：当外部调用失败时，或由于外部原因而被阻止时。在发送 Ether 的例子中，用户可以创建一个不接受 Ether 的合约。如果合约需要将 Ether 发送到这个地址才能进入新的状态，那么合约将永远不会达到新的状态，因为 Ether 永远不会被发送到合约。</p>
<h3 id="预防技术-10"><a href="#预防技术-10" class="headerlink" title="预防技术"></a>预防技术</h3><p>在第一个例子中，合约不应该遍历可以被外部用户人为操纵的数据结构。建议使用 withdrawal 模式，每个投资者都会调用取出函数独立取出代币。</p>
<p>在第二个例子中，改变合约的状态需要权限用户参与。在这样的例子中（只要有可能），如果 <code>owner</code> 已经瘫痪，可以使用自动防故障模式。一种解决方案是将 <code>owner</code> 设为一个多签名合约。另一种解决方案是使用一个时间锁，其中 [13]行 上的需求可以包括在基于时间的机制中，例如 <code>require(msg.sender == owner || now &gt; unlockTime)</code> ，那么在由 <code>unlockTime</code> 指定的一段时间后，任何用户都可以调用函数，完成合约。这种缓解技术也可以在第三个例子中使用。如果需要进行外部调用才能进入新状态，请考虑其可能的失败情况；并添加基于时间的状态进度，防止所需外部调用迟迟不到来。</p>
<p><em>注意：当然，这些建议都有中心化的替代方案，比如，可以添加 <code>maintenanceUser</code> ，它可以在有需要时出来解决基于 DOS 攻击向量的问题。通常，这类合约包含对这类权力实体的信任问题；不过这不是本节要探讨的内容</em>。</p>
<h3 id="真实的例子：GovernMental"><a href="#真实的例子：GovernMental" class="headerlink" title="真实的例子：GovernMental"></a>真实的例子：GovernMental</h3><p><a class="link"   href="http://governmental.github.io/GovernMental/" >GovernMental <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是一个古老的庞氏骗局，积累了相当多的 Ether。实际上，它曾经积累起 1100 个以太。不幸的是，它很容易受到本节提到的 DOS 漏洞的影响。<a class="link"   href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/" >这篇 Reddit  帖子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>描述了合约需要删除一个大的映射来取出以太。删除映射的 Gas 消耗量超过了当时的区块 Gas 上限，因此不可能撤回那 1100 个 Ether。合约地址为 <a href="https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3"><code>0xF45717552f12Ef7cb65e95476F217Ea008167Ae3</code></a>，您可以从交易<a href="https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b"><code>0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b</code></a>中看到，最后有人通过使用 250 万 Gas的交易取出了 1100 Ether 。</p>
<h2 id="操纵区块时间戳"><a href="#操纵区块时间戳" class="headerlink" title="操纵区块时间戳"></a>操纵区块时间戳</h2><p>区块时间戳历来被用于各种应用，例如随机数的函数（请参阅<a href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E8%AF%AF%E5%8C%BA">随机数误区</a>以获取更多详细信息）、锁定一段时间的资金、以及各种基于时间变更状态的条件语句。矿工有能力稍微调整时间戳，如果在智能合约中错误地使用区块时间戳，可以证明这是相当危险的。</p>
<p>一些有用的参考资料是：<a class="link"   href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties" >Solidity Docs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，以及这个 <a class="link"   href="https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" >Stack Exchange 上的问题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-11"><a href="#漏洞-11" class="headerlink" title="漏洞"></a>漏洞</h3><p> <code>block.timestamp</code> 或者别名 <code>now</code> 可以由矿工操纵，如果他们有这样做的激励的话。让我们构建一个简单的、容易受到矿工的剥削的游戏，</p>
<p> <code>roulette.sol</code> ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Roulette &#123;</span><br><span class="line">    uint public pastBlockTime; // Forces one bet per block</span><br><span class="line">    </span><br><span class="line">    constructor() public payable &#123;&#125; // initially fund contract</span><br><span class="line">    </span><br><span class="line">    // fallback function used to make a bet</span><br><span class="line">    function () public payable &#123;</span><br><span class="line">        require(msg.value == 10 ether); // must send 10 ether to play</span><br><span class="line">        require(now != pastBlockTime); // only 1 transaction per block</span><br><span class="line">        pastBlockTime = now;</span><br><span class="line">        if(now % 15 == 0) &#123; // winner</span><br><span class="line">            msg.sender.transfer(this.balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这份合约是一个简单的彩票。每个区块都有一笔交易可以下注 10 Ether，获得机会赢取合约中的全部余额。这里的假设是， <code>block.timestamp</code> 的最后两位数字是均匀分布的。如果是这样，那么将有 1&#x2F;15 的机会赢得这个彩票。</p>
<p>但是，正如我们所知，矿工可以根据自己的意愿调整时间戳。在这种特殊情况下，如果合约中有足够的 Ether，挖出某个区块的矿工将被激励选择一个 <code>block.timestamp</code> 或 <code>now</code> 对 15 取余为 <code>0</code> 的时间戳。在这样做的时候，他们可能会赢得这个合约中的 Ether 以及区块奖励。由于每个区块只允许一个人下注，所以这也容易受到<a href="#%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/%E6%8A%A2%E5%85%88%E6%8F%90%E4%BA%A4">抢先提交攻击</a>。</p>
<p>在实践中，区块时间戳是单调递增的，所以矿工不能选择任意块时间戳（它们必须大于其祖先块）。区块时间也不能是未来值，因为这些块可能会被网络拒绝（节点不会验证其时间戳指向未来的块）。</p>
<h3 id="预防技术-11"><a href="#预防技术-11" class="headerlink" title="预防技术"></a>预防技术</h3><p>区块时间戳不应该用于熵源或产生随机数——也就是说，它们不应该是游戏判定胜负或改变重要状态（如果假定为随机）的决定性因素（无论是直接还是通过某些推导）。</p>
<p>时效性强的逻辑有时是必需的；即解锁合约（时间锁定），几周后完成 ICO 或到期强制执行。有时建议使用 <code>block.number</code>（参见 <a class="link"   href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties" >Solidity 文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）和平均区块时间来估计时间；即，10 秒的区块时间运行 1 周，约等于，60480 个区块。因此，指定区块编号来更改合约状态可能更安全，因为矿工无法轻松操纵区块编号。<a class="link"   href="https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code" >BAT ICO合约 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>就采用这种策略。</p>
<p>如果合约不是特别关心矿工对区块时间戳的操纵，这可能是不必要的，但是在开发合约时应该注意这一点。</p>
<h3 id="真实的例子：GovernMental-1"><a href="#真实的例子：GovernMental-1" class="headerlink" title="真实的例子：GovernMental"></a>真实的例子：GovernMental</h3><p><a class="link"   href="http://governmental.github.io/GovernMental/" >GovernMental <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个古老的庞氏骗局，积累了相当多的 Ether。它也容易受到基于时间戳的攻击。合约会在一轮内支付给最后一个加入合约的玩家（需要加入至少一分钟）。因此，作为玩家的矿工可以调整时间戳（未来的时间，使其看起来像是一分钟过去了），以显示玩家加入已经超过一分钟（尽管现实中并非如此）。关于这方面的更多细节可以在 Tanya Bahrynovska 的 <a href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes"><em>以太坊安全漏洞史</em></a> 中找到。</p>
<h2 id="构造函数失控"><a href="#构造函数失控" class="headerlink" title="构造函数失控"></a>构造函数失控</h2><p>构造函数（Constructors）是特殊函数，在初始化合约时经常执行关键的权限任务。在 solidity v0.4.22 以前，构造函数被定义为与所在合约同名的函数。因此，如果合约名称在开发过程中发生变化，而构造函数名称没有更改，它将变成正常的可调用函数。正如你可以想象的，这可以（并且已经）导致一些有趣的合约被黑。</p>
<p>为了进一步阅读，我建议读者尝试 <a class="link"   href="https://github.com/OpenZeppelin/ethernaut" >Ethernaught 挑战 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（特别是 Fallout 层级）。</p>
<h3 id="漏洞-12"><a href="#漏洞-12" class="headerlink" title="漏洞"></a>漏洞</h3><p>如果合约名称被修改，或者在构造函数名称中存在拼写错误以致它不再与合约名称匹配，则构造函数的行为将与普通函数类似。这可能会导致可怕的后果，特别是如果构造函数正在执行有权限的操作。考虑以下合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OwnerWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    //constructor</span><br><span class="line">    function ownerWallet(address _owner) public &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // fallback. Collect ether.</span><br><span class="line">    function () payable &#123;&#125; </span><br><span class="line">    </span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        require(msg.sender == owner); </span><br><span class="line">        msg.sender.transfer(this.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该合约储存 Ether，并只允许所有者通过调用 <code>withdraw()</code> 函数来取出所有 Ether。但由于构造函数的名称与合约名称不完全一致，这个合约会出问题。具体来说， <code>ownerWallet</code> 与 <code>OwnerWallet</code> 不相同。因此，任何用户都可以调用 <code>ownerWallet()</code> 函数，将自己设置为所有者，然后通过调用 <code>withdraw()</code> 将合约中的所有 Ether 都取出来。</p>
<h3 id="预防技术-12"><a href="#预防技术-12" class="headerlink" title="预防技术"></a>预防技术</h3><p>这个问题在 Solidity 0.4.22 版本的编译器中已经基本得到了解决。该版本引入了一个关键词 <code>constructor</code> 来指定构造函数，而不是要求函数的名称与合约名称匹配。建议使用这个关键词来指定构造函数，以防止上面显示的命名问题。</p>
<h3 id="真实世界的例子：Rubixi"><a href="#真实世界的例子：Rubixi" class="headerlink" title="真实世界的例子：Rubixi"></a>真实世界的例子：Rubixi</h3><p>Rubixi（<a class="link"   href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code" >合约代码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）是另一个显现出这种漏洞的传销方案。合约中的构造函数一开始叫做 <code>DynamicPyramid</code> ，但合约名称在部署之前已改为 <code>Rubixi</code> 。构造函数的名字没有改变，因此任何用户都可以成为 <code>creator</code> 。这篇 <a class="link"   href="https://bitcointalk.org/index.php?topic=1400536.60" >Bitcoin Thread <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中可以找到关于这个 bug 的一些有趣的讨论。总之，用户因为这个漏洞开始互相争夺 <code>creator</code> 身份，以从合约中获得金钱。关于这个特定 bug 的更多细节可以在<a class="link"   href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>找到。</p>
<h2 id="未初始化的存储指针"><a href="#未初始化的存储指针" class="headerlink" title="未初始化的存储指针"></a>未初始化的存储指针</h2><p>EVM 既用 <code>storage</code> 来存储，也用 <code>memory</code> 来存储。强烈建议开发合约时弄懂存储的方式和函数局部变量的默认类型。因为不恰当地初始化变量可能产生有漏洞的合约。</p>
<p>要了解更多关于的 EVM 中 <code>storage</code> 和 <code>memory</code> 的内容，请看 <a class="link"   href="http://solidity.readthedocs.io/en/latest/types.html#data-location" >Solidity Docs: Data Location <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage" >Solidity Docs: Layout of State Variables in Storage <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-in-memory" >Solidity Docs: Layout in Memory <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>*本节以 <a class="link"   href="https://medium.com/cryptronics/storage-allocation-exploits-in-ethereum-smart-contracts-16c2aa312743" >Sfan Beyer出色的文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为基础。关于这个话题的进一步阅读可以从 Sefan 的启发中找到，也就是个这篇 <a class="link"   href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/" >reddit 帖子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>*。</p>
<h3 id="漏洞-13"><a href="#漏洞-13" class="headerlink" title="漏洞"></a>漏洞</h3><p>函数内的局部变量根据它们的类型默认用 <code>storage</code> 或 <code>memory</code> 存储。未初始化的局部 <code>storage</code> 变量可能会指向合约中的其他意外存储变量，从而导致有意（即，开发人员故意将它们放在那里进行攻击）或无意的漏洞。</p>
<p>我们来考虑以下相对简单的名称注册器合约：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// A Locked Name Registrar</span><br><span class="line">contract NameRegistrar &#123;</span><br><span class="line"></span><br><span class="line">    bool public unlocked = false;  // registrar locked, no name updates</span><br><span class="line">    </span><br><span class="line">    struct NameRecord &#123; // map hashes to addresses</span><br><span class="line">        bytes32 name;  </span><br><span class="line">        address mappedAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; NameRecord) public registeredNameRecord; // records who registered names </span><br><span class="line">    mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses</span><br><span class="line">    </span><br><span class="line">    function register(bytes32 _name, address _mappedAddress) public &#123;</span><br><span class="line">        // set up the new NameRecord</span><br><span class="line">        NameRecord newRecord;</span><br><span class="line">        newRecord.name = _name;</span><br><span class="line">        newRecord.mappedAddress = _mappedAddress; </span><br><span class="line"></span><br><span class="line">        resolve[_name] = _mappedAddress;</span><br><span class="line">        registeredNameRecord[msg.sender] = newRecord; </span><br><span class="line"></span><br><span class="line">        require(unlocked); // only allow registrations if contract is unlocked</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个简单的名称注册器只有一个功能。当合约是 <code>unlocked</code> 状态时，任何用户都可以注册一个名称（以 <code>bytes32</code> 哈希值的形式）并将该名称映射到地址。不幸的是，这个注册器一开始是被锁定的，并且在 [23] 行的 <code>require</code> 函数禁止 <code>register()</code> 添加姓名记录。但是，这个合约中存在一个漏洞，让用户可以不管 <code>unlocked</code> 运行注册器。</p>
<p>为了讨论这个漏洞，首先我们需要了解存储（Storage）在 Solidity 中的工作方式。作为一个高度抽象的概述（没有任何适当的技术细节——我建议阅读 Solidity 文档以进行适当的审查），状态变量按它们出现在合约中的顺序存储在合约的 <em>Slot</em> 中（它们可以被组合在一起，但在本例中不可以，所以我们不用担心）。因此， <code>unlocked</code> 存在 <code>slot 0</code> 中， <code>registeredNameRecord</code> 存在 <code>slot 1</code> 中， <code>resolve</code> 在 <code>slot 2</code> 中，等等。这些 slot 的大小是 32 字节（映射会让事情更加复杂，但我们暂时忽略）。如果 <code>unlocked</code> 是 <code>false</code> ，其布尔值看起来会是 <code>0x000...0</code> （64 个 0，不包括 <code>0x</code> ）；如果是 <code>true</code> ，则其布尔值会是 <code>0x000...1</code> （63 个 0）。正如你所看到的，在这个特殊的例子中，存储上存在着很大的浪费。</p>
<p>我们需要的另一部分知识，是 Solidity 会在将复杂的数据类型，比如 <code>structs</code> ，初始化为局部变量时，默认使用 storage 来存储。因此，在 [16] 行中的 <code>newRecord</code> 默认为storage。合约的漏洞是由 <code>newRecord</code> 未初始化导致的。由于它默认为 storage，因此它成为指向 storage 的指针；并且由于它未初始化，它指向 slot 0（即 <code>unlocked</code> 的存储位置）。请注意，[17] 行和[18] 行中，我们将 <code>_name</code> 设为 <code>nameRecord.name</code> 、将  <code>_mappedAddress</code> 设为 <code>nameRecord.mappedAddress</code> 的操作，实际上改变了 slot 0 和 slot 1 的存储位置，也就是改变了 <code>unlocked</code> 和与 <code>registeredNameRecord</code> 相关联的 slot。</p>
<p>这意味着我们可以通过 <code>register()</code> 函数的 <code>bytes32 _name</code> 参数直接修改 <code>unlocked</code> 。因此，如果 <code>_name</code> 的最后一个字节为非零，它将修改 slot 0 的最后一个字节并直接将 <code>unlocked</code> 转为 <code>true</code> 。就在我们将 <code>unlocked</code> 设置为 <code>true</code> 之时，这样的 <code>_name</code> 值将传入 [23] 行的 <code>require()</code> 函数。在Remix中试试这个。注意如果你的 <code>_name</code> 使用下面形式，函数会通过： <code>0x0000000000000000000000000000000000000000000000000000000000000001</code> </p>
<h3 id="预防技术-13"><a href="#预防技术-13" class="headerlink" title="预防技术"></a>预防技术</h3><p>Solidity 编译器会在出现未经初始化的存储变量时发出警告，因此开发人员在构建智能合约时应小心注意这些警告。当前版本的 mist（0.10）不允许编译这些合约。在处理复杂类型时，明确使用 <code>memory</code> 或 <code>storage</code> 以保证合约行为符合预期一般是很好的做法。</p>
<h3 id="真实世界的例子：钓鱼：OpenAddressLottery-和-CryptoRoulette"><a href="#真实世界的例子：钓鱼：OpenAddressLottery-和-CryptoRoulette" class="headerlink" title="真实世界的例子：钓鱼：OpenAddressLottery 和 CryptoRoulette"></a>真实世界的例子：钓鱼：OpenAddressLottery 和 CryptoRoulette</h3><p>有人部署了一个名为 OpenAddressLottery（<a class="link"   href="https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code" >合约代码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）的钓鱼合约，它使用未初始化的存储变量以从一些可能的黑客手上吊取 ether。合约是相当深入的，所以我会把讨论留在这个 <a class="link"   href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/" >reddit 帖子 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中。我在里面很清楚地解释了这种攻击。</p>
<p>另一个钓鱼合约，CryptoRoulette（<a class="link"   href="https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code" >合约代码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）也利用这个技巧尝试获得一些 Ether。如果您无法弄清楚攻击是如何进行的，请参阅<a class="link"   href="https://medium.com/@jsanjuas/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d" >对以太坊钓鱼合约的分析 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以获得对此合约和其他内容的概述。</p>
<h2 id="浮点和精度"><a href="#浮点和精度" class="headerlink" title="浮点和精度"></a>浮点和精度</h2><p>在撰写本文时（Solidity v0.4.24），Solidity 不支持定点或浮点数。这意味着浮点表示必须用 Solidity 中的整数类型进行表示。如果没有正确实施，这可能会导致错误&#x2F;漏洞。</p>
<p>如需进一步阅读，请参阅<a class="link"   href="https://github.com/ethereum/wiki/wiki/Safety#beware-rounding-with-integer-division" >以太坊合约安全技术和提示：整数除法的舍入 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-14"><a href="#漏洞-14" class="headerlink" title="漏洞"></a>漏洞</h3><p>由于 Solidity 中没有固定小数点类型，因此开发人员需要使用标准整数数据类型来实现它们自己的类型。在这个过程中，开发人员可能遇到一些陷阱。我将尝试在本节中重点介绍其中的一些内容。</p>
<p>让我们从一个代码示例开始（为简单起见，忽略任何数值上溢&#x2F;下溢问题）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FunWithNumbers &#123;</span><br><span class="line">    uint constant public tokensPerEth = 10; </span><br><span class="line">    uint constant public weiPerEth = 1e18;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function buyTokens() public payable &#123;</span><br><span class="line">        uint tokens = msg.value/weiPerEth*tokensPerEth; // convert wei to eth, then multiply by token rate</span><br><span class="line">        balances[msg.sender] += tokens; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sellTokens(uint tokens) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= tokens);</span><br><span class="line">        uint eth = tokens/tokensPerEth; </span><br><span class="line">        balances[msg.sender] -= tokens;</span><br><span class="line">        msg.sender.transfer(eth*weiPerEth); //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个简单的合约在代币的买卖中存在一些明显的问题。虽然买卖代币的数学计算是正确的，但浮点数的缺乏会给出错误的结果。例如，当在 [7]行 上购买令牌时，如果该值小于 <code>1 ether</code> ，最初的除法将产生 <code>0</code> ，并使得最后的乘法结果也是 <code>0</code> （即 <code>200 wei</code> 除以 <code>1e18</code>  <code>weiPerEth</code> 等于 <code>0</code> ）。同样，当销售代币时，如果代币数量小于 <code>10 </code> ，就只能得到 <code>0 ether</code> 。事实上，这里四舍五入总是舍去，所以销售 <code>29 tokens</code> 只能得到 <code>2 ether</code> 。</p>
<p>这个合约的问题是精度只能到最近的 ether（即 <code>1e18 wei</code> ）。如果您在处理 <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" >ERC20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 代币的 <code>decimals</code> 时需要更高的精度，有时会有点棘手。</p>
<h3 id="预防技术-14"><a href="#预防技术-14" class="headerlink" title="预防技术"></a>预防技术</h3><p>保持智能合约的正确精确度非常重要，尤其是在处理反映经济决策的比率时。</p>
<p>您应该确保您使用的任何比率都可以在分数中使用大数。例如，我们在示例中使用了费率 <code>tokensPerEth</code> 。但是使用 <code>weiPerTokens</code> 这样的很大的数字会更好。为求出代币的数量我们可以使用 <code>msg.sender/weiPerTokens</code> 。这样做会给出更精确的结果。</p>
<p>要记住的另一个策略是注意操作的顺序。在上面的例子中，代币购买量的计算是 <code>msg.value/weiPerEth * tokenPerEth</code> 。请注意，除法发生在乘法之前。如果计算首先进行乘法，然后再进行除法，即 <code>msg.value * tokenPerEth/weiPerEth</code> ，那么这个例子会达到更高的精度，。</p>
<p>最后，为数字定义精度时，这样做可能是一个好主意：将变量转换为更高精度，执行所有数学运算，最后在需要时将其转换回所需的输出精度。一般来说， <code>uint256</code> 是最常见的数据类型（因为这种类型使用的 Gas 最少），它们的范围约为 60 个数量级，其中一些是可用于数学运算的精确度。有意义的是：最好让 Solidity 中的所有变量都保持高精度，而在外部应用程序中转换回较低的精度（这实际上是 ERC20 代币合约中变量 <code>decimals</code> 的工作原理）。要查看如何完成此操作的示例以及执行此操作的库，我建议查看 <a class="link"   href="https://github.com/dapphub/ds-math" >Maker DAO DSMath <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。他们的命名可能不尽合理，但这个概念是非常有用的。</p>
<h3 id="真实世界的例子：Ethstick"><a href="#真实世界的例子：Ethstick" class="headerlink" title="真实世界的例子：Ethstick"></a>真实世界的例子：Ethstick</h3><p>我无法找到一个舍入问题导致合约漏洞的好例子，但我相信这里有很多。如果你有一个好的想法，请随时更新。</p>
<p>由于缺乏一个很好的例子，我希望读者能关注 <a class="link"   href="https://etherscan.io/address/0xbA6284cA128d72B25f1353FadD06Aa145D9095Af#code" >Ethstick <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，主要是因为我喜欢合约中的酷命名。但是，这个合约并没有使用任何扩展的精确度，它是用 <code>wei</code> 来处理的。所以这个合约会有四舍五入的问题，但只会在 <code>wei</code> 的层级上出现。它有一些更严重的缺陷，但这些都与区块链上的熵源难题有关。关于 Ethstick 合约的进一步讨论，我推荐你阅读 Peter Venesses 的另一篇文章：<a class="link"   href="https://vessenes.com/ethereum-contracts-are-going-to-be-candy-for-hackers/" >许多以太坊合约就是黑客的糖果 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="Tx-Origin-用作身份验证"><a href="#Tx-Origin-用作身份验证" class="headerlink" title="Tx.Origin 用作身份验证"></a>Tx.Origin 用作身份验证</h2><p>Solidity 中有一个全局变量， <code>tx.origin</code> ，它遍历整个调用栈并返回最初发送调用（或交易）的帐户的地址。在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。</p>
<p>有关进一步阅读，请参阅 <a class="link"   href="https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin" >Stack Exchange Question <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<a class="link"   href="https://vessenes.com/tx-origin-and-ethereum-oh-my/" >Peter Venesses 的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和 <a class="link"   href="https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514" >Solidity - Tx.Origin 攻击 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="漏洞-15"><a href="#漏洞-15" class="headerlink" title="漏洞"></a>漏洞</h3><p>授权用户使用 <code>tx.origin</code> 变量的合约通常容易受到网络钓鱼攻击的攻击，这可能会诱骗用户在有漏洞的合约上执行身份验证操作。</p>
<p>考虑下面这个简单的合约，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Phishable &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    </span><br><span class="line">    constructor (address _owner) &#123;</span><br><span class="line">        owner = _owner; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function () public payable &#123;&#125; // collect ether</span><br><span class="line"></span><br><span class="line">    function withdrawAll(address _recipient) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        _recipient.transfer(this.balance); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，在 [11]行 中，此合约授权 <code>withdrawAll()</code> 函数使用 <code>tx.origin</code> 。攻击者可以创建下面形式的合约，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;Phishable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AttackContract &#123; </span><br><span class="line">    </span><br><span class="line">    Phishable phishableContract; </span><br><span class="line">    address attacker; // The attackers address to receive funds.</span><br><span class="line"></span><br><span class="line">    constructor (Phishable _phishableContract, address _attackerAddress) &#123; </span><br><span class="line">        phishableContract = _phishableContract; </span><br><span class="line">        attacker = _attackerAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function () &#123; </span><br><span class="line">        phishableContract.withdrawAll(attacker); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要利用这个合约，攻击者会先部署它，然后说服 <code>Phishable</code> 合约的所有者发送一定数量的 ETH 到这个恶意合约。攻击者可能把这个合约伪装成他们自己的私人地址，或者对受害人进行社会工程学攻击让后者发送某种形式的交易。受害者除非很小心，否则可能不会注意到目标地址上有代码，或者攻击者可能将其伪装为多重签名钱包或某些高级存储钱包。</p>
<p>只要受害者向 <code>AttackContract</code> 地址发送了一个交易（有足够的 Gas），它将调用 <code>fallback</code> 函数，后者又以 <code>attacker</code> 为参数，调用 <code>Phishable</code> 合约中的 <code>withdrawAll()</code> 函数。这将导致所有资金从 <code>Phishable</code> 合约中撤回到 <code>attacker</code> 的地址。这是因为，首先初始化调用的地址是受害者（即 <code>Phishable</code> 合约中的 <code>owner</code> ）。因此， <code>tx.origin</code> 将等于 <code>owner</code> 、 <code>Phishable</code> 合约中 [11]行 中的 <code>require</code> 要求会通过，（合约中的钱可以全部被取出）。</p>
<h3 id="预防技术-15"><a href="#预防技术-15" class="headerlink" title="预防技术"></a>预防技术</h3><p> <code>tx.origin</code> 不应该用于智能合约授权。这并不是说该 <code>tx.origin</code> 变量不应该被使用。它确实在智能合约中有一些合法用例。例如，如果有人想要拒绝外部合约调用当前合约，他们可以实现一个从 <code>require(tx.origin == msg.sender)</code> 中实现这一要求。这可以防止中间合约调用当前合约，只将合约开放给常规无代码地址。</p>
<h3 id="真实世界的例子：未知-2"><a href="#真实世界的例子：未知-2" class="headerlink" title="真实世界的例子：未知"></a>真实世界的例子：未知</h3><p>我不知道真实世界中任何使用这一手段造成攻击的例子。</p>
<h2 id="以太坊机关"><a href="#以太坊机关" class="headerlink" title="以太坊机关"></a>以太坊机关</h2><p>我打算用社区发现的各种有趣机关填充本节。这些都保存在这个博客中，因为如果在实践中使用这些机关，它们可能有助于智能合约开发。</p>
<h3 id="无密钥的-ether"><a href="#无密钥的-ether" class="headerlink" title="无密钥的 ether"></a>无密钥的 ether</h3><p>合约地址是确定性的，这意味着它们可以在实际创建合约之前算出。创建合约的地址和产生自其他合约的地址都是这种情况。实际上，创建的合约地址取决于：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">keccak256(rlp.encode([&lt;account_address&gt;, &lt;transaction_nonce&gt;])</span><br></pre></td></tr></table></figure></div>

<p>从本质上讲，合约的地址就是立约账户及其交易 Nonce 的 <code>keccak256</code>哈希值  [^ 2]。用合约来创建合约时也是如此，只不过合约的 nonce 从 1开始，外部账户的 nonce 从 0 开始。</p>
<p>这意味着给定一个以太坊地址，我们可以计算出该地址可以产生的所有可能的合约地址。例如，如果地址 <code>0x123000...000</code> 是在其第 100 次交易中创建合约的，则所创合约的地址为 <code>keccak256(rlp.encode[0x123...000, 100])</code> ，也就是 <code>0xed4cafc88a13f5d58a163e61591b9385b6fe6d1a</code> （校对注：此处疑为作者笔误。EOA 的第 100 笔交易的 Nonce 应为 99，但意思是毫无问题的）。</p>
<p>这是什么意思呢？这意味着您可以将 ether 发送到预先确定的地址（你不知道那个地址的私钥，但可以确定您可以用自己的某个账户在该地址上创建合约）。您可以将 <code>ether</code> 发送到该地址，日后再在该地址上创建合约取回 Ether。构造函数可用于返回所有预先发送的 ether。因此，如果有人获得了你的以太坊私钥，攻击者很难发现你的以太坊地址还可以取得这些隐藏的 Ether。事实上，如果攻击者花去了太多交易次数，以致越过了取出隐藏 Ether 所需的 Nonce，这些隐藏的 Ether 都不可能再恢复了。</p>
<p>让我用合约说得更清楚一点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract KeylessHiddenEthCreator &#123; </span><br><span class="line">    uint public currentContractNonce = 1; // keep track of this contracts nonce publicly (it&#x27;s also found in the contracts state)</span><br><span class="line"></span><br><span class="line">    // determine future addresses which can hide ether. </span><br><span class="line">    function futureAddresses(uint8 nonce) public view returns (address) &#123;</span><br><span class="line">        if(nonce == 0) &#123;</span><br><span class="line">            return address(keccak256(0xd6, 0x94, this, 0x80));</span><br><span class="line">        &#125;</span><br><span class="line">        return address(keccak256(0xd6, 0x94, this, nonce));</span><br><span class="line">    // need to implement rlp encoding properly for a full range of nonces</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // increment the contract nonce or retrieve ether from a hidden/key-less account</span><br><span class="line">    // provided the nonce is correct</span><br><span class="line">    function retrieveHiddenEther(address beneficiary) public returns (address) &#123;</span><br><span class="line">    currentContractNonce +=1;</span><br><span class="line">       return new RecoverContract(beneficiary);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function () payable &#123;&#125; // Allow ether transfers (helps for playing in remix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract RecoverContract &#123; </span><br><span class="line">    constructor(address beneficiary) &#123;</span><br><span class="line">        selfdestruct(beneficiary); // don&#x27;t deploy code. Return the ether stored here to the beneficiary. </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>这个合约允许你存储无密钥的以太（相对安全，从某种意义上说你不能错误地忽略 Nonce）[^ 3]。 <code>futureAddresses()</code> 功能可用于计算此合约可产生的前127个合约地址，方法是指定 <code>nonce</code> 。如果您将 <code>ethe</code> r发送到其中一个地址，则可以在日后通过多次调用 <code>retrieveHiddenEther()</code> 来恢复。例如，如果您选择 <code>nonce=4</code> （并将 ether 发送到关联的地址），则需要调用 <code>retrieveHiddenEther()</code> 四次，然后 Ether 会回到 <code>beneficiary</code> 地址。</p>
<p>这可以在没有合约的情况下完成。您可以将 ether 发送到可以从您的一个标准以太坊帐户创建的地址，并在以后以正确的 Nonce 恢复。但是要小心，如果你不小心超过了恢复你的以太币所需的交易 Nonce，你的资金将永远丢失。</p>
<p>有关一些更高级的技巧，你可以用这个小窍门做更多的信息，我推荐阅读 <a class="link"   href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html" >Martin Swende 的文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h3 id="一次性地址"><a href="#一次性地址" class="headerlink" title="一次性地址"></a>一次性地址</h3><p>以太坊交易签名使用椭圆曲线数字签名算法（ECDSA）。通常，为了在以太坊上发送经过验证的交易，您需要使用您的以太坊私钥签署一条消息，该私钥授权从您的账户中支出。更详细一点，您签名的信息就是以太坊交易的一部分，具体而言包括  <code>to, value, gas, gasPrice, nonce, data</code> 领域。以太坊签名的结果是三个数字 <code>v</code> ， <code>r</code> 和 <code>s</code> 。我不会详细说明这些代表的内容，感兴趣的读者可以自行阅读  <a class="link"   href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" >ECDSA wiki页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（描述 <code>r</code> 和 <code>s</code> ）以及<a class="link"   href="https://ethereum.github.io/yellowpaper/paper.pdf" >以太坊黄皮书 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（附录F–描述 <code>v</code> ），以及为当前使用的  <code>v</code> 而作的 <a class="link"   href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" >EIP155 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p>所以我们知道以太坊交易签名包含一条消息和数字 <code>v</code> ， <code>r</code> 以及 <code>s</code> 。我们可以通过检查消息（即交易细节）、 <code>r</code> 和 <code>s</code> 是否能派生出以太坊地址，来检查签名是否有效。如果派生的以太坊地址匹配交易的  <code>from</code> 字段，那么我们知道 <code>r</code> 以及 <code>s</code> 是由拥有（或有权访问） <code>from</code> 字段的私钥的人创建，因此签名是有效的。</p>
<p>现在考虑一下，我们并不拥有一个私钥，而是为任意事务构建 <code>r</code> 值和 <code>s</code> 值。考虑我们有一个交易，参数为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;to ： “ 0xa9e ”，value ： 10e18，nonce ： 0 &#125;</span><br></pre></td></tr></table></figure></div>

<p>我忽略了其他参数。该交易将发送 10 ether 到 <code>0xa9e</code> 地址。现在让我们假设，我们生成了一些数字 <code>r</code> 和 <code>s</code> （这些有特定的范围）以及一个 <code>v</code> 。如果我们推导出与这些编号相关的以太坊地址，我们将得到一个随机的以太坊地址，且让我们假设为 <code>0x54321</code> 。知道这个地址，我们可以发送 10 ether 到地址 <code>0x54321</code> （不需要拥有该地址的私钥）。在将来的任何时候，我们都可以发送交易：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;to ： “ 0xa9e ”，value ： 10e18，nonce ： 0，from ： “ 0x54321 ” &#125;</span><br></pre></td></tr></table></figure></div>

<p>以及签名，即 <code>v</code> ，以及我们生成的 <code>r</code> 和 <code>s</code> 。这将是一个有效的交易，因为派生地址将与我们的 <code>from</code> 字段一致。这使我们可以将我们的钱从这个随机地址（0x54321）中分配到我们选择的地址 <code>0xa9e</code> 。因此，我们设法将 Ether 存储在我们没有私钥的地址中，并使用一次性交易来取回 Ether。</p>
<p>这个机关还可以无需信任的方式向许多人发送 Ether，正如 Nick Johnson 在 <a href="https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7"><em>如何将ether 发送给 11,440 个人</em></a> 中所描述的那样。</p>
<h2 id="有趣的加密相关的hacks-bugs列表"><a href="#有趣的加密相关的hacks-bugs列表" class="headerlink" title="有趣的加密相关的hacks&#x2F;bugs列表"></a>有趣的加密相关的hacks&#x2F;bugs列表</h2><ul>
<li><a class="link"   href="https://www.theregister.co.uk/2017/07/18/coindash_hack/" >CoinDash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/" >SmartBillions <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://steemit.com/cryptocurrency/@barrydutton/breaking-the-biggest-canadian-coin-exchange-quadrigacx-loses-67-000-usdeth-due-to-coding-error-funds-locked-in-an-executable" >Exchange Didn’t add “0x” to payload <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>[^ 2]: 交易 Nonce 就像一个交易计数器。每当你发送一次交易，它就会增加。<br>[^ 3]: 不要部署此合约来存储任何真实的 Ether。它仅用于演示目的。它没有固有的权限，如果你部署并使用这个合约，任何人都可以取出你的以太币。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul>
<li><a class="link"   href="https://github.com/infinityhacker" >yudan <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/editor-Ajian" >阿剑@EthFans <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
  </entry>
</search>
