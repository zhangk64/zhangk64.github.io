<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gas优化（一）</title>
    <url>/2024/04/12/GAS%20%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>以太坊网络上的每个操作，从简单的转账到复杂的合约交互，都需要消耗Gas。Gas机制不仅防止了网络资源的滥用，还通过设置交易的 Gas Limit 确保每个操作计算资源使用在合理范围内，从而保障网络的安全性和稳定性。</p>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><h3 id="减少存储变量的读取"><a href="#减少存储变量的读取" class="headerlink" title="减少存储变量的读取"></a>减少存储变量的读取</h3><p>读取存储变量至少需要100gas（在EVM中，每次第一次访问任何存储变量时都必须付费，这称为“冷”访问，需要花费2100个gas。第二次或连续一次被称为“热”访问，需要花费 100 Gas。），因为Solidity不会缓存存储读取。<br>如下例子中存储变量<code>_decimalsETH</code>被重复读取</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getTokensFromUSD(</span><br><span class="line">    address _tokenAddress,</span><br><span class="line">    uint256 _usdValue</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 tokenDecimals = _tokenDecimals[</span><br><span class="line">        _tokenAddress</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    return _decimalsETH &lt; tokenDecimals     //第一次</span><br><span class="line">        ? _usdValue</span><br><span class="line">            * 10 ** (tokenDecimals - _decimalsETH)   //第二次</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">        : _usdValue</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">            / 10 ** (_decimalsETH - tokenDecimals);   //第二次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>采用临时变量来缓存存储变量节省gas。</p>
<h3 id="使用存储指针"><a href="#使用存储指针" class="headerlink" title="使用存储指针"></a>使用存储指针</h3><p>将整个结构体从存储中复制到内存中，包含了不需要的变量。而使用存储指针，通过引用传递只进行一次存储加载而不需要再从内存复制回存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseReservedForCompound(</span><br><span class="line">    address _pendleMarket,</span><br><span class="line">    uint256[] calldata _amounts</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyChildContract(_pendleMarket)</span><br><span class="line">&#123;</span><br><span class="line">    CompoundStruct memory childInfo = pendleChildCompoundInfo[</span><br><span class="line">        _pendleMarket</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 length = childInfo.rewardTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">        childInfo.reservedForCompound[i] += _amounts[i];</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pendleChildCompoundInfo[_pendleMarket] = childInfo;</span><br><span class="line"></span><br><span class="line">    emit IncreaseReservedForCompound(</span><br><span class="line">        _pendleMarket,</span><br><span class="line">        _amounts</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>memery</code>改为<code>storage </code>，并删除<code>pendleChildCompoundInfo[_pendleMarket] = childInfo;</code>.</p>
<h3 id="减少0写入"><a href="#减少0写入" class="headerlink" title="减少0写入"></a>减少0写入</h3><p>在存储变量做计算赋值时，应避免0的计算。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseIncentiveA(</span><br><span class="line">    uint256 _value</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyIncentiveMaster</span><br><span class="line">&#123;</span><br><span class="line">    incentiveUSD[incentiveOwnerA] += _value;</span><br><span class="line"></span><br><span class="line">    emit IncentiveIncreasedA(</span><br><span class="line">        _value,</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>_value</code>如果为0，<code>incentiveUSD[incentiveOwnerA]</code>并没有发生变化，可以不进行加法运算，减少存储变量的读写操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">error ZeroValue();</span><br><span class="line">if(_value == 0) &#123;</span><br><span class="line">    revert ZeroValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先<code>_value</code>判断是否为0，再进行加法操作。</p>
<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><h3 id="临时变量的检查优先于存储变量的检查"><a href="#临时变量的检查优先于存储变量的检查" class="headerlink" title="临时变量的检查优先于存储变量的检查"></a>临时变量的检查优先于存储变量的检查</h3><p>由于函数内部开始执行正常逻辑前，会有多个判断条件，常量的判断先于存储变量的判断，在不满足判断的条件下可节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkLiquidatorNft(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _nftIdLiquidator</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">&#123;</span><br><span class="line">    if (positionLocked[_nftIdLiquidator] == true) &#123;</span><br><span class="line">        revert LiquidatorIsInPowerFarm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator == _nftId) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator &gt;= POSITION_NFT.getNextExpectedId()) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以将判断条件<code>_nftIdLiquidator == _nftId</code>放置函数的最前端。</p>
<h2 id="修饰符优化"><a href="#修饰符优化" class="headerlink" title="修饰符优化"></a>修饰符优化</h2><h3 id="选择合适的变量可见性"><a href="#选择合适的变量可见性" class="headerlink" title="选择合适的变量可见性"></a>选择合适的变量可见性</h3><p>避免使用公共变量（public），公共变量隐式创建一个getter函数，这可能会增加合约的大小和Gas使用。</p>
<p>父合约<code>contracts/WiseLendingDeclaration.sol</code>定义存储变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) public positionLendTokenData;</span><br></pre></td></tr></table></figure></div>
<p>子合约<code>contracts/WiseLowLevelHelper.sol</code>使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPositionLendingTokenByIndex(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _index</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    return positionLendTokenData[_nftId][_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>public</code>修饰符改为<code>internal</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) internal positionLendTokenData;</span><br></pre></td></tr></table></figure></div>


<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><h3 id="unchecked除法"><a href="#unchecked除法" class="headerlink" title="unchecked除法"></a>unchecked除法</h3><p>从 Solidity 0.8.0 版本开始，所有的算术运算默认就会进行溢出检查。Unchecked 代码块，提示编译器不安全地执行算术操作。前提是保证 unchecked 代码块中的内容能够安全的执行，从而可以节省Gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant ONE_WEEK = 7 days;</span><br><span class="line">function previewDistribution()</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    if (totalLpAssetsToDistribute == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (block.timestamp == lastInteraction) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (totalLpAssetsToDistribute &lt; ONE_WEEK) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 currentRate = totalLpAssetsToDistribute</span><br><span class="line">        / ONE_WEEK;                      // unckecked</span><br><span class="line"></span><br><span class="line">    uint256 additonalAssets = currentRate</span><br><span class="line">        * (block.timestamp - lastInteraction);</span><br><span class="line"></span><br><span class="line">    if (additonalAssets &gt; totalLpAssetsToDistribute) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return additonalAssets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分母为0或负数的情况，以上代码不需要检查，添加unchecked可以节省Gas。</p>
]]></content>
      <tags>
        <tag>智能合约审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
</search>
