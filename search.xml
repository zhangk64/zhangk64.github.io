<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gas优化（一）</title>
    <url>/2024/04/12/GAS%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>以太坊网络上的每个操作，从简单的转账到复杂的合约交互，都需要消耗Gas。Gas机制不仅防止了网络资源的滥用，还通过设置交易的 Gas Limit 确保每个操作计算资源使用在合理范围内，从而保障网络的安全性和稳定性。</p>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><h3 id="减少存储变量的读取"><a href="#减少存储变量的读取" class="headerlink" title="减少存储变量的读取"></a>减少存储变量的读取</h3><p>读取存储变量至少需要100gas（在EVM中，每次第一次访问任何存储变量时都必须付费，这称为“冷”访问，需要花费2100个gas。第二次或连续一次被称为“热”访问，需要花费 100 Gas。），因为Solidity不会缓存存储读取。<br>如下例子中存储变量<code>_decimalsETH</code>被重复读取</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getTokensFromUSD(</span><br><span class="line">    address _tokenAddress,</span><br><span class="line">    uint256 _usdValue</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 tokenDecimals = _tokenDecimals[</span><br><span class="line">        _tokenAddress</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    return _decimalsETH &lt; tokenDecimals     //第一次</span><br><span class="line">        ? _usdValue</span><br><span class="line">            * 10 ** (tokenDecimals - _decimalsETH)   //第二次</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">        : _usdValue</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">            / 10 ** (_decimalsETH - tokenDecimals);   //第二次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>采用临时变量来缓存存储变量节省gas。</p>
<h3 id="使用存储指针"><a href="#使用存储指针" class="headerlink" title="使用存储指针"></a>使用存储指针</h3><p>将整个结构体从存储中复制到内存中，包含了不需要的变量。而使用存储指针，通过引用传递只进行一次存储加载而不需要再从内存复制回存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseReservedForCompound(</span><br><span class="line">    address _pendleMarket,</span><br><span class="line">    uint256[] calldata _amounts</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyChildContract(_pendleMarket)</span><br><span class="line">&#123;</span><br><span class="line">    CompoundStruct memory childInfo = pendleChildCompoundInfo[</span><br><span class="line">        _pendleMarket</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 length = childInfo.rewardTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">        childInfo.reservedForCompound[i] += _amounts[i];</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pendleChildCompoundInfo[_pendleMarket] = childInfo;</span><br><span class="line"></span><br><span class="line">    emit IncreaseReservedForCompound(</span><br><span class="line">        _pendleMarket,</span><br><span class="line">        _amounts</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>memery</code>改为<code>storage </code>，并删除<code>pendleChildCompoundInfo[_pendleMarket] = childInfo;</code>.</p>
<h3 id="减少0写入"><a href="#减少0写入" class="headerlink" title="减少0写入"></a>减少0写入</h3><p>在存储变量做计算赋值时，应避免0的计算。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseIncentiveA(</span><br><span class="line">    uint256 _value</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyIncentiveMaster</span><br><span class="line">&#123;</span><br><span class="line">    incentiveUSD[incentiveOwnerA] += _value;</span><br><span class="line"></span><br><span class="line">    emit IncentiveIncreasedA(</span><br><span class="line">        _value,</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>_value</code>如果为0，<code>incentiveUSD[incentiveOwnerA]</code>并没有发生变化，可以不进行加法运算，减少存储变量的读写操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">error ZeroValue();</span><br><span class="line">if(_value == 0) &#123;</span><br><span class="line">    revert ZeroValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先<code>_value</code>判断是否为0，再进行加法操作。</p>
<h3 id="只读参数使用calldata比memory便宜"><a href="#只读参数使用calldata比memory便宜" class="headerlink" title="只读参数使用calldata比memory便宜"></a>只读参数使用calldata比memory便宜</h3><p>直接从calldata中加载函数输入或数据比从内存中加载更便宜，因为从calldata访问数据涉及的操作和gas成本较少。因此，建议仅在函数需要修改数据时使用memory（calldata无法修改）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setBaseURI(</span><br><span class="line">    string memory _newBaseURI   // 用calldata代替memory</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    baseURI = _newBaseURI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="变量优化"><a href="#变量优化" class="headerlink" title="变量优化"></a>变量优化</h2><h3 id="打包结构体成员变量"><a href="#打包结构体成员变量" class="headerlink" title="打包结构体成员变量"></a>打包结构体成员变量</h3><h3 id="打包存储变量"><a href="#打包存储变量" class="headerlink" title="打包存储变量"></a>打包存储变量</h3><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="函数命名式-returns-返回值"><a href="#函数命名式-returns-返回值" class="headerlink" title="函数命名式(returns)返回值"></a>函数命名式(returns)返回值</h3><p>Solidity中两个关键字：<code>return</code>和<code>returns</code>，区别是：</p>
<ul>
<li><code>return</code>: 在函数主体中，用于返回指定的变量；</li>
<li><code>returns</code>: 加在函数名后面，用于生命返回的变量类型及变量名。</li>
</ul>
<p>在returns中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。每个变量可以节省9gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TestContract  &#123;</span><br><span class="line">    function NoNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256) </span><br><span class="line">    &#123;</span><br><span class="line">        uint256 sum;</span><br><span class="line"></span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function UsingNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256 sum) </span><br><span class="line">    &#123;</span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="合并仅调用一次的internal函数"><a href="#合并仅调用一次的internal函数" class="headerlink" title="合并仅调用一次的internal函数"></a>合并仅调用一次的internal函数</h3><p>当某个被调用函数仅调用一次时，可以重构并合并到调用函数当中，函数调用会增加额外的堆栈和JUMP指令等开销。<br><strong>注：这可能会影响代码原有结构，适用于代码量少的函数，慎用。</strong></p>
<h2 id="修饰符优化"><a href="#修饰符优化" class="headerlink" title="修饰符优化"></a>修饰符优化</h2><h3 id="选择合适的变量可见性"><a href="#选择合适的变量可见性" class="headerlink" title="选择合适的变量可见性"></a>选择合适的变量可见性</h3><p>避免使用公共变量（public），公共变量隐式创建一个getter函数，这可能会增加合约的大小和Gas使用。</p>
<p>父合约<code>contracts/WiseLendingDeclaration.sol</code>定义存储变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) public positionLendTokenData;</span><br></pre></td></tr></table></figure></div>
<p>子合约<code>contracts/WiseLowLevelHelper.sol</code>使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPositionLendingTokenByIndex(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _index</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    return positionLendTokenData[_nftId][_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>public</code>修饰符改为<code>internal</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) internal positionLendTokenData;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用-payable-函数"><a href="#使用-payable-函数" class="headerlink" title="使用 payable 函数"></a>使用 payable 函数</h3><p>payable函数比非payable函数消耗更少的gas，因为payable函数允许用户在调用函数时传递非0或0ETH，而不需要检查ETH转账。<br><strong>注：虽然节省gas很重要，如果一个函数与接收ETH无关，即使能节省gas也不应附加任何payable修饰符。</strong></p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><h3 id="unchecked除法"><a href="#unchecked除法" class="headerlink" title="unchecked除法"></a>unchecked除法</h3><p>从 Solidity 0.8.0 版本开始，所有的算术运算默认就会进行溢出检查。Unchecked 代码块，提示编译器不安全地执行算术操作。前提是保证 unchecked 代码块中的内容能够安全的执行，从而可以节省Gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant ONE_WEEK = 7 days;</span><br><span class="line">function previewDistribution()</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    if (totalLpAssetsToDistribute == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (block.timestamp == lastInteraction) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (totalLpAssetsToDistribute &lt; ONE_WEEK) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 currentRate = totalLpAssetsToDistribute</span><br><span class="line">        / ONE_WEEK;                      // unckecked</span><br><span class="line"></span><br><span class="line">    uint256 additonalAssets = currentRate</span><br><span class="line">        * (block.timestamp - lastInteraction);</span><br><span class="line"></span><br><span class="line">    if (additonalAssets &gt; totalLpAssetsToDistribute) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return additonalAssets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分母为0或负数的情况，以上代码不需要检查，添加unchecked可以节省Gas。</p>
]]></content>
      <tags>
        <tag>智能合约审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>GAS优化（二）</title>
    <url>/2024/08/19/GAS%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><h3 id="临时变量的检查优先于存储变量的检查"><a href="#临时变量的检查优先于存储变量的检查" class="headerlink" title="临时变量的检查优先于存储变量的检查"></a>临时变量的检查优先于存储变量的检查</h3><p>由于函数内部开始执行正常逻辑前，会有多个判断条件，常量的判断先于存储变量的判断，在不满足判断的条件下可节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkLiquidatorNft(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _nftIdLiquidator</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">&#123;</span><br><span class="line">    if (positionLocked[_nftIdLiquidator] == true) &#123;</span><br><span class="line">        revert LiquidatorIsInPowerFarm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator == _nftId) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator &gt;= POSITION_NFT.getNextExpectedId()) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以将判断条件<code>_nftIdLiquidator == _nftId</code>放置函数的最前端。</p>
<h3 id="避免不必要的状态更新"><a href="#避免不必要的状态更新" class="headerlink" title="避免不必要的状态更新"></a>避免不必要的状态更新</h3><p>当频繁更新存储变量的状态时，应先检查是否曾经更新过，否则跳过更新（写入）操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setApprovalForAll(address operator, bool approved) public &#123;</span><br><span class="line">    isApprovedForAll[msg.sender][operator] = approved;</span><br><span class="line">    emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setApprovalForAll(address operator, bool approved) public &#123;</span><br><span class="line">    if (isApprovedForAll[msg.sender][operator] == approved) return;   //先判断</span><br><span class="line">    isApprovedForAll[msg.sender][operator] = approved;</span><br><span class="line">    emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="循环中避免昂贵的操作"><a href="#循环中避免昂贵的操作" class="headerlink" title="循环中避免昂贵的操作"></a>循环中避免昂贵的操作</h3><p>应该尽量避免在循环语句中进行昂贵的操作，比如读写存储操作，复杂的计算，外部调用和发送事情等。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setPoolFeeBulk(</span><br><span class="line">    address[] calldata _poolTokens,</span><br><span class="line">    uint256[] calldata _newFees</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 l = _poolTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line"></span><br><span class="line">        _checkValue(</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        WISE_LENDING.setPoolFee(</span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit PoolFeeChanged(       </span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i],</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>while循环中发送事件，会消耗更多的gas，应避免这种情况。</p>
<h3 id="循环中避免创建memory变量"><a href="#循环中避免创建memory变量" class="headerlink" title="循环中避免创建memory变量"></a>循环中避免创建memory变量</h3><p>不在循环中创建memory变量，可以减少每次循环创建memory变量的gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarInLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            uint256 doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarOutLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        uint256 doubleNum;                //在循环外定义变量</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="删除冗余的代码逻辑"><a href="#删除冗余的代码逻辑" class="headerlink" title="删除冗余的代码逻辑"></a>删除冗余的代码逻辑</h3><ul>
<li><p>结合代码上下文，对于可预测的执行结果，没有必要通过代码进行计算，可以进行简化代码，从而节省gas。<br>如以下代码就可以直接设置 num 变量的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function constantOutcome() public pure returns (uint256) &#123;</span><br><span class="line">    uint256 num = 0;</span><br><span class="line">    for (uint256 i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        num += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>当存储变量更新为address(0)时，可直接使用address(0)而不是去读取该存储变量（<strong>此处可能影响代码可读性</strong>）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address private _pendingMultiSourceLoanAddress;</span><br><span class="line"></span><br><span class="line">function finalUpdateMultiSourceLoanAddress(address _newAddress) external onlyOwner &#123;</span><br><span class="line">    if (_pendingMultiSourceLoanAddress != _newAddress) &#123;</span><br><span class="line">        revert InvalidAddressUpdateError();</span><br><span class="line">    &#125;</span><br><span class="line">    _multiSourceLoan = MultiSourceLoan(_pendingMultiSourceLoanAddress);</span><br><span class="line">    _pendingMultiSourceLoanAddress = address(0);</span><br><span class="line">    emit MultiSourceLoanUpdated(_pendingMultiSourceLoanAddress);  // 可直接使用address(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="使用更优的库函数"><a href="#使用更优的库函数" class="headerlink" title="使用更优的库函数"></a>使用更优的库函数</h3><p>将引用库多个函数调用合并为单个操作，利用直接按位操作，可减少多个函数调用相关的开销。<br>如，当前使用的库<code>LiquidityChunkOriginal</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library LiquidityChunkOriginal &#123;</span><br><span class="line">    function createChunk(</span><br><span class="line">        uint256 self,</span><br><span class="line">        int24 _tickLower,</span><br><span class="line">        int24 _tickUpper,</span><br><span class="line">        uint128 amount</span><br><span class="line">    ) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return addLiquidity(self, amount) + addTickLower(self, _tickLower) + addTickUpper(self, _tickUpper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addLiquidity(uint256 self, uint128 amount) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + uint256(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addTickLower(uint256 self, int24 _tickLower) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + (uint256(uint24(_tickLower)) &lt;&lt; 232);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addTickUpper(uint256 self, int24 _tickUpper) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + ((uint256(uint24(_tickUpper))) &lt;&lt; 208);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后的库<code>LiquidityChunkOptimized</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library LiquidityChunkOptimized &#123;</span><br><span class="line">    function createChunk(</span><br><span class="line">        uint256 self,</span><br><span class="line">        int24 _tickLower,</span><br><span class="line">        int24 _tickUpper,</span><br><span class="line">        uint128 amount</span><br><span class="line">    ) internal pure returns (uint256) &#123;</span><br><span class="line">        return uint256(uint24(_tickLower)) &lt;&lt; 232 | uint256(uint24(_tickUpper)) &lt;&lt; 208 | uint256(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="重复的代码进行重构"><a href="#重复的代码进行重构" class="headerlink" title="重复的代码进行重构"></a>重复的代码进行重构</h3><p>重复的代码结合上下文，可通过复用重构实现。<strong>注：这可能会影响程序原有的扩展性。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimFees(address token) external &#123;</span><br><span class="line">    updateFeeCredit(token, msg.sender);</span><br><span class="line">    uint256 claimable = getClaimableFees(token, msg.sender);</span><br><span class="line">    if (claimable == 0) revert NoFeesToClaim();</span><br><span class="line">    tokensData[token].unclaimedFees[msg.sender] = 0;</span><br><span class="line">    payable(msg.sender).transfer(claimable);</span><br><span class="line">    emit FeesClaimed(token, msg.sender, claimable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateFeeCredit(address token, address account) internal &#123;</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, account);</span><br><span class="line">    if (balance &gt; 0) &#123;</span><br><span class="line">        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span><br><span class="line">        data.unclaimedFees[account] += owed / PRECISION;</span><br><span class="line">        data.userFeeOffset[account] = data.cumulativeFeePerToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getClaimableFees(address token, address account) public view returns (uint256) &#123;</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, account);</span><br><span class="line">    uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span><br><span class="line">    return (owed / PRECISION) + data.unclaimedFees[account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>函数claimFees中调用了2个函数（updateFeeCredit和getClaimableFees），这个2个函数中包含了重复的实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TokenData storage data = tokensData[token];</span><br><span class="line">uint256 balance = balanceOf(token, account);</span><br></pre></td></tr></table></figure></div>
<p>通过重构原来的实现，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimFees(address token) external &#123;</span><br><span class="line">    updateFeeCredit(token, msg.sender);</span><br><span class="line">    uint256 claimable = getClaimableFees(token, msg.sender);</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, msg.sender);</span><br><span class="line">    if (balance &gt; 0) &#123;</span><br><span class="line">        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;</span><br><span class="line">        data.unclaimedFees[msg.sender] += owed / PRECISION;</span><br><span class="line">        data.userFeeOffset[msg.sender] = data.cumulativeFeePerToken;</span><br><span class="line">   &#125;</span><br><span class="line">    uint256 owed_ = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;</span><br><span class="line">    uint256 claimable = (owed_ / PRECISION) + data.unclaimedFees[msg.sender];</span><br><span class="line">    if (claimable == 0) revert NoFeesToClaim();</span><br><span class="line">    tokensData[token].unclaimedFees[msg.sender] = 0;</span><br><span class="line">    payable(msg.sender).transfer(claimable);</span><br><span class="line">    emit FeesClaimed(token, msg.sender, claimable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多余的代码"><a href="#多余的代码" class="headerlink" title="多余的代码"></a>多余的代码</h3><ul>
<li><p>两次进行函数修改器的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function depositEth(uint256 _vaultId) external payable vaultExists(_vaultId) vaultExists(_vaultId) &#123;</span><br><span class="line">    _vaultERC20s[ETH][_vaultId] += msg.value;</span><br><span class="line">    emit ERC20Deposited(_vaultId, ETH, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重复的处理逻辑</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function placeBid(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)</span><br><span class="line">    external</span><br><span class="line">    nonReentrant</span><br><span class="line">    returns (Auction memory)</span><br><span class="line">&#123;</span><br><span class="line">    _placeBidChecks(_nftAddress, _tokenId, _auction, _bid);</span><br><span class="line">     </span><br><span class="line">    uint256 currentHighestBid = _auction.highestBid;</span><br><span class="line">    // 以下判断在函数_placeBidChecks()中已有处理</span><br><span class="line">    if (_bid == 0 || (currentHighestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) &gt;= _bid)) &#123;</span><br><span class="line">        revert MinBidError(_bid);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _placeBidChecks(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">    virtual</span><br><span class="line">&#123;</span><br><span class="line">    _checkAuction(_nftAddress, _tokenId, _auction);</span><br><span class="line">    if (_bid == 0 || (_auction.highestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) &gt;= _bid)) &#123;</span><br><span class="line">        revert MinBidError(_bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>多余的函数参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createWithPermit(</span><br><span class="line">    uint256 tokenId,</span><br><span class="line">    address owner,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint256 deadline,</span><br><span class="line">    uint8 v,</span><br><span class="line">    bytes32 r,</span><br><span class="line">    bytes32 s</span><br><span class="line">) external override &#123;</span><br><span class="line">    if (msg.sender != owner) &#123;</span><br><span class="line">        revert Unauthorized();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonfungiblePositionManager.permit(address(this), tokenId, deadline, v, r, s);</span><br><span class="line">    nonfungiblePositionManager.safeTransferFrom(owner, address(this), tokenId, abi.encode(recipient));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>去掉参数<code>owner</code>，直接使用<code>msg.sender</code>。</p>
</li>
</ul>
<h3 id="存储变量只使用一次就无需缓存"><a href="#存储变量只使用一次就无需缓存" class="headerlink" title="存储变量只使用一次就无需缓存"></a>存储变量只使用一次就无需缓存</h3><p>当存储变量在当前函数中，只被读取一次，就不用缓存变量进行缓存，导致消耗更多的gas。直接使用即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setWhitelist(bytes32 merkleRoot) external &#123;</span><br><span class="line">    uint256 supply = curvesTokenSupply[msg.sender];   //只使用一次</span><br><span class="line">    if (supply &gt; 1) revert CurveAlreadyExists();</span><br><span class="line">    if (presalesMeta[msg.sender].merkleRoot != merkleRoot) &#123;</span><br><span class="line">        presalesMeta[msg.sender].merkleRoot = merkleRoot;</span><br><span class="line">        emit WhitelistUpdated(msg.sender, merkleRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="避免死代码"><a href="#避免死代码" class="headerlink" title="避免死代码"></a>避免死代码</h3><p>死代码是指永远也不会执行的代码，例如某个条件永远不可能满足，消耗了以太坊 gas 但没有任何作用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (balance &lt; 100) &#123;</span><br><span class="line">    if (balance &gt; 300) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>智能合约审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
</search>
