<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gas优化（一）</title>
    <url>/2024/04/12/GAS%20%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>以太坊网络上的每个操作，从简单的转账到复杂的合约交互，都需要消耗Gas。Gas机制不仅防止了网络资源的滥用，还通过设置交易的 Gas Limit 确保每个操作计算资源使用在合理范围内，从而保障网络的安全性和稳定性。</p>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><h3 id="减少存储变量的读取"><a href="#减少存储变量的读取" class="headerlink" title="减少存储变量的读取"></a>减少存储变量的读取</h3><p>读取存储变量至少需要100gas（在EVM中，每次第一次访问任何存储变量时都必须付费，这称为“冷”访问，需要花费2100个gas。第二次或连续一次被称为“热”访问，需要花费 100 Gas。），因为Solidity不会缓存存储读取。<br>如下例子中存储变量<code>_decimalsETH</code>被重复读取</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getTokensFromUSD(</span><br><span class="line">    address _tokenAddress,</span><br><span class="line">    uint256 _usdValue</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    uint8 tokenDecimals = _tokenDecimals[</span><br><span class="line">        _tokenAddress</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    return _decimalsETH &lt; tokenDecimals     //第一次</span><br><span class="line">        ? _usdValue</span><br><span class="line">            * 10 ** (tokenDecimals - _decimalsETH)   //第二次</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">        : _usdValue</span><br><span class="line">            * 10 ** decimals(_tokenAddress)</span><br><span class="line">            / latestResolver(_tokenAddress)</span><br><span class="line">            / 10 ** (_decimalsETH - tokenDecimals);   //第二次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>采用临时变量来缓存存储变量节省gas。</p>
<h3 id="使用存储指针"><a href="#使用存储指针" class="headerlink" title="使用存储指针"></a>使用存储指针</h3><p>将整个结构体从存储中复制到内存中，包含了不需要的变量。而使用存储指针，通过引用传递只进行一次存储加载而不需要再从内存复制回存储中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseReservedForCompound(</span><br><span class="line">    address _pendleMarket,</span><br><span class="line">    uint256[] calldata _amounts</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyChildContract(_pendleMarket)</span><br><span class="line">&#123;</span><br><span class="line">    CompoundStruct memory childInfo = pendleChildCompoundInfo[</span><br><span class="line">        _pendleMarket</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 length = childInfo.rewardTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">        childInfo.reservedForCompound[i] += _amounts[i];</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pendleChildCompoundInfo[_pendleMarket] = childInfo;</span><br><span class="line"></span><br><span class="line">    emit IncreaseReservedForCompound(</span><br><span class="line">        _pendleMarket,</span><br><span class="line">        _amounts</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>memery</code>改为<code>storage </code>，并删除<code>pendleChildCompoundInfo[_pendleMarket] = childInfo;</code>.</p>
<h3 id="减少0写入"><a href="#减少0写入" class="headerlink" title="减少0写入"></a>减少0写入</h3><p>在存储变量做计算赋值时，应避免0的计算。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function increaseIncentiveA(</span><br><span class="line">    uint256 _value</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyIncentiveMaster</span><br><span class="line">&#123;</span><br><span class="line">    incentiveUSD[incentiveOwnerA] += _value;</span><br><span class="line"></span><br><span class="line">    emit IncentiveIncreasedA(</span><br><span class="line">        _value,</span><br><span class="line">        block.timestamp</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>_value</code>如果为0，<code>incentiveUSD[incentiveOwnerA]</code>并没有发生变化，可以不进行加法运算，减少存储变量的读写操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">error ZeroValue();</span><br><span class="line">if(_value == 0) &#123;</span><br><span class="line">    revert ZeroValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先<code>_value</code>判断是否为0，再进行加法操作。</p>
<h3 id="只读参数使用calldata比memory便宜"><a href="#只读参数使用calldata比memory便宜" class="headerlink" title="只读参数使用calldata比memory便宜"></a>只读参数使用calldata比memory便宜</h3><p>直接从calldata中加载函数输入或数据比从内存中加载更便宜，因为从calldata访问数据涉及的操作和gas成本较少。因此，建议仅在函数需要修改数据时使用memory（calldata无法修改）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setBaseURI(</span><br><span class="line">    string memory _newBaseURI   // 用calldata代替memory</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    baseURI = _newBaseURI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><h3 id="临时变量的检查优先于存储变量的检查"><a href="#临时变量的检查优先于存储变量的检查" class="headerlink" title="临时变量的检查优先于存储变量的检查"></a>临时变量的检查优先于存储变量的检查</h3><p>由于函数内部开始执行正常逻辑前，会有多个判断条件，常量的判断先于存储变量的判断，在不满足判断的条件下可节省gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _checkLiquidatorNft(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _nftIdLiquidator</span><br><span class="line">)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">&#123;</span><br><span class="line">    if (positionLocked[_nftIdLiquidator] == true) &#123;</span><br><span class="line">        revert LiquidatorIsInPowerFarm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator == _nftId) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_nftIdLiquidator &gt;= POSITION_NFT.getNextExpectedId()) &#123;</span><br><span class="line">        revert InvalidLiquidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以将判断条件<code>_nftIdLiquidator == _nftId</code>放置函数的最前端。</p>
<h3 id="循环中避免昂贵的操作"><a href="#循环中避免昂贵的操作" class="headerlink" title="循环中避免昂贵的操作"></a>循环中避免昂贵的操作</h3><p>应该尽量避免在循环语句中进行昂贵的操作，比如读写存储操作，复杂的计算，外部调用和发送事情等。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setPoolFeeBulk(</span><br><span class="line">    address[] calldata _poolTokens,</span><br><span class="line">    uint256[] calldata _newFees</span><br><span class="line">)</span><br><span class="line">    external</span><br><span class="line">    onlyMaster</span><br><span class="line">&#123;</span><br><span class="line">    uint256 i;</span><br><span class="line">    uint256 l = _poolTokens.length;</span><br><span class="line"></span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line"></span><br><span class="line">        _checkValue(</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        WISE_LENDING.setPoolFee(</span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit PoolFeeChanged(       </span><br><span class="line">            _poolTokens[i],</span><br><span class="line">            _newFees[i],</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        unchecked &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>while循环中发送事件，会消耗更多的gas，应避免这种情况。</p>
<h3 id="循环中避免创建memory变量"><a href="#循环中避免创建memory变量" class="headerlink" title="循环中避免创建memory变量"></a>循环中避免创建memory变量</h3><p>不在循环中创建memory变量，可以减少每次循环创建memory变量的gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarInLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            uint256 doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>优化后，可节省gas</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract VarOutLoop &#123;</span><br><span class="line">    uint256[] numbers = [1,2,3,4,5];</span><br><span class="line">    uint256 total;</span><br><span class="line">    function double(uint256 num) public pure returns(uint256 ans) &#123;</span><br><span class="line">        ans = num * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    function doubleNumbers() public &#123;</span><br><span class="line">        uint256 len = numbers.length;</span><br><span class="line">        uint256 doubleNum;                //在循环外定义变量</span><br><span class="line">        for(uint256 i; i &lt; len; ++i) &#123;</span><br><span class="line">            doubleNum =  double(numbers[i]);</span><br><span class="line">            total = total + doubleNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="函数命名式-returns-返回值"><a href="#函数命名式-returns-返回值" class="headerlink" title="函数命名式(returns)返回值"></a>函数命名式(returns)返回值</h3><p>Solidity中两个关键字：<code>return</code>和<code>returns</code>，区别是：</p>
<ul>
<li><code>return</code>: 在函数主体中，用于返回指定的变量；</li>
<li><code>returns</code>: 加在函数名后面，用于生命返回的变量类型及变量名。</li>
</ul>
<p>在returns中标明返回变量的名称，这样solidity会自动给这些变量初始化，并且自动返回这些函数的值，不需要加return。每个变量可以节省9gas。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TestContract  &#123;</span><br><span class="line">    function NoNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256) </span><br><span class="line">    &#123;</span><br><span class="line">        uint256 sum;</span><br><span class="line"></span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function UsingNamedReturn(uint256[] calldata inputs) </span><br><span class="line">        external </span><br><span class="line">        pure </span><br><span class="line">        returns(uint256 sum) </span><br><span class="line">    &#123;</span><br><span class="line">        for(uint256 i; i&lt;inputs.length; i++) &#123;</span><br><span class="line">            sum += inputs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h2 id="修饰符优化"><a href="#修饰符优化" class="headerlink" title="修饰符优化"></a>修饰符优化</h2><h3 id="选择合适的变量可见性"><a href="#选择合适的变量可见性" class="headerlink" title="选择合适的变量可见性"></a>选择合适的变量可见性</h3><p>避免使用公共变量（public），公共变量隐式创建一个getter函数，这可能会增加合约的大小和Gas使用。</p>
<p>父合约<code>contracts/WiseLendingDeclaration.sol</code>定义存储变量：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) public positionLendTokenData;</span><br></pre></td></tr></table></figure></div>
<p>子合约<code>contracts/WiseLowLevelHelper.sol</code>使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPositionLendingTokenByIndex(</span><br><span class="line">    uint256 _nftId,</span><br><span class="line">    uint256 _index</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    return positionLendTokenData[_nftId][_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>将<code>public</code>修饰符改为<code>internal</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(uint256 =&gt; address[]) internal positionLendTokenData;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用-payable-函数"><a href="#使用-payable-函数" class="headerlink" title="使用 payable 函数"></a>使用 payable 函数</h3><p>payable函数比非payable函数消耗更少的gas，因为payable函数允许用户在调用函数时传递非0或0ETH，而不需要检查ETH转账。<br>注：虽然节省gas很重要，如果一个函数与接收ETH无关，即使能节省gas也不应附加任何payable修饰符。</p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><h3 id="unchecked除法"><a href="#unchecked除法" class="headerlink" title="unchecked除法"></a>unchecked除法</h3><p>从 Solidity 0.8.0 版本开始，所有的算术运算默认就会进行溢出检查。Unchecked 代码块，提示编译器不安全地执行算术操作。前提是保证 unchecked 代码块中的内容能够安全的执行，从而可以节省Gas成本。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant ONE_WEEK = 7 days;</span><br><span class="line">function previewDistribution()</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    if (totalLpAssetsToDistribute == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (block.timestamp == lastInteraction) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (totalLpAssetsToDistribute &lt; ONE_WEEK) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint256 currentRate = totalLpAssetsToDistribute</span><br><span class="line">        / ONE_WEEK;                      // unckecked</span><br><span class="line"></span><br><span class="line">    uint256 additonalAssets = currentRate</span><br><span class="line">        * (block.timestamp - lastInteraction);</span><br><span class="line"></span><br><span class="line">    if (additonalAssets &gt; totalLpAssetsToDistribute) &#123;</span><br><span class="line">        return totalLpAssetsToDistribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return additonalAssets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分母为0或负数的情况，以上代码不需要检查，添加unchecked可以节省Gas。</p>
]]></content>
      <tags>
        <tag>智能合约审计</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
</search>
